"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mendoza";
exports.ids = ["vendor-chunks/mendoza"];
exports.modules = {

/***/ "(ssr)/./node_modules/mendoza/dist/index.cjs":
/*!*********************************************!*\
  !*** ./node_modules/mendoza/dist/index.cjs ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value)=>key in obj ? __defProp$1(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value)=>{\n    __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nconst OPS = [\n    \"Value\",\n    \"Copy\",\n    \"Blank\",\n    \"ReturnIntoArray\",\n    \"ReturnIntoObject\",\n    \"ReturnIntoObjectSameKey\",\n    \"PushField\",\n    \"PushElement\",\n    \"PushParent\",\n    \"Pop\",\n    \"PushFieldCopy\",\n    \"PushFieldBlank\",\n    \"PushElementCopy\",\n    \"PushElementBlank\",\n    \"ReturnIntoObjectPop\",\n    \"ReturnIntoObjectSameKeyPop\",\n    \"ReturnIntoArrayPop\",\n    \"ObjectSetFieldValue\",\n    \"ObjectCopyField\",\n    \"ObjectDeleteField\",\n    \"ArrayAppendValue\",\n    \"ArrayAppendSlice\",\n    \"StringAppendString\",\n    \"StringAppendSlice\"\n];\nclass Patcher {\n    constructor(model, root, patch){\n        __publicField$1(this, \"model\");\n        __publicField$1(this, \"root\");\n        __publicField$1(this, \"patch\");\n        __publicField$1(this, \"i\");\n        __publicField$1(this, \"inputStack\");\n        __publicField$1(this, \"outputStack\");\n        this.model = model;\n        this.root = root;\n        this.patch = patch;\n        this.i = 0;\n        this.inputStack = [];\n        this.outputStack = [];\n    }\n    read() {\n        return this.patch[this.i++];\n    }\n    process() {\n        this.inputStack.push({\n            value: this.root\n        });\n        this.outputStack.push({\n            value: this.root\n        });\n        for(; this.i < this.patch.length;){\n            let opcode = this.read();\n            let op = OPS[opcode];\n            if (!op) throw new Error(\"Unknown opcode: \".concat(opcode));\n            let processor = \"process\".concat(op);\n            this[processor].apply(this);\n        }\n        let entry = this.outputStack.pop();\n        return this.finalizeOutput(entry);\n    }\n    inputEntry() {\n        return this.inputStack[this.inputStack.length - 1];\n    }\n    inputKey(entry, idx) {\n        if (!entry.keys) {\n            entry.keys = this.model.objectGetKeys(entry.value).sort();\n        }\n        return entry.keys[idx];\n    }\n    outputEntry() {\n        return this.outputStack[this.outputStack.length - 1];\n    }\n    outputArray() {\n        let entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyArray(entry.value);\n        }\n        return entry.writeValue;\n    }\n    outputObject() {\n        let entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyObject(entry.value);\n        }\n        return entry.writeValue;\n    }\n    outputString() {\n        let entry = this.outputEntry();\n        if (!entry.writeValue) {\n            entry.writeValue = this.model.copyString(entry.value);\n        }\n        return entry.writeValue;\n    }\n    finalizeOutput(entry) {\n        if (entry.writeValue) {\n            return this.model.finalize(entry.writeValue);\n        } else {\n            return entry.value;\n        }\n    }\n    // Processors:\n    processValue() {\n        let value = this.model.wrap(this.read());\n        this.outputStack.push({\n            value\n        });\n    }\n    processCopy() {\n        let input = this.inputEntry();\n        this.outputStack.push({\n            value: input.value\n        });\n    }\n    processBlank() {\n        this.outputStack.push({\n            value: null\n        });\n    }\n    processReturnIntoArray() {\n        let entry = this.outputStack.pop();\n        let result = this.finalizeOutput(entry);\n        let arr = this.outputArray();\n        this.model.arrayAppendValue(arr, result);\n    }\n    processReturnIntoObject() {\n        let key = this.read();\n        let entry = this.outputStack.pop();\n        let result = this.finalizeOutput(entry);\n        result = this.model.markChanged(result);\n        let obj = this.outputObject();\n        this.model.objectSetField(obj, key, result);\n    }\n    processReturnIntoObjectSameKey() {\n        let input = this.inputEntry();\n        let entry = this.outputStack.pop();\n        let result = this.finalizeOutput(entry);\n        let obj = this.outputObject();\n        this.model.objectSetField(obj, input.key, result);\n    }\n    processPushField() {\n        let idx = this.read();\n        let entry = this.inputEntry();\n        let key = this.inputKey(entry, idx);\n        let value = this.model.objectGetField(entry.value, key);\n        this.inputStack.push({\n            value,\n            key\n        });\n    }\n    processPushElement() {\n        let idx = this.read();\n        let entry = this.inputEntry();\n        let value = this.model.arrayGetElement(entry.value, idx);\n        this.inputStack.push({\n            value\n        });\n    }\n    processPop() {\n        this.inputStack.pop();\n    }\n    processPushFieldCopy() {\n        this.processPushField();\n        this.processCopy();\n    }\n    processPushFieldBlank() {\n        this.processPushField();\n        this.processBlank();\n    }\n    processPushElementCopy() {\n        this.processPushElement();\n        this.processCopy();\n    }\n    processPushElementBlank() {\n        this.processPushElement();\n        this.processBlank();\n    }\n    processReturnIntoObjectPop() {\n        this.processReturnIntoObject();\n        this.processPop();\n    }\n    processReturnIntoObjectSameKeyPop() {\n        this.processReturnIntoObjectSameKey();\n        this.processPop();\n    }\n    processReturnIntoArrayPop() {\n        this.processReturnIntoArray();\n        this.processPop();\n    }\n    processObjectSetFieldValue() {\n        this.processValue();\n        this.processReturnIntoObject();\n    }\n    processObjectCopyField() {\n        this.processPushField();\n        this.processCopy();\n        this.processReturnIntoObjectSameKey();\n        this.processPop();\n    }\n    processObjectDeleteField() {\n        let idx = this.read();\n        let entry = this.inputEntry();\n        let key = this.inputKey(entry, idx);\n        let obj = this.outputObject();\n        this.model.objectDeleteField(obj, key);\n    }\n    processArrayAppendValue() {\n        let value = this.model.wrap(this.read());\n        let arr = this.outputArray();\n        this.model.arrayAppendValue(arr, value);\n    }\n    processArrayAppendSlice() {\n        let left = this.read();\n        let right = this.read();\n        let str = this.outputArray();\n        let val = this.inputEntry().value;\n        this.model.arrayAppendSlice(str, val, left, right);\n    }\n    processStringAppendString() {\n        let value = this.model.wrap(this.read());\n        let str = this.outputString();\n        this.model.stringAppendValue(str, value);\n    }\n    processStringAppendSlice() {\n        let left = this.read();\n        let right = this.read();\n        let str = this.outputString();\n        let val = this.inputEntry().value;\n        this.model.stringAppendSlice(str, val, left, right);\n    }\n}\nfunction utf8charSize(code) {\n    if (code >> 16) {\n        return 4;\n    } else if (code >> 11) {\n        return 3;\n    } else if (code >> 7) {\n        return 2;\n    } else {\n        return 1;\n    }\n}\nfunction utf8stringSize(str) {\n    let b = 0;\n    for(let i = 0; i < str.length; i++){\n        let code = str.codePointAt(i);\n        let size = utf8charSize(code);\n        if (size == 4) i++;\n        b += size;\n    }\n    return b;\n}\nfunction utf8resolveIndex(str, idx) {\n    let start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let byteCount = start;\n    let ucsIdx = 0;\n    for(ucsIdx = start; byteCount < idx; ucsIdx++){\n        let code = str.codePointAt(ucsIdx);\n        let size = utf8charSize(code);\n        if (size === 4) ucsIdx++;\n        byteCount += size;\n    }\n    return ucsIdx;\n}\nfunction commonPrefix(str, str2) {\n    let len = Math.min(str.length, str2.length);\n    let b = 0;\n    for(let i = 0; i < len;){\n        let aPoint = str.codePointAt(i);\n        let bPoint = str2.codePointAt(i);\n        if (aPoint !== bPoint) return b;\n        let size = utf8charSize(aPoint);\n        b += size;\n        i += size === 4 ? 2 : 1;\n    }\n    return b;\n}\nfunction commonSuffix(str, str2) {\n    let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let len = Math.min(str.length, str2.length) - prefix;\n    let b = 0;\n    for(let i = 0; i < len;){\n        let aPoint = str.codePointAt(str.length - 1 - i);\n        let bPoint = str2.codePointAt(str2.length - 1 - i);\n        if (aPoint !== bPoint) return b;\n        let size = utf8charSize(aPoint);\n        b += size;\n        i += size === 4 ? 2 : 1;\n    }\n    return b;\n}\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>{\n    __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nclass IncrementalModel {\n    constructor(meta){\n        __publicField(this, \"meta\");\n        this.meta = meta;\n    }\n    wrap(data) {\n        return this.wrapWithMeta(data, this.meta, this.meta);\n    }\n    wrapWithMeta(data, startMeta) {\n        let endMeta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.meta;\n        return {\n            data,\n            startMeta,\n            endMeta\n        };\n    }\n    asObject(value) {\n        if (!value.content) {\n            let fields = {};\n            for (let [key, val] of Object.entries(value.data)){\n                fields[key] = this.wrapWithMeta(val, value.startMeta);\n            }\n            value.content = {\n                type: \"object\",\n                fields\n            };\n        }\n        return value.content;\n    }\n    asArray(value) {\n        if (!value.content) {\n            let elements = value.data.map((item)=>this.wrapWithMeta(item, value.startMeta));\n            let metas = elements.map(()=>this.meta);\n            value.content = {\n                type: \"array\",\n                elements,\n                metas\n            };\n        }\n        return value.content;\n    }\n    asString(value) {\n        if (!value.content) {\n            let str = value.data;\n            let part = {\n                value: str,\n                utf8size: utf8stringSize(str),\n                uses: [],\n                startMeta: value.startMeta,\n                endMeta: value.endMeta\n            };\n            value.content = this.stringFromParts([\n                part\n            ]);\n        }\n        return value.content;\n    }\n    stringFromParts(parts) {\n        let str = {\n            type: \"string\",\n            parts\n        };\n        for (let part of parts){\n            part.uses.push(str);\n        }\n        return str;\n    }\n    objectGetKeys(value) {\n        if (value.content) {\n            return Object.keys(value.content.fields);\n        } else {\n            return Object.keys(value.data);\n        }\n    }\n    objectGetField(value, key) {\n        let obj = this.asObject(value);\n        return obj.fields[key];\n    }\n    arrayGetElement(value, idx) {\n        let arr = this.asArray(value);\n        return arr.elements[idx];\n    }\n    finalize(content) {\n        this.updateEndMeta(content);\n        return {\n            content,\n            startMeta: this.meta,\n            endMeta: this.meta\n        };\n    }\n    markChanged(value) {\n        return this.wrap(unwrap(value));\n    }\n    updateEndMeta(content) {\n        if (content.type == \"string\") {\n            for (let part of content.parts){\n                part.endMeta = this.meta;\n            }\n        } else {\n            if (content.type === \"array\") {\n                for (let val of content.elements){\n                    if (val.content && val.endMeta !== this.meta) {\n                        this.updateEndMeta(val.content);\n                    }\n                    val.endMeta = this.meta;\n                }\n            } else {\n                for (let val of Object.values(content.fields)){\n                    if (val.content && val.endMeta !== this.meta) {\n                        this.updateEndMeta(val.content);\n                    }\n                    val.endMeta = this.meta;\n                }\n            }\n        }\n    }\n    copyString(value) {\n        if (value) {\n            let other = this.asString(value);\n            return this.stringFromParts(other.parts.slice());\n        } else {\n            return {\n                type: \"string\",\n                parts: []\n            };\n        }\n    }\n    copyObject(value) {\n        let obj = {\n            type: \"object\",\n            fields: {}\n        };\n        if (value) {\n            let other = this.asObject(value);\n            Object.assign(obj.fields, other.fields);\n        }\n        return obj;\n    }\n    copyArray(value) {\n        let arr = value ? this.asArray(value) : null;\n        let elements = arr ? arr.elements : [];\n        let metas = arr ? arr.metas : [];\n        return {\n            type: \"array\",\n            elements,\n            metas\n        };\n    }\n    objectSetField(target, key, value) {\n        target.fields[key] = value;\n    }\n    objectDeleteField(target, key) {\n        delete target.fields[key];\n    }\n    arrayAppendValue(target, value) {\n        target.elements.push(value);\n        target.metas.push(this.meta);\n    }\n    arrayAppendSlice(target, source, left, right) {\n        let arr = this.asArray(source);\n        let samePosition = arr.elements.length === left;\n        target.elements.push(...arr.elements.slice(left, right));\n        if (samePosition) {\n            target.metas.push(...arr.metas.slice(left, right));\n        } else {\n            for(let i = left; i < right; i++){\n                target.metas.push(this.meta);\n            }\n        }\n    }\n    stringAppendValue(target, value) {\n        let str = this.asString(value);\n        for (let part of str.parts){\n            this.stringAppendPart(target, part);\n        }\n    }\n    stringAppendPart(target, part) {\n        target.parts.push(part);\n        part.uses.push(target);\n    }\n    resolveStringPart(str, from, len) {\n        if (len === 0) return from;\n        for(let i = from; i < str.parts.length; i++){\n            let part = str.parts[i];\n            if (len === part.utf8size) {\n                return i + 1;\n            }\n            if (len < part.utf8size) {\n                this.splitString(part, len);\n                return i + 1;\n            }\n            len -= part.utf8size;\n        }\n        throw new Error(\"splitting string out of bounds\");\n    }\n    splitString(part, idx) {\n        let leftValue;\n        let rightValue;\n        let leftSize = idx;\n        let rightSize = part.utf8size - leftSize;\n        if (part.utf8size !== part.value.length) {\n            let byteCount = 0;\n            for(idx = 0; byteCount < leftSize; idx++){\n                let code = part.value.codePointAt(idx);\n                let size = utf8charSize(code);\n                if (size === 4) idx++;\n                byteCount += size;\n            }\n        }\n        leftValue = part.value.slice(0, idx);\n        rightValue = part.value.slice(idx);\n        let newPart = {\n            value: rightValue,\n            utf8size: rightSize,\n            uses: part.uses.slice(),\n            startMeta: part.startMeta,\n            endMeta: part.endMeta\n        };\n        part.value = leftValue;\n        part.utf8size = leftSize;\n        for (let use of part.uses){\n            let ndx = use.parts.indexOf(part);\n            if (ndx === -1) throw new Error(\"bug: mismatch between string parts and use.\");\n            use.parts.splice(ndx + 1, 0, newPart);\n        }\n    }\n    stringAppendSlice(target, source, left, right) {\n        let str = this.asString(source);\n        let firstPart = this.resolveStringPart(str, 0, left);\n        let lastPart = this.resolveStringPart(str, firstPart, right - left);\n        for(let i = firstPart; i < lastPart; i++){\n            let part = str.parts[i];\n            this.stringAppendPart(target, part);\n        }\n    }\n}\nfunction wrap(data, meta) {\n    return {\n        data,\n        startMeta: meta,\n        endMeta: meta\n    };\n}\nfunction unwrap(value) {\n    if (typeof value.data !== \"undefined\") return value.data;\n    let result;\n    let content = value.content;\n    switch(content.type){\n        case \"string\":\n            result = content.parts.map((part)=>part.value).join(\"\");\n            break;\n        case \"array\":\n            result = content.elements.map((val)=>unwrap(val));\n            break;\n        case \"object\":\n            {\n                result = {};\n                for (let [key, val] of Object.entries(content.fields)){\n                    result[key] = unwrap(val);\n                }\n            }\n    }\n    value.data = result;\n    return result;\n}\nfunction getType(value) {\n    if (value.content) return value.content.type;\n    if (Array.isArray(value.data)) return \"array\";\n    if (value.data === null) return \"null\";\n    return typeof value.data;\n}\nfunction rebaseValue(left, right) {\n    let leftType = getType(left);\n    let rightType = getType(right);\n    if (leftType !== rightType) return right;\n    let leftModel = new IncrementalModel(left.endMeta);\n    let rightModel = new IncrementalModel(right.endMeta);\n    switch(leftType){\n        case \"object\":\n            {\n                let leftObj = leftModel.asObject(left);\n                let rightObj = rightModel.asObject(right);\n                let identicalFieldCount = 0;\n                let leftFieldCount = Object.keys(leftObj.fields).length;\n                let rightFieldCount = Object.keys(rightObj.fields).length;\n                for (let [key, rightVal] of Object.entries(rightObj.fields)){\n                    let leftVal = leftObj.fields[key];\n                    if (leftVal) {\n                        rightObj.fields[key] = rebaseValue(leftVal, rightVal);\n                        if (rightObj.fields[key] === leftVal) {\n                            identicalFieldCount++;\n                        }\n                    }\n                }\n                let isIdentical = leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount;\n                return isIdentical ? left : right;\n            }\n        case \"array\":\n            {\n                let leftArr = leftModel.asArray(left);\n                let rightArr = rightModel.asArray(right);\n                if (leftArr.elements.length !== rightArr.elements.length) {\n                    break;\n                }\n                let numRebased = 0;\n                for(let i = 0; i < rightArr.elements.length; i++){\n                    rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]);\n                    if (rightArr.elements[i] !== leftArr.elements[i]) {\n                        numRebased++;\n                    }\n                }\n                return numRebased === 0 ? left : right;\n            }\n        case \"null\":\n        case \"boolean\":\n        case \"number\":\n            {\n                if (unwrap(left) === unwrap(right)) return left;\n                break;\n            }\n        case \"string\":\n            {\n                let leftRaw = unwrap(left);\n                let rightRaw = unwrap(right);\n                if (leftRaw === rightRaw) return left;\n                let result = rightModel.copyString(null);\n                let prefix = commonPrefix(leftRaw, rightRaw);\n                let suffix = commonSuffix(leftRaw, rightRaw, prefix);\n                let rightLen = utf8stringSize(rightRaw);\n                let leftLen = utf8stringSize(leftRaw);\n                if (0 < prefix) {\n                    rightModel.stringAppendSlice(result, left, 0, prefix);\n                }\n                if (prefix < rightLen - suffix) {\n                    rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix);\n                }\n                if (leftLen - suffix < leftLen) {\n                    rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);\n                }\n                let value = rightModel.finalize(result);\n                if (unwrap(value) !== rightRaw) throw new Error(\"incorrect string rebase\");\n                return value;\n            }\n    }\n    return right;\n}\nfunction applyPatch$1(left, patch, startMeta) {\n    let model = new IncrementalModel(startMeta);\n    let patcher = new Patcher(model, left, patch);\n    return patcher.process();\n}\nvar incrementalPatcher = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    applyPatch: applyPatch$1,\n    getType: getType,\n    rebaseValue: rebaseValue,\n    unwrap: unwrap,\n    wrap: wrap\n});\nclass SimpleModel {\n    wrap(data) {\n        return data;\n    }\n    finalize(b) {\n        if (Array.isArray(b)) {\n            return b;\n        } else {\n            return b.data;\n        }\n    }\n    markChanged(value) {\n        return value;\n    }\n    objectGetKeys(value) {\n        return Object.keys(value);\n    }\n    objectGetField(value, key) {\n        return value[key];\n    }\n    arrayGetElement(value, idx) {\n        return value[idx];\n    }\n    copyObject(value) {\n        let res = {\n            type: \"object\",\n            data: {}\n        };\n        if (value !== null) {\n            for (let [key, val] of Object.entries(value)){\n                res.data[key] = val;\n            }\n        }\n        return res;\n    }\n    copyArray(value) {\n        if (value === null) return [];\n        return value.slice();\n    }\n    copyString(value) {\n        return {\n            type: \"string\",\n            data: value === null ? \"\" : value\n        };\n    }\n    objectSetField(target, key, value) {\n        target.data[key] = value;\n    }\n    objectDeleteField(target, key) {\n        delete target.data[key];\n    }\n    arrayAppendValue(target, value) {\n        target.push(value);\n    }\n    arrayAppendSlice(target, source, left, right) {\n        target.push(...source.slice(left, right));\n    }\n    stringAppendSlice(target, source, left, right) {\n        const sourceString = source;\n        const leftPos = utf8resolveIndex(sourceString, left);\n        const rightPos = utf8resolveIndex(sourceString, right, leftPos);\n        target.data += sourceString.slice(leftPos, rightPos);\n    }\n    stringAppendValue(target, value) {\n        target.data += value;\n    }\n}\nfunction applyPatch(left, patch) {\n    let root = left;\n    let patcher = new Patcher(new SimpleModel(), root, patch);\n    return patcher.process();\n}\nexports.applyPatch = applyPatch;\nexports.incremental = incrementalPatcher; //# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9kaXN0L2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFDM0NHLE9BQU87QUFDVCxDQUFDLEVBQUM7QUFDRixJQUFJQyxjQUFjSixPQUFPQyxjQUFjO0FBQ3ZDLElBQUlJLG9CQUFvQixDQUFDQyxLQUFLQyxLQUFLSixRQUFVSSxPQUFPRCxNQUFNRixZQUFZRSxLQUFLQyxLQUFLO1FBQzlFQyxZQUFZO1FBQ1pDLGNBQWM7UUFDZEMsVUFBVTtRQUNWUDtJQUNGLEtBQUtHLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHSjtBQUNoQixJQUFJUSxrQkFBa0IsQ0FBQ0wsS0FBS0MsS0FBS0o7SUFDL0JFLGtCQUFrQkMsS0FBSyxPQUFPQyxRQUFRLFdBQVdBLE1BQU0sS0FBS0EsS0FBS0o7SUFDakUsT0FBT0E7QUFDVDtBQUNBLE1BQU1TLE1BQU07SUFBQztJQUFTO0lBQVE7SUFBUztJQUFtQjtJQUFvQjtJQUEyQjtJQUFhO0lBQWU7SUFBYztJQUFPO0lBQWlCO0lBQWtCO0lBQW1CO0lBQW9CO0lBQXVCO0lBQThCO0lBQXNCO0lBQXVCO0lBQW1CO0lBQXFCO0lBQW9CO0lBQW9CO0lBQXNCO0NBQW9CO0FBQ2hjLE1BQU1DO0lBQ0pDLFlBQVlDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxLQUFLLENBQUU7UUFDOUJOLGdCQUFnQixJQUFJLEVBQUU7UUFDdEJBLGdCQUFnQixJQUFJLEVBQUU7UUFDdEJBLGdCQUFnQixJQUFJLEVBQUU7UUFDdEJBLGdCQUFnQixJQUFJLEVBQUU7UUFDdEJBLGdCQUFnQixJQUFJLEVBQUU7UUFDdEJBLGdCQUFnQixJQUFJLEVBQUU7UUFDdEIsSUFBSSxDQUFDSSxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxDQUFDLEdBQUc7UUFDVCxJQUFJLENBQUNDLFVBQVUsR0FBRyxFQUFF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QUFNQztJQUNwQztJQUNBTyxrQkFBa0JxRCxNQUFNLEVBQUVDLE1BQU0sRUFBRTlELElBQUksRUFBRUMsS0FBSyxFQUFFO1FBQzdDLE1BQU0rRyxlQUFlbEQ7UUFDckIsTUFBTW1ELFVBQVVsRyxpQkFBaUJpRyxjQUFjaEg7UUFDL0MsTUFBTWtILFdBQVduRyxpQkFBaUJpRyxjQUFjL0csT0FBT2dIO1FBQ3ZEcEQsT0FBTzFCLElBQUksSUFBSTZFLGFBQWFyRCxLQUFLLENBQUNzRCxTQUFTQztJQUM3QztJQUNBNUcsa0JBQWtCdUQsTUFBTSxFQUFFMUksS0FBSyxFQUFFO1FBQy9CMEksT0FBTzFCLElBQUksSUFBSWhIO0lBQ2pCO0FBQ0Y7QUFDQSxTQUFTMEwsV0FBVzdHLElBQUksRUFBRS9ELEtBQUs7SUFDN0IsSUFBSUQsT0FBT2dFO0lBQ1gsSUFBSXlHLFVBQVUsSUFBSTVLLFFBQVEsSUFBSWlMLGVBQWU5SyxNQUFNQztJQUNuRCxPQUFPd0ssUUFBUW5LLE9BQU87QUFDeEI7QUFDQXBCLGtCQUFrQixHQUFHMkw7QUFDckIzTCxtQkFBbUIsR0FBR3dMLG9CQUN0QixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJ5LmluZm8vLi9ub2RlX21vZHVsZXMvbWVuZG96YS9kaXN0L2luZGV4LmNqcz9mNTE3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWVcbn0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcCQxKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IE9QUyA9IFtcIlZhbHVlXCIsIFwiQ29weVwiLCBcIkJsYW5rXCIsIFwiUmV0dXJuSW50b0FycmF5XCIsIFwiUmV0dXJuSW50b09iamVjdFwiLCBcIlJldHVybkludG9PYmplY3RTYW1lS2V5XCIsIFwiUHVzaEZpZWxkXCIsIFwiUHVzaEVsZW1lbnRcIiwgXCJQdXNoUGFyZW50XCIsIFwiUG9wXCIsIFwiUHVzaEZpZWxkQ29weVwiLCBcIlB1c2hGaWVsZEJsYW5rXCIsIFwiUHVzaEVsZW1lbnRDb3B5XCIsIFwiUHVzaEVsZW1lbnRCbGFua1wiLCBcIlJldHVybkludG9PYmplY3RQb3BcIiwgXCJSZXR1cm5JbnRvT2JqZWN0U2FtZUtleVBvcFwiLCBcIlJldHVybkludG9BcnJheVBvcFwiLCBcIk9iamVjdFNldEZpZWxkVmFsdWVcIiwgXCJPYmplY3RDb3B5RmllbGRcIiwgXCJPYmplY3REZWxldGVGaWVsZFwiLCBcIkFycmF5QXBwZW5kVmFsdWVcIiwgXCJBcnJheUFwcGVuZFNsaWNlXCIsIFwiU3RyaW5nQXBwZW5kU3RyaW5nXCIsIFwiU3RyaW5nQXBwZW5kU2xpY2VcIl07XG5jbGFzcyBQYXRjaGVyIHtcbiAgY29uc3RydWN0b3IobW9kZWwsIHJvb3QsIHBhdGNoKSB7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibW9kZWxcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwicm9vdFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJwYXRjaFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJpXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImlucHV0U3RhY2tcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwib3V0cHV0U3RhY2tcIik7XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgdGhpcy5wYXRjaCA9IHBhdGNoO1xuICAgIHRoaXMuaSA9IDA7XG4gICAgdGhpcy5pbnB1dFN0YWNrID0gW107XG4gICAgdGhpcy5vdXRwdXRTdGFjayA9IFtdO1xuICB9XG4gIHJlYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0Y2hbdGhpcy5pKytdO1xuICB9XG4gIHByb2Nlc3MoKSB7XG4gICAgdGhpcy5pbnB1dFN0YWNrLnB1c2goe1xuICAgICAgdmFsdWU6IHRoaXMucm9vdFxuICAgIH0pO1xuICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7XG4gICAgICB2YWx1ZTogdGhpcy5yb290XG4gICAgfSk7XG4gICAgZm9yICg7IHRoaXMuaSA8IHRoaXMucGF0Y2gubGVuZ3RoOykge1xuICAgICAgbGV0IG9wY29kZSA9IHRoaXMucmVhZCgpO1xuICAgICAgbGV0IG9wID0gT1BTW29wY29kZV07XG4gICAgICBpZiAoIW9wKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wY29kZTogXCIuY29uY2F0KG9wY29kZSkpO1xuICAgICAgbGV0IHByb2Nlc3NvciA9IFwicHJvY2Vzc1wiLmNvbmNhdChvcCk7XG4gICAgICB0aGlzW3Byb2Nlc3Nvcl0uYXBwbHkodGhpcyk7XG4gICAgfVxuICAgIGxldCBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpO1xuICB9XG4gIGlucHV0RW50cnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRTdGFja1t0aGlzLmlucHV0U3RhY2subGVuZ3RoIC0gMV07XG4gIH1cbiAgaW5wdXRLZXkoZW50cnksIGlkeCkge1xuICAgIGlmICghZW50cnkua2V5cykge1xuICAgICAgZW50cnkua2V5cyA9IHRoaXMubW9kZWwub2JqZWN0R2V0S2V5cyhlbnRyeS52YWx1ZSkuc29ydCgpO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnkua2V5c1tpZHhdO1xuICB9XG4gIG91dHB1dEVudHJ5KCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dFN0YWNrW3RoaXMub3V0cHV0U3RhY2subGVuZ3RoIC0gMV07XG4gIH1cbiAgb3V0cHV0QXJyYXkoKSB7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5vdXRwdXRFbnRyeSgpO1xuICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weUFycmF5KGVudHJ5LnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5LndyaXRlVmFsdWU7XG4gIH1cbiAgb3V0cHV0T2JqZWN0KCkge1xuICAgIGxldCBlbnRyeSA9IHRoaXMub3V0cHV0RW50cnkoKTtcbiAgICBpZiAoIWVudHJ5LndyaXRlVmFsdWUpIHtcbiAgICAgIGVudHJ5LndyaXRlVmFsdWUgPSB0aGlzLm1vZGVsLmNvcHlPYmplY3QoZW50cnkudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnkud3JpdGVWYWx1ZTtcbiAgfVxuICBvdXRwdXRTdHJpbmcoKSB7XG4gICAgbGV0IGVudHJ5ID0gdGhpcy5vdXRwdXRFbnRyeSgpO1xuICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xuICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weVN0cmluZyhlbnRyeS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS53cml0ZVZhbHVlO1xuICB9XG4gIGZpbmFsaXplT3V0cHV0KGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5LndyaXRlVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVsLmZpbmFsaXplKGVudHJ5LndyaXRlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgfVxuICB9XG4gIC8vIFByb2Nlc3NvcnM6XG4gIHByb2Nlc3NWYWx1ZSgpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpO1xuICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7XG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9XG4gIHByb2Nlc3NDb3B5KCkge1xuICAgIGxldCBpbnB1dCA9IHRoaXMuaW5wdXRFbnRyeSgpO1xuICAgIHRoaXMub3V0cHV0U3RhY2sucHVzaCh7XG4gICAgICB2YWx1ZTogaW5wdXQudmFsdWVcbiAgICB9KTtcbiAgfVxuICBwcm9jZXNzQmxhbmsoKSB7XG4gICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSk7XG4gIH1cbiAgcHJvY2Vzc1JldHVybkludG9BcnJheSgpIHtcbiAgICBsZXQgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcbiAgICBsZXQgYXJyID0gdGhpcy5vdXRwdXRBcnJheSgpO1xuICAgIHRoaXMubW9kZWwuYXJyYXlBcHBlbmRWYWx1ZShhcnIsIHJlc3VsdCk7XG4gIH1cbiAgcHJvY2Vzc1JldHVybkludG9PYmplY3QoKSB7XG4gICAgbGV0IGtleSA9IHRoaXMucmVhZCgpO1xuICAgIGxldCBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpO1xuICAgIHJlc3VsdCA9IHRoaXMubW9kZWwubWFya0NoYW5nZWQocmVzdWx0KTtcbiAgICBsZXQgb2JqID0gdGhpcy5vdXRwdXRPYmplY3QoKTtcbiAgICB0aGlzLm1vZGVsLm9iamVjdFNldEZpZWxkKG9iaiwga2V5LCByZXN1bHQpO1xuICB9XG4gIHByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleSgpIHtcbiAgICBsZXQgaW5wdXQgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICBsZXQgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcbiAgICBsZXQgb2JqID0gdGhpcy5vdXRwdXRPYmplY3QoKTtcbiAgICB0aGlzLm1vZGVsLm9iamVjdFNldEZpZWxkKG9iaiwgaW5wdXQua2V5LCByZXN1bHQpO1xuICB9XG4gIHByb2Nlc3NQdXNoRmllbGQoKSB7XG4gICAgbGV0IGlkeCA9IHRoaXMucmVhZCgpO1xuICAgIGxldCBlbnRyeSA9IHRoaXMuaW5wdXRFbnRyeSgpO1xuICAgIGxldCBrZXkgPSB0aGlzLmlucHV0S2V5KGVudHJ5LCBpZHgpO1xuICAgIGxldCB2YWx1ZSA9IHRoaXMubW9kZWwub2JqZWN0R2V0RmllbGQoZW50cnkudmFsdWUsIGtleSk7XG4gICAgdGhpcy5pbnB1dFN0YWNrLnB1c2goe1xuICAgICAgdmFsdWUsXG4gICAgICBrZXlcbiAgICB9KTtcbiAgfVxuICBwcm9jZXNzUHVzaEVsZW1lbnQoKSB7XG4gICAgbGV0IGlkeCA9IHRoaXMucmVhZCgpO1xuICAgIGxldCBlbnRyeSA9IHRoaXMuaW5wdXRFbnRyeSgpO1xuICAgIGxldCB2YWx1ZSA9IHRoaXMubW9kZWwuYXJyYXlHZXRFbGVtZW50KGVudHJ5LnZhbHVlLCBpZHgpO1xuICAgIHRoaXMuaW5wdXRTdGFjay5wdXNoKHtcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH1cbiAgcHJvY2Vzc1BvcCgpIHtcbiAgICB0aGlzLmlucHV0U3RhY2sucG9wKCk7XG4gIH1cbiAgcHJvY2Vzc1B1c2hGaWVsZENvcHkoKSB7XG4gICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCk7XG4gICAgdGhpcy5wcm9jZXNzQ29weSgpO1xuICB9XG4gIHByb2Nlc3NQdXNoRmllbGRCbGFuaygpIHtcbiAgICB0aGlzLnByb2Nlc3NQdXNoRmllbGQoKTtcbiAgICB0aGlzLnByb2Nlc3NCbGFuaygpO1xuICB9XG4gIHByb2Nlc3NQdXNoRWxlbWVudENvcHkoKSB7XG4gICAgdGhpcy5wcm9jZXNzUHVzaEVsZW1lbnQoKTtcbiAgICB0aGlzLnByb2Nlc3NDb3B5KCk7XG4gIH1cbiAgcHJvY2Vzc1B1c2hFbGVtZW50QmxhbmsoKSB7XG4gICAgdGhpcy5wcm9jZXNzUHVzaEVsZW1lbnQoKTtcbiAgICB0aGlzLnByb2Nlc3NCbGFuaygpO1xuICB9XG4gIHByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0UG9wKCkge1xuICAgIHRoaXMucHJvY2Vzc1JldHVybkludG9PYmplY3QoKTtcbiAgICB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgfVxuICBwcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXlQb3AoKSB7XG4gICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKTtcbiAgICB0aGlzLnByb2Nlc3NQb3AoKTtcbiAgfVxuICBwcm9jZXNzUmV0dXJuSW50b0FycmF5UG9wKCkge1xuICAgIHRoaXMucHJvY2Vzc1JldHVybkludG9BcnJheSgpO1xuICAgIHRoaXMucHJvY2Vzc1BvcCgpO1xuICB9XG4gIHByb2Nlc3NPYmplY3RTZXRGaWVsZFZhbHVlKCkge1xuICAgIHRoaXMucHJvY2Vzc1ZhbHVlKCk7XG4gICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdCgpO1xuICB9XG4gIHByb2Nlc3NPYmplY3RDb3B5RmllbGQoKSB7XG4gICAgdGhpcy5wcm9jZXNzUHVzaEZpZWxkKCk7XG4gICAgdGhpcy5wcm9jZXNzQ29weSgpO1xuICAgIHRoaXMucHJvY2Vzc1JldHVybkludG9PYmplY3RTYW1lS2V5KCk7XG4gICAgdGhpcy5wcm9jZXNzUG9wKCk7XG4gIH1cbiAgcHJvY2Vzc09iamVjdERlbGV0ZUZpZWxkKCkge1xuICAgIGxldCBpZHggPSB0aGlzLnJlYWQoKTtcbiAgICBsZXQgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKTtcbiAgICBsZXQga2V5ID0gdGhpcy5pbnB1dEtleShlbnRyeSwgaWR4KTtcbiAgICBsZXQgb2JqID0gdGhpcy5vdXRwdXRPYmplY3QoKTtcbiAgICB0aGlzLm1vZGVsLm9iamVjdERlbGV0ZUZpZWxkKG9iaiwga2V5KTtcbiAgfVxuICBwcm9jZXNzQXJyYXlBcHBlbmRWYWx1ZSgpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpO1xuICAgIGxldCBhcnIgPSB0aGlzLm91dHB1dEFycmF5KCk7XG4gICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFZhbHVlKGFyciwgdmFsdWUpO1xuICB9XG4gIHByb2Nlc3NBcnJheUFwcGVuZFNsaWNlKCkge1xuICAgIGxldCBsZWZ0ID0gdGhpcy5yZWFkKCk7XG4gICAgbGV0IHJpZ2h0ID0gdGhpcy5yZWFkKCk7XG4gICAgbGV0IHN0ciA9IHRoaXMub3V0cHV0QXJyYXkoKTtcbiAgICBsZXQgdmFsID0gdGhpcy5pbnB1dEVudHJ5KCkudmFsdWU7XG4gICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFNsaWNlKHN0ciwgdmFsLCBsZWZ0LCByaWdodCk7XG4gIH1cbiAgcHJvY2Vzc1N0cmluZ0FwcGVuZFN0cmluZygpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLm1vZGVsLndyYXAodGhpcy5yZWFkKCkpO1xuICAgIGxldCBzdHIgPSB0aGlzLm91dHB1dFN0cmluZygpO1xuICAgIHRoaXMubW9kZWwuc3RyaW5nQXBwZW5kVmFsdWUoc3RyLCB2YWx1ZSk7XG4gIH1cbiAgcHJvY2Vzc1N0cmluZ0FwcGVuZFNsaWNlKCkge1xuICAgIGxldCBsZWZ0ID0gdGhpcy5yZWFkKCk7XG4gICAgbGV0IHJpZ2h0ID0gdGhpcy5yZWFkKCk7XG4gICAgbGV0IHN0ciA9IHRoaXMub3V0cHV0U3RyaW5nKCk7XG4gICAgbGV0IHZhbCA9IHRoaXMuaW5wdXRFbnRyeSgpLnZhbHVlO1xuICAgIHRoaXMubW9kZWwuc3RyaW5nQXBwZW5kU2xpY2Uoc3RyLCB2YWwsIGxlZnQsIHJpZ2h0KTtcbiAgfVxufVxuZnVuY3Rpb24gdXRmOGNoYXJTaXplKGNvZGUpIHtcbiAgaWYgKGNvZGUgPj4gMTYpIHtcbiAgICByZXR1cm4gNDtcbiAgfSBlbHNlIGlmIChjb2RlID4+IDExKSB7XG4gICAgcmV0dXJuIDM7XG4gIH0gZWxzZSBpZiAoY29kZSA+PiA3KSB7XG4gICAgcmV0dXJuIDI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn1cbmZ1bmN0aW9uIHV0ZjhzdHJpbmdTaXplKHN0cikge1xuICBsZXQgYiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNvZGUgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgbGV0IHNpemUgPSB1dGY4Y2hhclNpemUoY29kZSk7XG4gICAgaWYgKHNpemUgPT0gNCkgaSsrO1xuICAgIGIgKz0gc2l6ZTtcbiAgfVxuICByZXR1cm4gYjtcbn1cbmZ1bmN0aW9uIHV0ZjhyZXNvbHZlSW5kZXgoc3RyLCBpZHgpIHtcbiAgbGV0IHN0YXJ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICBsZXQgYnl0ZUNvdW50ID0gc3RhcnQ7XG4gIGxldCB1Y3NJZHggPSAwO1xuICBmb3IgKHVjc0lkeCA9IHN0YXJ0OyBieXRlQ291bnQgPCBpZHg7IHVjc0lkeCsrKSB7XG4gICAgbGV0IGNvZGUgPSBzdHIuY29kZVBvaW50QXQodWNzSWR4KTtcbiAgICBsZXQgc2l6ZSA9IHV0ZjhjaGFyU2l6ZShjb2RlKTtcbiAgICBpZiAoc2l6ZSA9PT0gNCkgdWNzSWR4Kys7XG4gICAgYnl0ZUNvdW50ICs9IHNpemU7XG4gIH1cbiAgcmV0dXJuIHVjc0lkeDtcbn1cbmZ1bmN0aW9uIGNvbW1vblByZWZpeChzdHIsIHN0cjIpIHtcbiAgbGV0IGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIHN0cjIubGVuZ3RoKTtcbiAgbGV0IGIgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBsZXQgYVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KGkpO1xuICAgIGxldCBiUG9pbnQgPSBzdHIyLmNvZGVQb2ludEF0KGkpO1xuICAgIGlmIChhUG9pbnQgIT09IGJQb2ludCkgcmV0dXJuIGI7XG4gICAgbGV0IHNpemUgPSB1dGY4Y2hhclNpemUoYVBvaW50KTtcbiAgICBiICs9IHNpemU7XG4gICAgaSArPSBzaXplID09PSA0ID8gMiA6IDE7XG4gIH1cbiAgcmV0dXJuIGI7XG59XG5mdW5jdGlvbiBjb21tb25TdWZmaXgoc3RyLCBzdHIyKSB7XG4gIGxldCBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gIGxldCBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBzdHIyLmxlbmd0aCkgLSBwcmVmaXg7XG4gIGxldCBiID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgbGV0IGFQb2ludCA9IHN0ci5jb2RlUG9pbnRBdChzdHIubGVuZ3RoIC0gMSAtIGkpO1xuICAgIGxldCBiUG9pbnQgPSBzdHIyLmNvZGVQb2ludEF0KHN0cjIubGVuZ3RoIC0gMSAtIGkpO1xuICAgIGlmIChhUG9pbnQgIT09IGJQb2ludCkgcmV0dXJuIGI7XG4gICAgbGV0IHNpemUgPSB1dGY4Y2hhclNpemUoYVBvaW50KTtcbiAgICBiICs9IHNpemU7XG4gICAgaSArPSBzaXplID09PSA0ID8gMiA6IDE7XG4gIH1cbiAgcmV0dXJuIGI7XG59XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWVcbn0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgSW5jcmVtZW50YWxNb2RlbCB7XG4gIGNvbnN0cnVjdG9yKG1ldGEpIHtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWV0YVwiKTtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG4gIHdyYXAoZGF0YSkge1xuICAgIHJldHVybiB0aGlzLndyYXBXaXRoTWV0YShkYXRhLCB0aGlzLm1ldGEsIHRoaXMubWV0YSk7XG4gIH1cbiAgd3JhcFdpdGhNZXRhKGRhdGEsIHN0YXJ0TWV0YSkge1xuICAgIGxldCBlbmRNZXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLm1ldGE7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGEsXG4gICAgICBzdGFydE1ldGEsXG4gICAgICBlbmRNZXRhXG4gICAgfTtcbiAgfVxuICBhc09iamVjdCh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUuY29udGVudCkge1xuICAgICAgbGV0IGZpZWxkcyA9IHt9O1xuICAgICAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZS5kYXRhKSkge1xuICAgICAgICBmaWVsZHNba2V5XSA9IHRoaXMud3JhcFdpdGhNZXRhKHZhbCwgdmFsdWUuc3RhcnRNZXRhKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlLmNvbnRlbnQgPSB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIGZpZWxkc1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQ7XG4gIH1cbiAgYXNBcnJheSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUuY29udGVudCkge1xuICAgICAgbGV0IGVsZW1lbnRzID0gdmFsdWUuZGF0YS5tYXAoaXRlbSA9PiB0aGlzLndyYXBXaXRoTWV0YShpdGVtLCB2YWx1ZS5zdGFydE1ldGEpKTtcbiAgICAgIGxldCBtZXRhcyA9IGVsZW1lbnRzLm1hcCgoKSA9PiB0aGlzLm1ldGEpO1xuICAgICAgdmFsdWUuY29udGVudCA9IHtcbiAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgbWV0YXNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5jb250ZW50O1xuICB9XG4gIGFzU3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XG4gICAgICBsZXQgc3RyID0gdmFsdWUuZGF0YTtcbiAgICAgIGxldCBwYXJ0ID0ge1xuICAgICAgICB2YWx1ZTogc3RyLFxuICAgICAgICB1dGY4c2l6ZTogdXRmOHN0cmluZ1NpemUoc3RyKSxcbiAgICAgICAgdXNlczogW10sXG4gICAgICAgIHN0YXJ0TWV0YTogdmFsdWUuc3RhcnRNZXRhLFxuICAgICAgICBlbmRNZXRhOiB2YWx1ZS5lbmRNZXRhXG4gICAgICB9O1xuICAgICAgdmFsdWUuY29udGVudCA9IHRoaXMuc3RyaW5nRnJvbVBhcnRzKFtwYXJ0XSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5jb250ZW50O1xuICB9XG4gIHN0cmluZ0Zyb21QYXJ0cyhwYXJ0cykge1xuICAgIGxldCBzdHIgPSB7XG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgcGFydHNcbiAgICB9O1xuICAgIGZvciAobGV0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgIHBhcnQudXNlcy5wdXNoKHN0cik7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgb2JqZWN0R2V0S2V5cyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5jb250ZW50KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUuY29udGVudC5maWVsZHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUuZGF0YSk7XG4gICAgfVxuICB9XG4gIG9iamVjdEdldEZpZWxkKHZhbHVlLCBrZXkpIHtcbiAgICBsZXQgb2JqID0gdGhpcy5hc09iamVjdCh2YWx1ZSk7XG4gICAgcmV0dXJuIG9iai5maWVsZHNba2V5XTtcbiAgfVxuICBhcnJheUdldEVsZW1lbnQodmFsdWUsIGlkeCkge1xuICAgIGxldCBhcnIgPSB0aGlzLmFzQXJyYXkodmFsdWUpO1xuICAgIHJldHVybiBhcnIuZWxlbWVudHNbaWR4XTtcbiAgfVxuICBmaW5hbGl6ZShjb250ZW50KSB7XG4gICAgdGhpcy51cGRhdGVFbmRNZXRhKGNvbnRlbnQpO1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZW50LFxuICAgICAgc3RhcnRNZXRhOiB0aGlzLm1ldGEsXG4gICAgICBlbmRNZXRhOiB0aGlzLm1ldGFcbiAgICB9O1xuICB9XG4gIG1hcmtDaGFuZ2VkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMud3JhcCh1bndyYXAodmFsdWUpKTtcbiAgfVxuICB1cGRhdGVFbmRNZXRhKGNvbnRlbnQpIHtcbiAgICBpZiAoY29udGVudC50eXBlID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGZvciAobGV0IHBhcnQgb2YgY29udGVudC5wYXJ0cykge1xuICAgICAgICBwYXJ0LmVuZE1ldGEgPSB0aGlzLm1ldGE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb250ZW50LnR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICBmb3IgKGxldCB2YWwgb2YgY29udGVudC5lbGVtZW50cykge1xuICAgICAgICAgIGlmICh2YWwuY29udGVudCAmJiB2YWwuZW5kTWV0YSAhPT0gdGhpcy5tZXRhKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVuZE1ldGEodmFsLmNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWwuZW5kTWV0YSA9IHRoaXMubWV0YTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgdmFsIG9mIE9iamVjdC52YWx1ZXMoY29udGVudC5maWVsZHMpKSB7XG4gICAgICAgICAgaWYgKHZhbC5jb250ZW50ICYmIHZhbC5lbmRNZXRhICE9PSB0aGlzLm1ldGEpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRW5kTWV0YSh2YWwuY29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbC5lbmRNZXRhID0gdGhpcy5tZXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvcHlTdHJpbmcodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGxldCBvdGhlciA9IHRoaXMuYXNTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nRnJvbVBhcnRzKG90aGVyLnBhcnRzLnNsaWNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBwYXJ0czogW11cbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGNvcHlPYmplY3QodmFsdWUpIHtcbiAgICBsZXQgb2JqID0ge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIGZpZWxkczoge31cbiAgICB9O1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgbGV0IG90aGVyID0gdGhpcy5hc09iamVjdCh2YWx1ZSk7XG4gICAgICBPYmplY3QuYXNzaWduKG9iai5maWVsZHMsIG90aGVyLmZpZWxkcyk7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgY29weUFycmF5KHZhbHVlKSB7XG4gICAgbGV0IGFyciA9IHZhbHVlID8gdGhpcy5hc0FycmF5KHZhbHVlKSA6IG51bGw7XG4gICAgbGV0IGVsZW1lbnRzID0gYXJyID8gYXJyLmVsZW1lbnRzIDogW107XG4gICAgbGV0IG1ldGFzID0gYXJyID8gYXJyLm1ldGFzIDogW107XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgbWV0YXNcbiAgICB9O1xuICB9XG4gIG9iamVjdFNldEZpZWxkKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgIHRhcmdldC5maWVsZHNba2V5XSA9IHZhbHVlO1xuICB9XG4gIG9iamVjdERlbGV0ZUZpZWxkKHRhcmdldCwga2V5KSB7XG4gICAgZGVsZXRlIHRhcmdldC5maWVsZHNba2V5XTtcbiAgfVxuICBhcnJheUFwcGVuZFZhbHVlKHRhcmdldCwgdmFsdWUpIHtcbiAgICB0YXJnZXQuZWxlbWVudHMucHVzaCh2YWx1ZSk7XG4gICAgdGFyZ2V0Lm1ldGFzLnB1c2godGhpcy5tZXRhKTtcbiAgfVxuICBhcnJheUFwcGVuZFNsaWNlKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xuICAgIGxldCBhcnIgPSB0aGlzLmFzQXJyYXkoc291cmNlKTtcbiAgICBsZXQgc2FtZVBvc2l0aW9uID0gYXJyLmVsZW1lbnRzLmxlbmd0aCA9PT0gbGVmdDtcbiAgICB0YXJnZXQuZWxlbWVudHMucHVzaCguLi5hcnIuZWxlbWVudHMuc2xpY2UobGVmdCwgcmlnaHQpKTtcbiAgICBpZiAoc2FtZVBvc2l0aW9uKSB7XG4gICAgICB0YXJnZXQubWV0YXMucHVzaCguLi5hcnIubWV0YXMuc2xpY2UobGVmdCwgcmlnaHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IGxlZnQ7IGkgPCByaWdodDsgaSsrKSB7XG4gICAgICAgIHRhcmdldC5tZXRhcy5wdXNoKHRoaXMubWV0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0cmluZ0FwcGVuZFZhbHVlKHRhcmdldCwgdmFsdWUpIHtcbiAgICBsZXQgc3RyID0gdGhpcy5hc1N0cmluZyh2YWx1ZSk7XG4gICAgZm9yIChsZXQgcGFydCBvZiBzdHIucGFydHMpIHtcbiAgICAgIHRoaXMuc3RyaW5nQXBwZW5kUGFydCh0YXJnZXQsIHBhcnQpO1xuICAgIH1cbiAgfVxuICBzdHJpbmdBcHBlbmRQYXJ0KHRhcmdldCwgcGFydCkge1xuICAgIHRhcmdldC5wYXJ0cy5wdXNoKHBhcnQpO1xuICAgIHBhcnQudXNlcy5wdXNoKHRhcmdldCk7XG4gIH1cbiAgcmVzb2x2ZVN0cmluZ1BhcnQoc3RyLCBmcm9tLCBsZW4pIHtcbiAgICBpZiAobGVuID09PSAwKSByZXR1cm4gZnJvbTtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHN0ci5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBhcnQgPSBzdHIucGFydHNbaV07XG4gICAgICBpZiAobGVuID09PSBwYXJ0LnV0ZjhzaXplKSB7XG4gICAgICAgIHJldHVybiBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChsZW4gPCBwYXJ0LnV0ZjhzaXplKSB7XG4gICAgICAgIHRoaXMuc3BsaXRTdHJpbmcocGFydCwgbGVuKTtcbiAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgfVxuICAgICAgbGVuIC09IHBhcnQudXRmOHNpemU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcInNwbGl0dGluZyBzdHJpbmcgb3V0IG9mIGJvdW5kc1wiKTtcbiAgfVxuICBzcGxpdFN0cmluZyhwYXJ0LCBpZHgpIHtcbiAgICBsZXQgbGVmdFZhbHVlO1xuICAgIGxldCByaWdodFZhbHVlO1xuICAgIGxldCBsZWZ0U2l6ZSA9IGlkeDtcbiAgICBsZXQgcmlnaHRTaXplID0gcGFydC51dGY4c2l6ZSAtIGxlZnRTaXplO1xuICAgIGlmIChwYXJ0LnV0ZjhzaXplICE9PSBwYXJ0LnZhbHVlLmxlbmd0aCkge1xuICAgICAgbGV0IGJ5dGVDb3VudCA9IDA7XG4gICAgICBmb3IgKGlkeCA9IDA7IGJ5dGVDb3VudCA8IGxlZnRTaXplOyBpZHgrKykge1xuICAgICAgICBsZXQgY29kZSA9IHBhcnQudmFsdWUuY29kZVBvaW50QXQoaWR4KTtcbiAgICAgICAgbGV0IHNpemUgPSB1dGY4Y2hhclNpemUoY29kZSk7XG4gICAgICAgIGlmIChzaXplID09PSA0KSBpZHgrKztcbiAgICAgICAgYnl0ZUNvdW50ICs9IHNpemU7XG4gICAgICB9XG4gICAgfVxuICAgIGxlZnRWYWx1ZSA9IHBhcnQudmFsdWUuc2xpY2UoMCwgaWR4KTtcbiAgICByaWdodFZhbHVlID0gcGFydC52YWx1ZS5zbGljZShpZHgpO1xuICAgIGxldCBuZXdQYXJ0ID0ge1xuICAgICAgdmFsdWU6IHJpZ2h0VmFsdWUsXG4gICAgICB1dGY4c2l6ZTogcmlnaHRTaXplLFxuICAgICAgdXNlczogcGFydC51c2VzLnNsaWNlKCksXG4gICAgICBzdGFydE1ldGE6IHBhcnQuc3RhcnRNZXRhLFxuICAgICAgZW5kTWV0YTogcGFydC5lbmRNZXRhXG4gICAgfTtcbiAgICBwYXJ0LnZhbHVlID0gbGVmdFZhbHVlO1xuICAgIHBhcnQudXRmOHNpemUgPSBsZWZ0U2l6ZTtcbiAgICBmb3IgKGxldCB1c2Ugb2YgcGFydC51c2VzKSB7XG4gICAgICBsZXQgbmR4ID0gdXNlLnBhcnRzLmluZGV4T2YocGFydCk7XG4gICAgICBpZiAobmR4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKFwiYnVnOiBtaXNtYXRjaCBiZXR3ZWVuIHN0cmluZyBwYXJ0cyBhbmQgdXNlLlwiKTtcbiAgICAgIHVzZS5wYXJ0cy5zcGxpY2UobmR4ICsgMSwgMCwgbmV3UGFydCk7XG4gICAgfVxuICB9XG4gIHN0cmluZ0FwcGVuZFNsaWNlKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xuICAgIGxldCBzdHIgPSB0aGlzLmFzU3RyaW5nKHNvdXJjZSk7XG4gICAgbGV0IGZpcnN0UGFydCA9IHRoaXMucmVzb2x2ZVN0cmluZ1BhcnQoc3RyLCAwLCBsZWZ0KTtcbiAgICBsZXQgbGFzdFBhcnQgPSB0aGlzLnJlc29sdmVTdHJpbmdQYXJ0KHN0ciwgZmlyc3RQYXJ0LCByaWdodCAtIGxlZnQpO1xuICAgIGZvciAobGV0IGkgPSBmaXJzdFBhcnQ7IGkgPCBsYXN0UGFydDsgaSsrKSB7XG4gICAgICBsZXQgcGFydCA9IHN0ci5wYXJ0c1tpXTtcbiAgICAgIHRoaXMuc3RyaW5nQXBwZW5kUGFydCh0YXJnZXQsIHBhcnQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gd3JhcChkYXRhLCBtZXRhKSB7XG4gIHJldHVybiB7XG4gICAgZGF0YSxcbiAgICBzdGFydE1ldGE6IG1ldGEsXG4gICAgZW5kTWV0YTogbWV0YVxuICB9O1xufVxuZnVuY3Rpb24gdW53cmFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUuZGF0YSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHZhbHVlLmRhdGE7XG4gIGxldCByZXN1bHQ7XG4gIGxldCBjb250ZW50ID0gdmFsdWUuY29udGVudDtcbiAgc3dpdGNoIChjb250ZW50LnR5cGUpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXN1bHQgPSBjb250ZW50LnBhcnRzLm1hcChwYXJ0ID0+IHBhcnQudmFsdWUpLmpvaW4oXCJcIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIHJlc3VsdCA9IGNvbnRlbnQuZWxlbWVudHMubWFwKHZhbCA9PiB1bndyYXAodmFsKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICB7XG4gICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKGNvbnRlbnQuZmllbGRzKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdW53cmFwKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuICB2YWx1ZS5kYXRhID0gcmVzdWx0O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0VHlwZSh2YWx1ZSkge1xuICBpZiAodmFsdWUuY29udGVudCkgcmV0dXJuIHZhbHVlLmNvbnRlbnQudHlwZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUuZGF0YSkpIHJldHVybiBcImFycmF5XCI7XG4gIGlmICh2YWx1ZS5kYXRhID09PSBudWxsKSByZXR1cm4gXCJudWxsXCI7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUuZGF0YTtcbn1cbmZ1bmN0aW9uIHJlYmFzZVZhbHVlKGxlZnQsIHJpZ2h0KSB7XG4gIGxldCBsZWZ0VHlwZSA9IGdldFR5cGUobGVmdCk7XG4gIGxldCByaWdodFR5cGUgPSBnZXRUeXBlKHJpZ2h0KTtcbiAgaWYgKGxlZnRUeXBlICE9PSByaWdodFR5cGUpIHJldHVybiByaWdodDtcbiAgbGV0IGxlZnRNb2RlbCA9IG5ldyBJbmNyZW1lbnRhbE1vZGVsKGxlZnQuZW5kTWV0YSk7XG4gIGxldCByaWdodE1vZGVsID0gbmV3IEluY3JlbWVudGFsTW9kZWwocmlnaHQuZW5kTWV0YSk7XG4gIHN3aXRjaCAobGVmdFR5cGUpIHtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICB7XG4gICAgICAgIGxldCBsZWZ0T2JqID0gbGVmdE1vZGVsLmFzT2JqZWN0KGxlZnQpO1xuICAgICAgICBsZXQgcmlnaHRPYmogPSByaWdodE1vZGVsLmFzT2JqZWN0KHJpZ2h0KTtcbiAgICAgICAgbGV0IGlkZW50aWNhbEZpZWxkQ291bnQgPSAwO1xuICAgICAgICBsZXQgbGVmdEZpZWxkQ291bnQgPSBPYmplY3Qua2V5cyhsZWZ0T2JqLmZpZWxkcykubGVuZ3RoO1xuICAgICAgICBsZXQgcmlnaHRGaWVsZENvdW50ID0gT2JqZWN0LmtleXMocmlnaHRPYmouZmllbGRzKS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHJpZ2h0VmFsXSBvZiBPYmplY3QuZW50cmllcyhyaWdodE9iai5maWVsZHMpKSB7XG4gICAgICAgICAgbGV0IGxlZnRWYWwgPSBsZWZ0T2JqLmZpZWxkc1trZXldO1xuICAgICAgICAgIGlmIChsZWZ0VmFsKSB7XG4gICAgICAgICAgICByaWdodE9iai5maWVsZHNba2V5XSA9IHJlYmFzZVZhbHVlKGxlZnRWYWwsIHJpZ2h0VmFsKTtcbiAgICAgICAgICAgIGlmIChyaWdodE9iai5maWVsZHNba2V5XSA9PT0gbGVmdFZhbCkge1xuICAgICAgICAgICAgICBpZGVudGljYWxGaWVsZENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpc0lkZW50aWNhbCA9IGxlZnRGaWVsZENvdW50ID09PSByaWdodEZpZWxkQ291bnQgJiYgbGVmdEZpZWxkQ291bnQgPT09IGlkZW50aWNhbEZpZWxkQ291bnQ7XG4gICAgICAgIHJldHVybiBpc0lkZW50aWNhbCA/IGxlZnQgOiByaWdodDtcbiAgICAgIH1cbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIHtcbiAgICAgICAgbGV0IGxlZnRBcnIgPSBsZWZ0TW9kZWwuYXNBcnJheShsZWZ0KTtcbiAgICAgICAgbGV0IHJpZ2h0QXJyID0gcmlnaHRNb2RlbC5hc0FycmF5KHJpZ2h0KTtcbiAgICAgICAgaWYgKGxlZnRBcnIuZWxlbWVudHMubGVuZ3RoICE9PSByaWdodEFyci5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtUmViYXNlZCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmlnaHRBcnIuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByaWdodEFyci5lbGVtZW50c1tpXSA9IHJlYmFzZVZhbHVlKGxlZnRBcnIuZWxlbWVudHNbaV0sIHJpZ2h0QXJyLmVsZW1lbnRzW2ldKTtcbiAgICAgICAgICBpZiAocmlnaHRBcnIuZWxlbWVudHNbaV0gIT09IGxlZnRBcnIuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgICAgIG51bVJlYmFzZWQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bVJlYmFzZWQgPT09IDAgPyBsZWZ0IDogcmlnaHQ7XG4gICAgICB9XG4gICAgY2FzZSBcIm51bGxcIjpcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIHtcbiAgICAgICAgaWYgKHVud3JhcChsZWZ0KSA9PT0gdW53cmFwKHJpZ2h0KSkgcmV0dXJuIGxlZnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHtcbiAgICAgICAgbGV0IGxlZnRSYXcgPSB1bndyYXAobGVmdCk7XG4gICAgICAgIGxldCByaWdodFJhdyA9IHVud3JhcChyaWdodCk7XG4gICAgICAgIGlmIChsZWZ0UmF3ID09PSByaWdodFJhdykgcmV0dXJuIGxlZnQ7XG4gICAgICAgIGxldCByZXN1bHQgPSByaWdodE1vZGVsLmNvcHlTdHJpbmcobnVsbCk7XG4gICAgICAgIGxldCBwcmVmaXggPSBjb21tb25QcmVmaXgobGVmdFJhdywgcmlnaHRSYXcpO1xuICAgICAgICBsZXQgc3VmZml4ID0gY29tbW9uU3VmZml4KGxlZnRSYXcsIHJpZ2h0UmF3LCBwcmVmaXgpO1xuICAgICAgICBsZXQgcmlnaHRMZW4gPSB1dGY4c3RyaW5nU2l6ZShyaWdodFJhdyk7XG4gICAgICAgIGxldCBsZWZ0TGVuID0gdXRmOHN0cmluZ1NpemUobGVmdFJhdyk7XG4gICAgICAgIGlmICgwIDwgcHJlZml4KSB7XG4gICAgICAgICAgcmlnaHRNb2RlbC5zdHJpbmdBcHBlbmRTbGljZShyZXN1bHQsIGxlZnQsIDAsIHByZWZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWZpeCA8IHJpZ2h0TGVuIC0gc3VmZml4KSB7XG4gICAgICAgICAgcmlnaHRNb2RlbC5zdHJpbmdBcHBlbmRTbGljZShyZXN1bHQsIHJpZ2h0LCBwcmVmaXgsIHJpZ2h0TGVuIC0gc3VmZml4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdExlbiAtIHN1ZmZpeCA8IGxlZnRMZW4pIHtcbiAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgbGVmdCwgbGVmdExlbiAtIHN1ZmZpeCwgbGVmdExlbik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbHVlID0gcmlnaHRNb2RlbC5maW5hbGl6ZShyZXN1bHQpO1xuICAgICAgICBpZiAodW53cmFwKHZhbHVlKSAhPT0gcmlnaHRSYXcpIHRocm93IG5ldyBFcnJvcihcImluY29ycmVjdCBzdHJpbmcgcmViYXNlXCIpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHJpZ2h0O1xufVxuZnVuY3Rpb24gYXBwbHlQYXRjaCQxKGxlZnQsIHBhdGNoLCBzdGFydE1ldGEpIHtcbiAgbGV0IG1vZGVsID0gbmV3IEluY3JlbWVudGFsTW9kZWwoc3RhcnRNZXRhKTtcbiAgbGV0IHBhdGNoZXIgPSBuZXcgUGF0Y2hlcihtb2RlbCwgbGVmdCwgcGF0Y2gpO1xuICByZXR1cm4gcGF0Y2hlci5wcm9jZXNzKCk7XG59XG52YXIgaW5jcmVtZW50YWxQYXRjaGVyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGFwcGx5UGF0Y2g6IGFwcGx5UGF0Y2gkMSxcbiAgZ2V0VHlwZTogZ2V0VHlwZSxcbiAgcmViYXNlVmFsdWU6IHJlYmFzZVZhbHVlLFxuICB1bndyYXA6IHVud3JhcCxcbiAgd3JhcDogd3JhcFxufSk7XG5jbGFzcyBTaW1wbGVNb2RlbCB7XG4gIHdyYXAoZGF0YSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGZpbmFsaXplKGIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiLmRhdGE7XG4gICAgfVxuICB9XG4gIG1hcmtDaGFuZ2VkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIG9iamVjdEdldEtleXModmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpO1xuICB9XG4gIG9iamVjdEdldEZpZWxkKHZhbHVlLCBrZXkpIHtcbiAgICByZXR1cm4gdmFsdWVba2V5XTtcbiAgfVxuICBhcnJheUdldEVsZW1lbnQodmFsdWUsIGlkeCkge1xuICAgIHJldHVybiB2YWx1ZVtpZHhdO1xuICB9XG4gIGNvcHlPYmplY3QodmFsdWUpIHtcbiAgICBsZXQgcmVzID0ge1xuICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgIGRhdGE6IHt9XG4gICAgfTtcbiAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGZvciAobGV0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgIHJlcy5kYXRhW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgY29weUFycmF5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gW107XG4gICAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XG4gIH1cbiAgY29weVN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgZGF0YTogdmFsdWUgPT09IG51bGwgPyBcIlwiIDogdmFsdWVcbiAgICB9O1xuICB9XG4gIG9iamVjdFNldEZpZWxkKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgIHRhcmdldC5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgfVxuICBvYmplY3REZWxldGVGaWVsZCh0YXJnZXQsIGtleSkge1xuICAgIGRlbGV0ZSB0YXJnZXQuZGF0YVtrZXldO1xuICB9XG4gIGFycmF5QXBwZW5kVmFsdWUodGFyZ2V0LCB2YWx1ZSkge1xuICAgIHRhcmdldC5wdXNoKHZhbHVlKTtcbiAgfVxuICBhcnJheUFwcGVuZFNsaWNlKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xuICAgIHRhcmdldC5wdXNoKC4uLnNvdXJjZS5zbGljZShsZWZ0LCByaWdodCkpO1xuICB9XG4gIHN0cmluZ0FwcGVuZFNsaWNlKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xuICAgIGNvbnN0IHNvdXJjZVN0cmluZyA9IHNvdXJjZTtcbiAgICBjb25zdCBsZWZ0UG9zID0gdXRmOHJlc29sdmVJbmRleChzb3VyY2VTdHJpbmcsIGxlZnQpO1xuICAgIGNvbnN0IHJpZ2h0UG9zID0gdXRmOHJlc29sdmVJbmRleChzb3VyY2VTdHJpbmcsIHJpZ2h0LCBsZWZ0UG9zKTtcbiAgICB0YXJnZXQuZGF0YSArPSBzb3VyY2VTdHJpbmcuc2xpY2UobGVmdFBvcywgcmlnaHRQb3MpO1xuICB9XG4gIHN0cmluZ0FwcGVuZFZhbHVlKHRhcmdldCwgdmFsdWUpIHtcbiAgICB0YXJnZXQuZGF0YSArPSB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gYXBwbHlQYXRjaChsZWZ0LCBwYXRjaCkge1xuICBsZXQgcm9vdCA9IGxlZnQ7XG4gIGxldCBwYXRjaGVyID0gbmV3IFBhdGNoZXIobmV3IFNpbXBsZU1vZGVsKCksIHJvb3QsIHBhdGNoKTtcbiAgcmV0dXJuIHBhdGNoZXIucHJvY2VzcygpO1xufVxuZXhwb3J0cy5hcHBseVBhdGNoID0gYXBwbHlQYXRjaDtcbmV4cG9ydHMuaW5jcmVtZW50YWwgPSBpbmNyZW1lbnRhbFBhdGNoZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwXG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfX2RlZlByb3AkMSIsIl9fZGVmTm9ybWFsUHJvcCQxIiwib2JqIiwia2V5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX19wdWJsaWNGaWVsZCQxIiwiT1BTIiwiUGF0Y2hlciIsImNvbnN0cnVjdG9yIiwibW9kZWwiLCJyb290IiwicGF0Y2giLCJpIiwiaW5wdXRTdGFjayIsIm91dHB1dFN0YWNrIiwicmVhZCIsInByb2Nlc3MiLCJwdXNoIiwibGVuZ3RoIiwib3Bjb2RlIiwib3AiLCJFcnJvciIsImNvbmNhdCIsInByb2Nlc3NvciIsImFwcGx5IiwiZW50cnkiLCJwb3AiLCJmaW5hbGl6ZU91dHB1dCIsImlucHV0RW50cnkiLCJpbnB1dEtleSIsImlkeCIsImtleXMiLCJvYmplY3RHZXRLZXlzIiwic29ydCIsIm91dHB1dEVudHJ5Iiwib3V0cHV0QXJyYXkiLCJ3cml0ZVZhbHVlIiwiY29weUFycmF5Iiwib3V0cHV0T2JqZWN0IiwiY29weU9iamVjdCIsIm91dHB1dFN0cmluZyIsImNvcHlTdHJpbmciLCJmaW5hbGl6ZSIsInByb2Nlc3NWYWx1ZSIsIndyYXAiLCJwcm9jZXNzQ29weSIsImlucHV0IiwicHJvY2Vzc0JsYW5rIiwicHJvY2Vzc1JldHVybkludG9BcnJheSIsInJlc3VsdCIsImFyciIsImFycmF5QXBwZW5kVmFsdWUiLCJwcm9jZXNzUmV0dXJuSW50b09iamVjdCIsIm1hcmtDaGFuZ2VkIiwib2JqZWN0U2V0RmllbGQiLCJwcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkiLCJwcm9jZXNzUHVzaEZpZWxkIiwib2JqZWN0R2V0RmllbGQiLCJwcm9jZXNzUHVzaEVsZW1lbnQiLCJhcnJheUdldEVsZW1lbnQiLCJwcm9jZXNzUG9wIiwicHJvY2Vzc1B1c2hGaWVsZENvcHkiLCJwcm9jZXNzUHVzaEZpZWxkQmxhbmsiLCJwcm9jZXNzUHVzaEVsZW1lbnRDb3B5IiwicHJvY2Vzc1B1c2hFbGVtZW50QmxhbmsiLCJwcm9jZXNzUmV0dXJuSW50b09iamVjdFBvcCIsInByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleVBvcCIsInByb2Nlc3NSZXR1cm5JbnRvQXJyYXlQb3AiLCJwcm9jZXNzT2JqZWN0U2V0RmllbGRWYWx1ZSIsInByb2Nlc3NPYmplY3RDb3B5RmllbGQiLCJwcm9jZXNzT2JqZWN0RGVsZXRlRmllbGQiLCJvYmplY3REZWxldGVGaWVsZCIsInByb2Nlc3NBcnJheUFwcGVuZFZhbHVlIiwicHJvY2Vzc0FycmF5QXBwZW5kU2xpY2UiLCJsZWZ0IiwicmlnaHQiLCJzdHIiLCJ2YWwiLCJhcnJheUFwcGVuZFNsaWNlIiwicHJvY2Vzc1N0cmluZ0FwcGVuZFN0cmluZyIsInN0cmluZ0FwcGVuZFZhbHVlIiwicHJvY2Vzc1N0cmluZ0FwcGVuZFNsaWNlIiwic3RyaW5nQXBwZW5kU2xpY2UiLCJ1dGY4Y2hhclNpemUiLCJjb2RlIiwidXRmOHN0cmluZ1NpemUiLCJiIiwiY29kZVBvaW50QXQiLCJzaXplIiwidXRmOHJlc29sdmVJbmRleCIsInN0YXJ0IiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwiYnl0ZUNvdW50IiwidWNzSWR4IiwiY29tbW9uUHJlZml4Iiwic3RyMiIsImxlbiIsIk1hdGgiLCJtaW4iLCJhUG9pbnQiLCJiUG9pbnQiLCJjb21tb25TdWZmaXgiLCJwcmVmaXgiLCJfX2RlZlByb3AiLCJfX2RlZk5vcm1hbFByb3AiLCJfX3B1YmxpY0ZpZWxkIiwiSW5jcmVtZW50YWxNb2RlbCIsIm1ldGEiLCJkYXRhIiwid3JhcFdpdGhNZXRhIiwic3RhcnRNZXRhIiwiZW5kTWV0YSIsImFzT2JqZWN0IiwiY29udGVudCIsImZpZWxkcyIsImVudHJpZXMiLCJ0eXBlIiwiYXNBcnJheSIsImVsZW1lbnRzIiwibWFwIiwiaXRlbSIsIm1ldGFzIiwiYXNTdHJpbmciLCJwYXJ0IiwidXRmOHNpemUiLCJ1c2VzIiwic3RyaW5nRnJvbVBhcnRzIiwicGFydHMiLCJ1cGRhdGVFbmRNZXRhIiwidW53cmFwIiwidmFsdWVzIiwib3RoZXIiLCJzbGljZSIsImFzc2lnbiIsInRhcmdldCIsInNvdXJjZSIsInNhbWVQb3NpdGlvbiIsInN0cmluZ0FwcGVuZFBhcnQiLCJyZXNvbHZlU3RyaW5nUGFydCIsImZyb20iLCJzcGxpdFN0cmluZyIsImxlZnRWYWx1ZSIsInJpZ2h0VmFsdWUiLCJsZWZ0U2l6ZSIsInJpZ2h0U2l6ZSIsIm5ld1BhcnQiLCJ1c2UiLCJuZHgiLCJpbmRleE9mIiwic3BsaWNlIiwiZmlyc3RQYXJ0IiwibGFzdFBhcnQiLCJqb2luIiwiZ2V0VHlwZSIsIkFycmF5IiwiaXNBcnJheSIsInJlYmFzZVZhbHVlIiwibGVmdFR5cGUiLCJyaWdodFR5cGUiLCJsZWZ0TW9kZWwiLCJyaWdodE1vZGVsIiwibGVmdE9iaiIsInJpZ2h0T2JqIiwiaWRlbnRpY2FsRmllbGRDb3VudCIsImxlZnRGaWVsZENvdW50IiwicmlnaHRGaWVsZENvdW50IiwicmlnaHRWYWwiLCJsZWZ0VmFsIiwiaXNJZGVudGljYWwiLCJsZWZ0QXJyIiwicmlnaHRBcnIiLCJudW1SZWJhc2VkIiwibGVmdFJhdyIsInJpZ2h0UmF3Iiwic3VmZml4IiwicmlnaHRMZW4iLCJsZWZ0TGVuIiwiYXBwbHlQYXRjaCQxIiwicGF0Y2hlciIsImluY3JlbWVudGFsUGF0Y2hlciIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsImFwcGx5UGF0Y2giLCJTaW1wbGVNb2RlbCIsInJlcyIsInNvdXJjZVN0cmluZyIsImxlZnRQb3MiLCJyaWdodFBvcyIsImluY3JlbWVudGFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mendoza/dist/index.cjs\n");

/***/ })

};
;