"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/moment";
exports.ids = ["vendor-chunks/moment"];
exports.modules = {

/***/ "(ssr)/./node_modules/moment/moment.js":
/*!***************************************!*\
  !*** ./node_modules/moment/moment.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n//! moment.js\n//! version : 2.29.4\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n\n(function(global, factory) {\n     true ? module.exports = factory() : 0;\n})(void 0, function() {\n    \"use strict\";\n    var hookCallback;\n    function hooks() {\n        return hookCallback.apply(null, arguments);\n    }\n    // This is done to register the method called with moment()\n    // without creating circular dependencies.\n    function setHookCallback(callback) {\n        hookCallback = callback;\n    }\n    function isArray(input) {\n        return input instanceof Array || Object.prototype.toString.call(input) === \"[object Array]\";\n    }\n    function isObject(input) {\n        // IE8 will treat undefined and null as object if it wasn't for\n        // input != null\n        return input != null && Object.prototype.toString.call(input) === \"[object Object]\";\n    }\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a, b);\n    }\n    function isObjectEmpty(obj) {\n        if (Object.getOwnPropertyNames) {\n            return Object.getOwnPropertyNames(obj).length === 0;\n        } else {\n            var k;\n            for(k in obj){\n                if (hasOwnProp(obj, k)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    function isUndefined(input) {\n        return input === void 0;\n    }\n    function isNumber(input) {\n        return typeof input === \"number\" || Object.prototype.toString.call(input) === \"[object Number]\";\n    }\n    function isDate(input) {\n        return input instanceof Date || Object.prototype.toString.call(input) === \"[object Date]\";\n    }\n    function map(arr, fn) {\n        var res = [], i, arrLen = arr.length;\n        for(i = 0; i < arrLen; ++i){\n            res.push(fn(arr[i], i));\n        }\n        return res;\n    }\n    function extend(a, b) {\n        for(var i in b){\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n        if (hasOwnProp(b, \"toString\")) {\n            a.toString = b.toString;\n        }\n        if (hasOwnProp(b, \"valueOf\")) {\n            a.valueOf = b.valueOf;\n        }\n        return a;\n    }\n    function createUTC(input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\n    }\n    function defaultParsingFlags() {\n        // We need to deep clone this object.\n        return {\n            empty: false,\n            unusedTokens: [],\n            unusedInput: [],\n            overflow: -2,\n            charsLeftOver: 0,\n            nullInput: false,\n            invalidEra: null,\n            invalidMonth: null,\n            invalidFormat: false,\n            userInvalidated: false,\n            iso: false,\n            parsedDateParts: [],\n            era: null,\n            meridiem: null,\n            rfc2822: false,\n            weekdayMismatch: false\n        };\n    }\n    function getParsingFlags(m) {\n        if (m._pf == null) {\n            m._pf = defaultParsingFlags();\n        }\n        return m._pf;\n    }\n    var some;\n    if (Array.prototype.some) {\n        some = Array.prototype.some;\n    } else {\n        some = function(fun) {\n            var t = Object(this), len = t.length >>> 0, i;\n            for(i = 0; i < len; i++){\n                if (i in t && fun.call(this, t[i], i, t)) {\n                    return true;\n                }\n            }\n            return false;\n        };\n    }\n    function isValid(m) {\n        if (m._isValid == null) {\n            var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {\n                return i != null;\n            }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);\n            if (m._strict) {\n                isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;\n            }\n            if (Object.isFrozen == null || !Object.isFrozen(m)) {\n                m._isValid = isNowValid;\n            } else {\n                return isNowValid;\n            }\n        }\n        return m._isValid;\n    }\n    function createInvalid(flags) {\n        var m = createUTC(NaN);\n        if (flags != null) {\n            extend(getParsingFlags(m), flags);\n        } else {\n            getParsingFlags(m).userInvalidated = true;\n        }\n        return m;\n    }\n    // Plugins that add properties should also add the key here (null value),\n    // so we can properly clone ourselves.\n    var momentProperties = hooks.momentProperties = [], updateInProgress = false;\n    function copyConfig(to, from) {\n        var i, prop, val, momentPropertiesLen = momentProperties.length;\n        if (!isUndefined(from._isAMomentObject)) {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if (!isUndefined(from._i)) {\n            to._i = from._i;\n        }\n        if (!isUndefined(from._f)) {\n            to._f = from._f;\n        }\n        if (!isUndefined(from._l)) {\n            to._l = from._l;\n        }\n        if (!isUndefined(from._strict)) {\n            to._strict = from._strict;\n        }\n        if (!isUndefined(from._tzm)) {\n            to._tzm = from._tzm;\n        }\n        if (!isUndefined(from._isUTC)) {\n            to._isUTC = from._isUTC;\n        }\n        if (!isUndefined(from._offset)) {\n            to._offset = from._offset;\n        }\n        if (!isUndefined(from._pf)) {\n            to._pf = getParsingFlags(from);\n        }\n        if (!isUndefined(from._locale)) {\n            to._locale = from._locale;\n        }\n        if (momentPropertiesLen > 0) {\n            for(i = 0; i < momentPropertiesLen; i++){\n                prop = momentProperties[i];\n                val = from[prop];\n                if (!isUndefined(val)) {\n                    to[prop] = val;\n                }\n            }\n        }\n        return to;\n    }\n    // Moment prototype object\n    function Moment(config) {\n        copyConfig(this, config);\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n        if (!this.isValid()) {\n            this._d = new Date(NaN);\n        }\n        // Prevent infinite loop in case updateOffset creates new moment\n        // objects.\n        if (updateInProgress === false) {\n            updateInProgress = true;\n            hooks.updateOffset(this);\n            updateInProgress = false;\n        }\n    }\n    function isMoment(obj) {\n        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;\n    }\n    function warn(msg) {\n        if (hooks.suppressDeprecationWarnings === false && typeof console !== \"undefined\" && console.warn) {\n            console.warn(\"Deprecation warning: \" + msg);\n        }\n    }\n    function deprecate(msg, fn) {\n        var firstTime = true;\n        return extend(function() {\n            if (hooks.deprecationHandler != null) {\n                hooks.deprecationHandler(null, msg);\n            }\n            if (firstTime) {\n                var args = [], arg, i, key, argLen = arguments.length;\n                for(i = 0; i < argLen; i++){\n                    arg = \"\";\n                    if (typeof arguments[i] === \"object\") {\n                        arg += \"\\n[\" + i + \"] \";\n                        for(key in arguments[0]){\n                            if (hasOwnProp(arguments[0], key)) {\n                                arg += key + \": \" + arguments[0][key] + \", \";\n                            }\n                        }\n                        arg = arg.slice(0, -2); // Remove trailing comma and space\n                    } else {\n                        arg = arguments[i];\n                    }\n                    args.push(arg);\n                }\n                warn(msg + \"\\nArguments: \" + Array.prototype.slice.call(args).join(\"\") + \"\\n\" + new Error().stack);\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n    var deprecations = {};\n    function deprecateSimple(name, msg) {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(name, msg);\n        }\n        if (!deprecations[name]) {\n            warn(msg);\n            deprecations[name] = true;\n        }\n    }\n    hooks.suppressDeprecationWarnings = false;\n    hooks.deprecationHandler = null;\n    function isFunction(input) {\n        return typeof Function !== \"undefined\" && input instanceof Function || Object.prototype.toString.call(input) === \"[object Function]\";\n    }\n    function set(config) {\n        var prop, i;\n        for(i in config){\n            if (hasOwnProp(config, i)) {\n                prop = config[i];\n                if (isFunction(prop)) {\n                    this[i] = prop;\n                } else {\n                    this[\"_\" + i] = prop;\n                }\n            }\n        }\n        this._config = config;\n        // Lenient ordinal parsing accepts just a number in addition to\n        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + \"|\" + /\\d{1,2}/.source);\n    }\n    function mergeConfigs(parentConfig, childConfig) {\n        var res = extend({}, parentConfig), prop;\n        for(prop in childConfig){\n            if (hasOwnProp(childConfig, prop)) {\n                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                    res[prop] = {};\n                    extend(res[prop], parentConfig[prop]);\n                    extend(res[prop], childConfig[prop]);\n                } else if (childConfig[prop] != null) {\n                    res[prop] = childConfig[prop];\n                } else {\n                    delete res[prop];\n                }\n            }\n        }\n        for(prop in parentConfig){\n            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {\n                // make sure changes to properties don't modify parent config\n                res[prop] = extend({}, res[prop]);\n            }\n        }\n        return res;\n    }\n    function Locale(config) {\n        if (config != null) {\n            this.set(config);\n        }\n    }\n    var keys;\n    if (Object.keys) {\n        keys = Object.keys;\n    } else {\n        keys = function(obj) {\n            var i, res = [];\n            for(i in obj){\n                if (hasOwnProp(obj, i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        };\n    }\n    var defaultCalendar = {\n        sameDay: \"[Today at] LT\",\n        nextDay: \"[Tomorrow at] LT\",\n        nextWeek: \"dddd [at] LT\",\n        lastDay: \"[Yesterday at] LT\",\n        lastWeek: \"[Last] dddd [at] LT\",\n        sameElse: \"L\"\n    };\n    function calendar(key, mom, now) {\n        var output = this._calendar[key] || this._calendar[\"sameElse\"];\n        return isFunction(output) ? output.call(mom, now) : output;\n    }\n    function zeroFill(number, targetLength, forceSign) {\n        var absNumber = \"\" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;\n        return (sign ? forceSign ? \"+\" : \"\" : \"-\") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n    }\n    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};\n    // token:    'M'\n    // padded:   ['MM', 2]\n    // ordinal:  'Mo'\n    // callback: function () { this.month() + 1 }\n    function addFormatToken(token, padded, ordinal, callback) {\n        var func = callback;\n        if (typeof callback === \"string\") {\n            func = function() {\n                return this[callback]();\n            };\n        }\n        if (token) {\n            formatTokenFunctions[token] = func;\n        }\n        if (padded) {\n            formatTokenFunctions[padded[0]] = function() {\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n            };\n        }\n        if (ordinal) {\n            formatTokenFunctions[ordinal] = function() {\n                return this.localeData().ordinal(func.apply(this, arguments), token);\n            };\n        }\n    }\n    function removeFormattingTokens(input) {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g, \"\");\n        }\n        return input.replace(/\\\\/g, \"\");\n    }\n    function makeFormatFunction(format) {\n        var array = format.match(formattingTokens), i, length;\n        for(i = 0, length = array.length; i < length; i++){\n            if (formatTokenFunctions[array[i]]) {\n                array[i] = formatTokenFunctions[array[i]];\n            } else {\n                array[i] = removeFormattingTokens(array[i]);\n            }\n        }\n        return function(mom) {\n            var output = \"\", i;\n            for(i = 0; i < length; i++){\n                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n            }\n            return output;\n        };\n    }\n    // format date using native date object\n    function formatMoment(m, format) {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n        }\n        format = expandFormat(format, m.localeData());\n        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n        return formatFunctions[format](m);\n    }\n    function expandFormat(format, locale) {\n        var i = 5;\n        function replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input) || input;\n        }\n        localFormattingTokens.lastIndex = 0;\n        while(i >= 0 && localFormattingTokens.test(format)){\n            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n            localFormattingTokens.lastIndex = 0;\n            i -= 1;\n        }\n        return format;\n    }\n    var defaultLongDateFormat = {\n        LTS: \"h:mm:ss A\",\n        LT: \"h:mm A\",\n        L: \"MM/DD/YYYY\",\n        LL: \"MMMM D, YYYY\",\n        LLL: \"MMMM D, YYYY h:mm A\",\n        LLLL: \"dddd, MMMM D, YYYY h:mm A\"\n    };\n    function longDateFormat(key) {\n        var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];\n        if (format || !formatUpper) {\n            return format;\n        }\n        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {\n            if (tok === \"MMMM\" || tok === \"MM\" || tok === \"DD\" || tok === \"dddd\") {\n                return tok.slice(1);\n            }\n            return tok;\n        }).join(\"\");\n        return this._longDateFormat[key];\n    }\n    var defaultInvalidDate = \"Invalid date\";\n    function invalidDate() {\n        return this._invalidDate;\n    }\n    var defaultOrdinal = \"%d\", defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n    function ordinal(number) {\n        return this._ordinal.replace(\"%d\", number);\n    }\n    var defaultRelativeTime = {\n        future: \"in %s\",\n        past: \"%s ago\",\n        s: \"a few seconds\",\n        ss: \"%d seconds\",\n        m: \"a minute\",\n        mm: \"%d minutes\",\n        h: \"an hour\",\n        hh: \"%d hours\",\n        d: \"a day\",\n        dd: \"%d days\",\n        w: \"a week\",\n        ww: \"%d weeks\",\n        M: \"a month\",\n        MM: \"%d months\",\n        y: \"a year\",\n        yy: \"%d years\"\n    };\n    function relativeTime(number, withoutSuffix, string, isFuture) {\n        var output = this._relativeTime[string];\n        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);\n    }\n    function pastFuture(diff, output) {\n        var format = this._relativeTime[diff > 0 ? \"future\" : \"past\"];\n        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n    }\n    var aliases = {};\n    function addUnitAlias(unit, shorthand) {\n        var lowerCase = unit.toLowerCase();\n        aliases[lowerCase] = aliases[lowerCase + \"s\"] = aliases[shorthand] = unit;\n    }\n    function normalizeUnits(units) {\n        return typeof units === \"string\" ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n    }\n    function normalizeObjectUnits(inputObject) {\n        var normalizedInput = {}, normalizedProp, prop;\n        for(prop in inputObject){\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp] = inputObject[prop];\n                }\n            }\n        }\n        return normalizedInput;\n    }\n    var priorities = {};\n    function addUnitPriority(unit, priority) {\n        priorities[unit] = priority;\n    }\n    function getPrioritizedUnits(unitsObj) {\n        var units = [], u;\n        for(u in unitsObj){\n            if (hasOwnProp(unitsObj, u)) {\n                units.push({\n                    unit: u,\n                    priority: priorities[u]\n                });\n            }\n        }\n        units.sort(function(a, b) {\n            return a.priority - b.priority;\n        });\n        return units;\n    }\n    function isLeapYear(year) {\n        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n    }\n    function absFloor(number) {\n        if (number < 0) {\n            // -0 -> 0\n            return Math.ceil(number) || 0;\n        } else {\n            return Math.floor(number);\n        }\n    }\n    function toInt(argumentForCoercion) {\n        var coercedNumber = +argumentForCoercion, value = 0;\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            value = absFloor(coercedNumber);\n        }\n        return value;\n    }\n    function makeGetSet(unit, keepTime) {\n        return function(value) {\n            if (value != null) {\n                set$1(this, unit, value);\n                hooks.updateOffset(this, keepTime);\n                return this;\n            } else {\n                return get(this, unit);\n            }\n        };\n    }\n    function get(mom, unit) {\n        return mom.isValid() ? mom._d[\"get\" + (mom._isUTC ? \"UTC\" : \"\") + unit]() : NaN;\n    }\n    function set$1(mom, unit, value) {\n        if (mom.isValid() && !isNaN(value)) {\n            if (unit === \"FullYear\" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\n                value = toInt(value);\n                mom._d[\"set\" + (mom._isUTC ? \"UTC\" : \"\") + unit](value, mom.month(), daysInMonth(value, mom.month()));\n            } else {\n                mom._d[\"set\" + (mom._isUTC ? \"UTC\" : \"\") + unit](value);\n            }\n        }\n    }\n    // MOMENTS\n    function stringGet(units) {\n        units = normalizeUnits(units);\n        if (isFunction(this[units])) {\n            return this[units]();\n        }\n        return this;\n    }\n    function stringSet(units, value) {\n        if (typeof units === \"object\") {\n            units = normalizeObjectUnits(units);\n            var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;\n            for(i = 0; i < prioritizedLen; i++){\n                this[prioritized[i].unit](units[prioritized[i].unit]);\n            }\n        } else {\n            units = normalizeUnits(units);\n            if (isFunction(this[units])) {\n                return this[units](value);\n            }\n        }\n        return this;\n    }\n    var match1 = /\\d/, match2 = /\\d\\d/, match3 = /\\d{3}/, match4 = /\\d{4}/, match6 = /[+-]?\\d{6}/, match1to2 = /\\d\\d?/, match3to4 = /\\d\\d\\d\\d?/, match5to6 = /\\d\\d\\d\\d\\d\\d?/, match1to3 = /\\d{1,3}/, match1to4 = /\\d{1,4}/, match1to6 = /[+-]?\\d{1,6}/, matchUnsigned = /\\d+/, matchSigned = /[+-]?\\d+/, matchOffset = /Z|[+-]\\d\\d:?\\d\\d/gi, matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi, matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/, // any word (or two) characters or numbers including two/three word month in arabic.\n    // includes scottish gaelic two word and hyphenated months\n    matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i, regexes;\n    regexes = {};\n    function addRegexToken(token, regex, strictRegex) {\n        regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {\n            return isStrict && strictRegex ? strictRegex : regex;\n        };\n    }\n    function getParseRegexForToken(token, config) {\n        if (!hasOwnProp(regexes, token)) {\n            return new RegExp(unescapeFormat(token));\n        }\n        return regexes[token](config._strict, config._locale);\n    }\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n    function unescapeFormat(s) {\n        return regexEscape(s.replace(\"\\\\\", \"\").replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function(matched, p1, p2, p3, p4) {\n            return p1 || p2 || p3 || p4;\n        }));\n    }\n    function regexEscape(s) {\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n    }\n    var tokens = {};\n    function addParseToken(token, callback) {\n        var i, func = callback, tokenLen;\n        if (typeof token === \"string\") {\n            token = [\n                token\n            ];\n        }\n        if (isNumber(callback)) {\n            func = function(input, array) {\n                array[callback] = toInt(input);\n            };\n        }\n        tokenLen = token.length;\n        for(i = 0; i < tokenLen; i++){\n            tokens[token[i]] = func;\n        }\n    }\n    function addWeekParseToken(token, callback) {\n        addParseToken(token, function(input, array, config, token) {\n            config._w = config._w || {};\n            callback(input, config._w, config, token);\n        });\n    }\n    function addTimeToArrayFromToken(token, input, config) {\n        if (input != null && hasOwnProp(tokens, token)) {\n            tokens[token](input, config._a, config, token);\n        }\n    }\n    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;\n    function mod(n, x) {\n        return (n % x + x) % x;\n    }\n    var indexOf;\n    if (Array.prototype.indexOf) {\n        indexOf = Array.prototype.indexOf;\n    } else {\n        indexOf = function(o) {\n            // I know\n            var i;\n            for(i = 0; i < this.length; ++i){\n                if (this[i] === o) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n    }\n    function daysInMonth(year, month) {\n        if (isNaN(year) || isNaN(month)) {\n            return NaN;\n        }\n        var modMonth = mod(month, 12);\n        year += (month - modMonth) / 12;\n        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;\n    }\n    // FORMATTING\n    addFormatToken(\"M\", [\n        \"MM\",\n        2\n    ], \"Mo\", function() {\n        return this.month() + 1;\n    });\n    addFormatToken(\"MMM\", 0, 0, function(format) {\n        return this.localeData().monthsShort(this, format);\n    });\n    addFormatToken(\"MMMM\", 0, 0, function(format) {\n        return this.localeData().months(this, format);\n    });\n    // ALIASES\n    addUnitAlias(\"month\", \"M\");\n    // PRIORITY\n    addUnitPriority(\"month\", 8);\n    // PARSING\n    addRegexToken(\"M\", match1to2);\n    addRegexToken(\"MM\", match1to2, match2);\n    addRegexToken(\"MMM\", function(isStrict, locale) {\n        return locale.monthsShortRegex(isStrict);\n    });\n    addRegexToken(\"MMMM\", function(isStrict, locale) {\n        return locale.monthsRegex(isStrict);\n    });\n    addParseToken([\n        \"M\",\n        \"MM\"\n    ], function(input, array) {\n        array[MONTH] = toInt(input) - 1;\n    });\n    addParseToken([\n        \"MMM\",\n        \"MMMM\"\n    ], function(input, array, config, token) {\n        var month = config._locale.monthsParse(input, token, config._strict);\n        // if we didn't find a month name, mark the date as invalid.\n        if (month != null) {\n            array[MONTH] = month;\n        } else {\n            getParsingFlags(config).invalidMonth = input;\n        }\n    });\n    // LOCALES\n    var defaultLocaleMonths = \"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"), defaultLocaleMonthsShort = \"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec\".split(\"_\"), MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;\n    function localeMonths(m, format) {\n        if (!m) {\n            return isArray(this._months) ? this._months : this._months[\"standalone\"];\n        }\n        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? \"format\" : \"standalone\"][m.month()];\n    }\n    function localeMonthsShort(m, format) {\n        if (!m) {\n            return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort[\"standalone\"];\n        }\n        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? \"format\" : \"standalone\"][m.month()];\n    }\n    function handleStrictParse(monthName, format, strict) {\n        var i, ii, mom, llc = monthName.toLocaleLowerCase();\n        if (!this._monthsParse) {\n            // this is not used\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n            for(i = 0; i < 12; ++i){\n                mom = createUTC([\n                    2000,\n                    i\n                ]);\n                this._shortMonthsParse[i] = this.monthsShort(mom, \"\").toLocaleLowerCase();\n                this._longMonthsParse[i] = this.months(mom, \"\").toLocaleLowerCase();\n            }\n        }\n        if (strict) {\n            if (format === \"MMM\") {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === \"MMM\") {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n    function localeMonthsParse(monthName, format, strict) {\n        var i, mom, regex;\n        if (this._monthsParseExact) {\n            return handleStrictParse.call(this, monthName, format, strict);\n        }\n        if (!this._monthsParse) {\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n        }\n        // TODO: add sorting\n        // Sorting makes sure if one month (or abbr) is a prefix of another\n        // see sorting in computeMonthsParse\n        for(i = 0; i < 12; i++){\n            // make the regex if we don't have it already\n            mom = createUTC([\n                2000,\n                i\n            ]);\n            if (strict && !this._longMonthsParse[i]) {\n                this._longMonthsParse[i] = new RegExp(\"^\" + this.months(mom, \"\").replace(\".\", \"\") + \"$\", \"i\");\n                this._shortMonthsParse[i] = new RegExp(\"^\" + this.monthsShort(mom, \"\").replace(\".\", \"\") + \"$\", \"i\");\n            }\n            if (!strict && !this._monthsParse[i]) {\n                regex = \"^\" + this.months(mom, \"\") + \"|^\" + this.monthsShort(mom, \"\");\n                this._monthsParse[i] = new RegExp(regex.replace(\".\", \"\"), \"i\");\n            }\n            // test the regex\n            if (strict && format === \"MMMM\" && this._longMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (strict && format === \"MMM\" && this._shortMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\n                return i;\n            }\n        }\n    }\n    // MOMENTS\n    function setMonth(mom, value) {\n        var dayOfMonth;\n        if (!mom.isValid()) {\n            // No op\n            return mom;\n        }\n        if (typeof value === \"string\") {\n            if (/^\\d+$/.test(value)) {\n                value = toInt(value);\n            } else {\n                value = mom.localeData().monthsParse(value);\n                // TODO: Another silent failure?\n                if (!isNumber(value)) {\n                    return mom;\n                }\n            }\n        }\n        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n        mom._d[\"set\" + (mom._isUTC ? \"UTC\" : \"\") + \"Month\"](value, dayOfMonth);\n        return mom;\n    }\n    function getSetMonth(value) {\n        if (value != null) {\n            setMonth(this, value);\n            hooks.updateOffset(this, true);\n            return this;\n        } else {\n            return get(this, \"Month\");\n        }\n    }\n    function getDaysInMonth() {\n        return daysInMonth(this.year(), this.month());\n    }\n    function monthsShortRegex(isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, \"_monthsRegex\")) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsShortStrictRegex;\n            } else {\n                return this._monthsShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, \"_monthsShortRegex\")) {\n                this._monthsShortRegex = defaultMonthsShortRegex;\n            }\n            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;\n        }\n    }\n    function monthsRegex(isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, \"_monthsRegex\")) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsStrictRegex;\n            } else {\n                return this._monthsRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, \"_monthsRegex\")) {\n                this._monthsRegex = defaultMonthsRegex;\n            }\n            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;\n        }\n    }\n    function computeMonthsParse() {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;\n        for(i = 0; i < 12; i++){\n            // make the regex if we don't have it already\n            mom = createUTC([\n                2000,\n                i\n            ]);\n            shortPieces.push(this.monthsShort(mom, \"\"));\n            longPieces.push(this.months(mom, \"\"));\n            mixedPieces.push(this.months(mom, \"\"));\n            mixedPieces.push(this.monthsShort(mom, \"\"));\n        }\n        // Sorting makes sure if one month (or abbr) is a prefix of another it\n        // will match the longer piece.\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for(i = 0; i < 12; i++){\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n        }\n        for(i = 0; i < 24; i++){\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n        this._monthsRegex = new RegExp(\"^(\" + mixedPieces.join(\"|\") + \")\", \"i\");\n        this._monthsShortRegex = this._monthsRegex;\n        this._monthsStrictRegex = new RegExp(\"^(\" + longPieces.join(\"|\") + \")\", \"i\");\n        this._monthsShortStrictRegex = new RegExp(\"^(\" + shortPieces.join(\"|\") + \")\", \"i\");\n    }\n    // FORMATTING\n    addFormatToken(\"Y\", 0, 0, function() {\n        var y = this.year();\n        return y <= 9999 ? zeroFill(y, 4) : \"+\" + y;\n    });\n    addFormatToken(0, [\n        \"YY\",\n        2\n    ], 0, function() {\n        return this.year() % 100;\n    });\n    addFormatToken(0, [\n        \"YYYY\",\n        4\n    ], 0, \"year\");\n    addFormatToken(0, [\n        \"YYYYY\",\n        5\n    ], 0, \"year\");\n    addFormatToken(0, [\n        \"YYYYYY\",\n        6,\n        true\n    ], 0, \"year\");\n    // ALIASES\n    addUnitAlias(\"year\", \"y\");\n    // PRIORITIES\n    addUnitPriority(\"year\", 1);\n    // PARSING\n    addRegexToken(\"Y\", matchSigned);\n    addRegexToken(\"YY\", match1to2, match2);\n    addRegexToken(\"YYYY\", match1to4, match4);\n    addRegexToken(\"YYYYY\", match1to6, match6);\n    addRegexToken(\"YYYYYY\", match1to6, match6);\n    addParseToken([\n        \"YYYYY\",\n        \"YYYYYY\"\n    ], YEAR);\n    addParseToken(\"YYYY\", function(input, array) {\n        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n    });\n    addParseToken(\"YY\", function(input, array) {\n        array[YEAR] = hooks.parseTwoDigitYear(input);\n    });\n    addParseToken(\"Y\", function(input, array) {\n        array[YEAR] = parseInt(input, 10);\n    });\n    // HELPERS\n    function daysInYear(year) {\n        return isLeapYear(year) ? 366 : 365;\n    }\n    // HOOKS\n    hooks.parseTwoDigitYear = function(input) {\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n    // MOMENTS\n    var getSetYear = makeGetSet(\"FullYear\", true);\n    function getIsLeapYear() {\n        return isLeapYear(this.year());\n    }\n    function createDate(y, m, d, h, M, s, ms) {\n        // can't just apply() to create a date:\n        // https://stackoverflow.com/q/181348\n        var date;\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            date = new Date(y + 400, m, d, h, M, s, ms);\n            if (isFinite(date.getFullYear())) {\n                date.setFullYear(y);\n            }\n        } else {\n            date = new Date(y, m, d, h, M, s, ms);\n        }\n        return date;\n    }\n    function createUTCDate(y) {\n        var date, args;\n        // the Date.UTC function remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            args = Array.prototype.slice.call(arguments);\n            // preserve leap years using a full 400 year cycle, then reset\n            args[0] = y + 400;\n            date = new Date(Date.UTC.apply(null, args));\n            if (isFinite(date.getUTCFullYear())) {\n                date.setUTCFullYear(y);\n            }\n        } else {\n            date = new Date(Date.UTC.apply(null, arguments));\n        }\n        return date;\n    }\n    // start-of-first-week - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        var fwd = 7 + dow - doy, // first-week day local weekday -- which local weekday is fwd\n        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n        return -fwdlw + fwd - 1;\n    }\n    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;\n        if (dayOfYear <= 0) {\n            resYear = year - 1;\n            resDayOfYear = daysInYear(resYear) + dayOfYear;\n        } else if (dayOfYear > daysInYear(year)) {\n            resYear = year + 1;\n            resDayOfYear = dayOfYear - daysInYear(year);\n        } else {\n            resYear = year;\n            resDayOfYear = dayOfYear;\n        }\n        return {\n            year: resYear,\n            dayOfYear: resDayOfYear\n        };\n    }\n    function weekOfYear(mom, dow, doy) {\n        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;\n        if (week < 1) {\n            resYear = mom.year() - 1;\n            resWeek = week + weeksInYear(resYear, dow, doy);\n        } else if (week > weeksInYear(mom.year(), dow, doy)) {\n            resWeek = week - weeksInYear(mom.year(), dow, doy);\n            resYear = mom.year() + 1;\n        } else {\n            resYear = mom.year();\n            resWeek = week;\n        }\n        return {\n            week: resWeek,\n            year: resYear\n        };\n    }\n    function weeksInYear(year, dow, doy) {\n        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n    }\n    // FORMATTING\n    addFormatToken(\"w\", [\n        \"ww\",\n        2\n    ], \"wo\", \"week\");\n    addFormatToken(\"W\", [\n        \"WW\",\n        2\n    ], \"Wo\", \"isoWeek\");\n    // ALIASES\n    addUnitAlias(\"week\", \"w\");\n    addUnitAlias(\"isoWeek\", \"W\");\n    // PRIORITIES\n    addUnitPriority(\"week\", 5);\n    addUnitPriority(\"isoWeek\", 5);\n    // PARSING\n    addRegexToken(\"w\", match1to2);\n    addRegexToken(\"ww\", match1to2, match2);\n    addRegexToken(\"W\", match1to2);\n    addRegexToken(\"WW\", match1to2, match2);\n    addWeekParseToken([\n        \"w\",\n        \"ww\",\n        \"W\",\n        \"WW\"\n    ], function(input, week, config, token) {\n        week[token.substr(0, 1)] = toInt(input);\n    });\n    // HELPERS\n    // LOCALES\n    function localeWeek(mom) {\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n    }\n    var defaultLocaleWeek = {\n        dow: 0,\n        doy: 6\n    };\n    function localeFirstDayOfWeek() {\n        return this._week.dow;\n    }\n    function localeFirstDayOfYear() {\n        return this._week.doy;\n    }\n    // MOMENTS\n    function getSetWeek(input) {\n        var week = this.localeData().week(this);\n        return input == null ? week : this.add((input - week) * 7, \"d\");\n    }\n    function getSetISOWeek(input) {\n        var week = weekOfYear(this, 1, 4).week;\n        return input == null ? week : this.add((input - week) * 7, \"d\");\n    }\n    // FORMATTING\n    addFormatToken(\"d\", 0, \"do\", \"day\");\n    addFormatToken(\"dd\", 0, 0, function(format) {\n        return this.localeData().weekdaysMin(this, format);\n    });\n    addFormatToken(\"ddd\", 0, 0, function(format) {\n        return this.localeData().weekdaysShort(this, format);\n    });\n    addFormatToken(\"dddd\", 0, 0, function(format) {\n        return this.localeData().weekdays(this, format);\n    });\n    addFormatToken(\"e\", 0, 0, \"weekday\");\n    addFormatToken(\"E\", 0, 0, \"isoWeekday\");\n    // ALIASES\n    addUnitAlias(\"day\", \"d\");\n    addUnitAlias(\"weekday\", \"e\");\n    addUnitAlias(\"isoWeekday\", \"E\");\n    // PRIORITY\n    addUnitPriority(\"day\", 11);\n    addUnitPriority(\"weekday\", 11);\n    addUnitPriority(\"isoWeekday\", 11);\n    // PARSING\n    addRegexToken(\"d\", match1to2);\n    addRegexToken(\"e\", match1to2);\n    addRegexToken(\"E\", match1to2);\n    addRegexToken(\"dd\", function(isStrict, locale) {\n        return locale.weekdaysMinRegex(isStrict);\n    });\n    addRegexToken(\"ddd\", function(isStrict, locale) {\n        return locale.weekdaysShortRegex(isStrict);\n    });\n    addRegexToken(\"dddd\", function(isStrict, locale) {\n        return locale.weekdaysRegex(isStrict);\n    });\n    addWeekParseToken([\n        \"dd\",\n        \"ddd\",\n        \"dddd\"\n    ], function(input, week, config, token) {\n        var weekday = config._locale.weekdaysParse(input, token, config._strict);\n        // if we didn't get a weekday name, mark the date as invalid\n        if (weekday != null) {\n            week.d = weekday;\n        } else {\n            getParsingFlags(config).invalidWeekday = input;\n        }\n    });\n    addWeekParseToken([\n        \"d\",\n        \"e\",\n        \"E\"\n    ], function(input, week, config, token) {\n        week[token] = toInt(input);\n    });\n    // HELPERS\n    function parseWeekday(input, locale) {\n        if (typeof input !== \"string\") {\n            return input;\n        }\n        if (!isNaN(input)) {\n            return parseInt(input, 10);\n        }\n        input = locale.weekdaysParse(input);\n        if (typeof input === \"number\") {\n            return input;\n        }\n        return null;\n    }\n    function parseIsoWeekday(input, locale) {\n        if (typeof input === \"string\") {\n            return locale.weekdaysParse(input) % 7 || 7;\n        }\n        return isNaN(input) ? null : input;\n    }\n    // LOCALES\n    function shiftWeekdays(ws, n) {\n        return ws.slice(n, 7).concat(ws.slice(0, n));\n    }\n    var defaultLocaleWeekdays = \"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"), defaultLocaleWeekdaysShort = \"Sun_Mon_Tue_Wed_Thu_Fri_Sat\".split(\"_\"), defaultLocaleWeekdaysMin = \"Su_Mo_Tu_We_Th_Fr_Sa\".split(\"_\"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;\n    function localeWeekdays(m, format) {\n        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? \"format\" : \"standalone\"];\n        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;\n    }\n    function localeWeekdaysShort(m) {\n        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n    }\n    function localeWeekdaysMin(m) {\n        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n    }\n    function handleStrictParse$1(weekdayName, format, strict) {\n        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._minWeekdaysParse = [];\n            for(i = 0; i < 7; ++i){\n                mom = createUTC([\n                    2000,\n                    1\n                ]).day(i);\n                this._minWeekdaysParse[i] = this.weekdaysMin(mom, \"\").toLocaleLowerCase();\n                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, \"\").toLocaleLowerCase();\n                this._weekdaysParse[i] = this.weekdays(mom, \"\").toLocaleLowerCase();\n            }\n        }\n        if (strict) {\n            if (format === \"dddd\") {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === \"ddd\") {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === \"dddd\") {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === \"ddd\") {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n    function localeWeekdaysParse(weekdayName, format, strict) {\n        var i, mom, regex;\n        if (this._weekdaysParseExact) {\n            return handleStrictParse$1.call(this, weekdayName, format, strict);\n        }\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._minWeekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._fullWeekdaysParse = [];\n        }\n        for(i = 0; i < 7; i++){\n            // make the regex if we don't have it already\n            mom = createUTC([\n                2000,\n                1\n            ]).day(i);\n            if (strict && !this._fullWeekdaysParse[i]) {\n                this._fullWeekdaysParse[i] = new RegExp(\"^\" + this.weekdays(mom, \"\").replace(\".\", \"\\\\.?\") + \"$\", \"i\");\n                this._shortWeekdaysParse[i] = new RegExp(\"^\" + this.weekdaysShort(mom, \"\").replace(\".\", \"\\\\.?\") + \"$\", \"i\");\n                this._minWeekdaysParse[i] = new RegExp(\"^\" + this.weekdaysMin(mom, \"\").replace(\".\", \"\\\\.?\") + \"$\", \"i\");\n            }\n            if (!this._weekdaysParse[i]) {\n                regex = \"^\" + this.weekdays(mom, \"\") + \"|^\" + this.weekdaysShort(mom, \"\") + \"|^\" + this.weekdaysMin(mom, \"\");\n                this._weekdaysParse[i] = new RegExp(regex.replace(\".\", \"\"), \"i\");\n            }\n            // test the regex\n            if (strict && format === \"dddd\" && this._fullWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === \"ddd\" && this._shortWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === \"dd\" && this._minWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n                return i;\n            }\n        }\n    }\n    // MOMENTS\n    function getSetDayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n        if (input != null) {\n            input = parseWeekday(input, this.localeData());\n            return this.add(input - day, \"d\");\n        } else {\n            return day;\n        }\n    }\n    function getSetLocaleDayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n        return input == null ? weekday : this.add(input - weekday, \"d\");\n    }\n    function getSetISODayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        // behaves the same as moment#day except\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n        // as a setter, sunday should belong to the previous week.\n        if (input != null) {\n            var weekday = parseIsoWeekday(input, this.localeData());\n            return this.day(this.day() % 7 ? weekday : weekday - 7);\n        } else {\n            return this.day() || 7;\n        }\n    }\n    function weekdaysRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, \"_weekdaysRegex\")) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysStrictRegex;\n            } else {\n                return this._weekdaysRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, \"_weekdaysRegex\")) {\n                this._weekdaysRegex = defaultWeekdaysRegex;\n            }\n            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;\n        }\n    }\n    function weekdaysShortRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, \"_weekdaysRegex\")) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysShortStrictRegex;\n            } else {\n                return this._weekdaysShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, \"_weekdaysShortRegex\")) {\n                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n            }\n            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n        }\n    }\n    function weekdaysMinRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, \"_weekdaysRegex\")) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysMinStrictRegex;\n            } else {\n                return this._weekdaysMinRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, \"_weekdaysMinRegex\")) {\n                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n            }\n            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n        }\n    }\n    function computeWeekdaysParse() {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;\n        for(i = 0; i < 7; i++){\n            // make the regex if we don't have it already\n            mom = createUTC([\n                2000,\n                1\n            ]).day(i);\n            minp = regexEscape(this.weekdaysMin(mom, \"\"));\n            shortp = regexEscape(this.weekdaysShort(mom, \"\"));\n            longp = regexEscape(this.weekdays(mom, \"\"));\n            minPieces.push(minp);\n            shortPieces.push(shortp);\n            longPieces.push(longp);\n            mixedPieces.push(minp);\n            mixedPieces.push(shortp);\n            mixedPieces.push(longp);\n        }\n        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n        // will match the longer piece.\n        minPieces.sort(cmpLenRev);\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        this._weekdaysRegex = new RegExp(\"^(\" + mixedPieces.join(\"|\") + \")\", \"i\");\n        this._weekdaysShortRegex = this._weekdaysRegex;\n        this._weekdaysMinRegex = this._weekdaysRegex;\n        this._weekdaysStrictRegex = new RegExp(\"^(\" + longPieces.join(\"|\") + \")\", \"i\");\n        this._weekdaysShortStrictRegex = new RegExp(\"^(\" + shortPieces.join(\"|\") + \")\", \"i\");\n        this._weekdaysMinStrictRegex = new RegExp(\"^(\" + minPieces.join(\"|\") + \")\", \"i\");\n    }\n    // FORMATTING\n    function hFormat() {\n        return this.hours() % 12 || 12;\n    }\n    function kFormat() {\n        return this.hours() || 24;\n    }\n    addFormatToken(\"H\", [\n        \"HH\",\n        2\n    ], 0, \"hour\");\n    addFormatToken(\"h\", [\n        \"hh\",\n        2\n    ], 0, hFormat);\n    addFormatToken(\"k\", [\n        \"kk\",\n        2\n    ], 0, kFormat);\n    addFormatToken(\"hmm\", 0, 0, function() {\n        return \"\" + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n    });\n    addFormatToken(\"hmmss\", 0, 0, function() {\n        return \"\" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);\n    });\n    addFormatToken(\"Hmm\", 0, 0, function() {\n        return \"\" + this.hours() + zeroFill(this.minutes(), 2);\n    });\n    addFormatToken(\"Hmmss\", 0, 0, function() {\n        return \"\" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);\n    });\n    function meridiem(token, lowercase) {\n        addFormatToken(token, 0, 0, function() {\n            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n        });\n    }\n    meridiem(\"a\", true);\n    meridiem(\"A\", false);\n    // ALIASES\n    addUnitAlias(\"hour\", \"h\");\n    // PRIORITY\n    addUnitPriority(\"hour\", 13);\n    // PARSING\n    function matchMeridiem(isStrict, locale) {\n        return locale._meridiemParse;\n    }\n    addRegexToken(\"a\", matchMeridiem);\n    addRegexToken(\"A\", matchMeridiem);\n    addRegexToken(\"H\", match1to2);\n    addRegexToken(\"h\", match1to2);\n    addRegexToken(\"k\", match1to2);\n    addRegexToken(\"HH\", match1to2, match2);\n    addRegexToken(\"hh\", match1to2, match2);\n    addRegexToken(\"kk\", match1to2, match2);\n    addRegexToken(\"hmm\", match3to4);\n    addRegexToken(\"hmmss\", match5to6);\n    addRegexToken(\"Hmm\", match3to4);\n    addRegexToken(\"Hmmss\", match5to6);\n    addParseToken([\n        \"H\",\n        \"HH\"\n    ], HOUR);\n    addParseToken([\n        \"k\",\n        \"kk\"\n    ], function(input, array, config) {\n        var kInput = toInt(input);\n        array[HOUR] = kInput === 24 ? 0 : kInput;\n    });\n    addParseToken([\n        \"a\",\n        \"A\"\n    ], function(input, array, config) {\n        config._isPm = config._locale.isPM(input);\n        config._meridiem = input;\n    });\n    addParseToken([\n        \"h\",\n        \"hh\"\n    ], function(input, array, config) {\n        array[HOUR] = toInt(input);\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken(\"hmm\", function(input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken(\"hmmss\", function(input, array, config) {\n        var pos1 = input.length - 4, pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken(\"Hmm\", function(input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n    });\n    addParseToken(\"Hmmss\", function(input, array, config) {\n        var pos1 = input.length - 4, pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n    });\n    // LOCALES\n    function localeIsPM(input) {\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n        // Using charAt should be more compatible.\n        return (input + \"\").toLowerCase().charAt(0) === \"p\";\n    }\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i, // Setting the hour should keep the time, because the user explicitly\n    // specified which hour they want. So trying to maintain the same hour (in\n    // a new timezone) makes sense. Adding/subtracting hours does not follow\n    // this rule.\n    getSetHour = makeGetSet(\"Hours\", true);\n    function localeMeridiem(hours, minutes, isLower) {\n        if (hours > 11) {\n            return isLower ? \"pm\" : \"PM\";\n        } else {\n            return isLower ? \"am\" : \"AM\";\n        }\n    }\n    var baseConfig = {\n        calendar: defaultCalendar,\n        longDateFormat: defaultLongDateFormat,\n        invalidDate: defaultInvalidDate,\n        ordinal: defaultOrdinal,\n        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n        relativeTime: defaultRelativeTime,\n        months: defaultLocaleMonths,\n        monthsShort: defaultLocaleMonthsShort,\n        week: defaultLocaleWeek,\n        weekdays: defaultLocaleWeekdays,\n        weekdaysMin: defaultLocaleWeekdaysMin,\n        weekdaysShort: defaultLocaleWeekdaysShort,\n        meridiemParse: defaultLocaleMeridiemParse\n    };\n    // internal storage for locale config files\n    var locales = {}, localeFamilies = {}, globalLocale;\n    function commonPrefix(arr1, arr2) {\n        var i, minl = Math.min(arr1.length, arr2.length);\n        for(i = 0; i < minl; i += 1){\n            if (arr1[i] !== arr2[i]) {\n                return i;\n            }\n        }\n        return minl;\n    }\n    function normalizeLocale(key) {\n        return key ? key.toLowerCase().replace(\"_\", \"-\") : key;\n    }\n    // pick the locale from the array\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n    function chooseLocale(names) {\n        var i = 0, j, next, locale, split;\n        while(i < names.length){\n            split = normalizeLocale(names[i]).split(\"-\");\n            j = split.length;\n            next = normalizeLocale(names[i + 1]);\n            next = next ? next.split(\"-\") : null;\n            while(j > 0){\n                locale = loadLocale(split.slice(0, j).join(\"-\"));\n                if (locale) {\n                    return locale;\n                }\n                if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {\n                    break;\n                }\n                j--;\n            }\n            i++;\n        }\n        return globalLocale;\n    }\n    function isLocaleNameSane(name) {\n        // Prevent names that look like filesystem paths, i.e contain '/' or '\\'\n        return name.match(\"^[^/\\\\\\\\]*$\") != null;\n    }\n    function loadLocale(name) {\n        var oldLocale = null, aliasedRequire;\n        // TODO: Find a better way to register and load all the locales in Node\n        if (locales[name] === undefined && \"object\" !== \"undefined\" && module && module.exports && isLocaleNameSane(name)) {\n            try {\n                oldLocale = globalLocale._abbr;\n                aliasedRequire = undefined;\n                Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'undefined'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n                getSetGlobalLocale(oldLocale);\n            } catch (e) {\n                // mark as not found to avoid repeating expensive file require call causing high CPU\n                // when trying to find en-US, en_US, en-us for every format call\n                locales[name] = null; // null means not found\n            }\n        }\n        return locales[name];\n    }\n    // This function will load locale and then set the global locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    function getSetGlobalLocale(key, values) {\n        var data;\n        if (key) {\n            if (isUndefined(values)) {\n                data = getLocale(key);\n            } else {\n                data = defineLocale(key, values);\n            }\n            if (data) {\n                // moment.duration._locale = moment._locale = data;\n                globalLocale = data;\n            } else {\n                if (typeof console !== \"undefined\" && console.warn) {\n                    //warn user if arguments are passed but the locale could not be set\n                    console.warn(\"Locale \" + key + \" not found. Did you forget to load it?\");\n                }\n            }\n        }\n        return globalLocale._abbr;\n    }\n    function defineLocale(name, config) {\n        if (config !== null) {\n            var locale, parentConfig = baseConfig;\n            config.abbr = name;\n            if (locales[name] != null) {\n                deprecateSimple(\"defineLocaleOverride\", \"use moment.updateLocale(localeName, config) to change \" + \"an existing locale. moment.defineLocale(localeName, \" + \"config) should only be used for creating a new locale \" + \"See http://momentjs.com/guides/#/warnings/define-locale/ for more info.\");\n                parentConfig = locales[name]._config;\n            } else if (config.parentLocale != null) {\n                if (locales[config.parentLocale] != null) {\n                    parentConfig = locales[config.parentLocale]._config;\n                } else {\n                    locale = loadLocale(config.parentLocale);\n                    if (locale != null) {\n                        parentConfig = locale._config;\n                    } else {\n                        if (!localeFamilies[config.parentLocale]) {\n                            localeFamilies[config.parentLocale] = [];\n                        }\n                        localeFamilies[config.parentLocale].push({\n                            name: name,\n                            config: config\n                        });\n                        return null;\n                    }\n                }\n            }\n            locales[name] = new Locale(mergeConfigs(parentConfig, config));\n            if (localeFamilies[name]) {\n                localeFamilies[name].forEach(function(x) {\n                    defineLocale(x.name, x.config);\n                });\n            }\n            // backwards compat for now: also set the locale\n            // make sure we set the locale AFTER all child locales have been\n            // created, so we won't end up with the child locale set.\n            getSetGlobalLocale(name);\n            return locales[name];\n        } else {\n            // useful for testing\n            delete locales[name];\n            return null;\n        }\n    }\n    function updateLocale(name, config) {\n        if (config != null) {\n            var locale, tmpLocale, parentConfig = baseConfig;\n            if (locales[name] != null && locales[name].parentLocale != null) {\n                // Update existing child locale in-place to avoid memory-leaks\n                locales[name].set(mergeConfigs(locales[name]._config, config));\n            } else {\n                // MERGE\n                tmpLocale = loadLocale(name);\n                if (tmpLocale != null) {\n                    parentConfig = tmpLocale._config;\n                }\n                config = mergeConfigs(parentConfig, config);\n                if (tmpLocale == null) {\n                    // updateLocale is called for creating a new locale\n                    // Set abbr so it will have a name (getters return\n                    // undefined otherwise).\n                    config.abbr = name;\n                }\n                locale = new Locale(config);\n                locale.parentLocale = locales[name];\n                locales[name] = locale;\n            }\n            // backwards compat for now: also set the locale\n            getSetGlobalLocale(name);\n        } else {\n            // pass null for config to unupdate, useful for tests\n            if (locales[name] != null) {\n                if (locales[name].parentLocale != null) {\n                    locales[name] = locales[name].parentLocale;\n                    if (name === getSetGlobalLocale()) {\n                        getSetGlobalLocale(name);\n                    }\n                } else if (locales[name] != null) {\n                    delete locales[name];\n                }\n            }\n        }\n        return locales[name];\n    }\n    // returns locale data\n    function getLocale(key) {\n        var locale;\n        if (key && key._locale && key._locale._abbr) {\n            key = key._locale._abbr;\n        }\n        if (!key) {\n            return globalLocale;\n        }\n        if (!isArray(key)) {\n            //short-circuit everything else\n            locale = loadLocale(key);\n            if (locale) {\n                return locale;\n            }\n            key = [\n                key\n            ];\n        }\n        return chooseLocale(key);\n    }\n    function listLocales() {\n        return keys(locales);\n    }\n    function checkOverflow(m) {\n        var overflow, a = m._a;\n        if (a && getParsingFlags(m).overflow === -2) {\n            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;\n            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n                overflow = DATE;\n            }\n            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n                overflow = WEEK;\n            }\n            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n                overflow = WEEKDAY;\n            }\n            getParsingFlags(m).overflow = overflow;\n        }\n        return m;\n    }\n    // iso 8601 regex\n    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n    var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/, basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d|))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/, tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/, isoDates = [\n        [\n            \"YYYYYY-MM-DD\",\n            /[+-]\\d{6}-\\d\\d-\\d\\d/\n        ],\n        [\n            \"YYYY-MM-DD\",\n            /\\d{4}-\\d\\d-\\d\\d/\n        ],\n        [\n            \"GGGG-[W]WW-E\",\n            /\\d{4}-W\\d\\d-\\d/\n        ],\n        [\n            \"GGGG-[W]WW\",\n            /\\d{4}-W\\d\\d/,\n            false\n        ],\n        [\n            \"YYYY-DDD\",\n            /\\d{4}-\\d{3}/\n        ],\n        [\n            \"YYYY-MM\",\n            /\\d{4}-\\d\\d/,\n            false\n        ],\n        [\n            \"YYYYYYMMDD\",\n            /[+-]\\d{10}/\n        ],\n        [\n            \"YYYYMMDD\",\n            /\\d{8}/\n        ],\n        [\n            \"GGGG[W]WWE\",\n            /\\d{4}W\\d{3}/\n        ],\n        [\n            \"GGGG[W]WW\",\n            /\\d{4}W\\d{2}/,\n            false\n        ],\n        [\n            \"YYYYDDD\",\n            /\\d{7}/\n        ],\n        [\n            \"YYYYMM\",\n            /\\d{6}/,\n            false\n        ],\n        [\n            \"YYYY\",\n            /\\d{4}/,\n            false\n        ]\n    ], // iso time formats and regexes\n    isoTimes = [\n        [\n            \"HH:mm:ss.SSSS\",\n            /\\d\\d:\\d\\d:\\d\\d\\.\\d+/\n        ],\n        [\n            \"HH:mm:ss,SSSS\",\n            /\\d\\d:\\d\\d:\\d\\d,\\d+/\n        ],\n        [\n            \"HH:mm:ss\",\n            /\\d\\d:\\d\\d:\\d\\d/\n        ],\n        [\n            \"HH:mm\",\n            /\\d\\d:\\d\\d/\n        ],\n        [\n            \"HHmmss.SSSS\",\n            /\\d\\d\\d\\d\\d\\d\\.\\d+/\n        ],\n        [\n            \"HHmmss,SSSS\",\n            /\\d\\d\\d\\d\\d\\d,\\d+/\n        ],\n        [\n            \"HHmmss\",\n            /\\d\\d\\d\\d\\d\\d/\n        ],\n        [\n            \"HHmm\",\n            /\\d\\d\\d\\d/\n        ],\n        [\n            \"HH\",\n            /\\d\\d/\n        ]\n    ], aspNetJsonRegex = /^\\/?Date\\((-?\\d+)/i, // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n    rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/, obsOffsets = {\n        UT: 0,\n        GMT: 0,\n        EDT: -4 * 60,\n        EST: -5 * 60,\n        CDT: -5 * 60,\n        CST: -6 * 60,\n        MDT: -6 * 60,\n        MST: -7 * 60,\n        PDT: -7 * 60,\n        PST: -8 * 60\n    };\n    // date from iso format\n    function configFromISO(config) {\n        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;\n        if (match) {\n            getParsingFlags(config).iso = true;\n            for(i = 0, l = isoDatesLen; i < l; i++){\n                if (isoDates[i][1].exec(match[1])) {\n                    dateFormat = isoDates[i][0];\n                    allowTime = isoDates[i][2] !== false;\n                    break;\n                }\n            }\n            if (dateFormat == null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[3]) {\n                for(i = 0, l = isoTimesLen; i < l; i++){\n                    if (isoTimes[i][1].exec(match[3])) {\n                        // match[2] should be 'T' or space\n                        timeFormat = (match[2] || \" \") + isoTimes[i][0];\n                        break;\n                    }\n                }\n                if (timeFormat == null) {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            if (!allowTime && timeFormat != null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[4]) {\n                if (tzRegex.exec(match[4])) {\n                    tzFormat = \"Z\";\n                } else {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            config._f = dateFormat + (timeFormat || \"\") + (tzFormat || \"\");\n            configFromStringAndFormat(config);\n        } else {\n            config._isValid = false;\n        }\n    }\n    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n        var result = [\n            untruncateYear(yearStr),\n            defaultLocaleMonthsShort.indexOf(monthStr),\n            parseInt(dayStr, 10),\n            parseInt(hourStr, 10),\n            parseInt(minuteStr, 10)\n        ];\n        if (secondStr) {\n            result.push(parseInt(secondStr, 10));\n        }\n        return result;\n    }\n    function untruncateYear(yearStr) {\n        var year = parseInt(yearStr, 10);\n        if (year <= 49) {\n            return 2000 + year;\n        } else if (year <= 999) {\n            return 1900 + year;\n        }\n        return year;\n    }\n    function preprocessRFC2822(s) {\n        // Remove comments and folding whitespace and replace multiple-spaces with a single space\n        return s.replace(/\\([^()]*\\)|[\\n\\t]/g, \" \").replace(/(\\s\\s+)/g, \" \").replace(/^\\s\\s*/, \"\").replace(/\\s\\s*$/, \"\");\n    }\n    function checkWeekday(weekdayStr, parsedInput, config) {\n        if (weekdayStr) {\n            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.\n            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\n            if (weekdayProvided !== weekdayActual) {\n                getParsingFlags(config).weekdayMismatch = true;\n                config._isValid = false;\n                return false;\n            }\n        }\n        return true;\n    }\n    function calculateOffset(obsOffset, militaryOffset, numOffset) {\n        if (obsOffset) {\n            return obsOffsets[obsOffset];\n        } else if (militaryOffset) {\n            // the only allowed military tz is Z\n            return 0;\n        } else {\n            var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;\n            return h * 60 + m;\n        }\n    }\n    // date and time from ref 2822 format\n    function configFromRFC2822(config) {\n        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;\n        if (match) {\n            parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\n            if (!checkWeekday(match[1], parsedArray, config)) {\n                return;\n            }\n            config._a = parsedArray;\n            config._tzm = calculateOffset(match[8], match[9], match[10]);\n            config._d = createUTCDate.apply(null, config._a);\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n            getParsingFlags(config).rfc2822 = true;\n        } else {\n            config._isValid = false;\n        }\n    }\n    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict\n    function configFromString(config) {\n        var matched = aspNetJsonRegex.exec(config._i);\n        if (matched !== null) {\n            config._d = new Date(+matched[1]);\n            return;\n        }\n        configFromISO(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n        configFromRFC2822(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n        if (config._strict) {\n            config._isValid = false;\n        } else {\n            // Final attempt, use Input Fallback\n            hooks.createFromInputFallback(config);\n        }\n    }\n    hooks.createFromInputFallback = deprecate(\"value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), \" + \"which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are \" + \"discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.\", function(config) {\n        config._d = new Date(config._i + (config._useUTC ? \" UTC\" : \"\"));\n    });\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n    function currentDateArray(config) {\n        // hooks is actually the exported moment object\n        var nowValue = new Date(hooks.now());\n        if (config._useUTC) {\n            return [\n                nowValue.getUTCFullYear(),\n                nowValue.getUTCMonth(),\n                nowValue.getUTCDate()\n            ];\n        }\n        return [\n            nowValue.getFullYear(),\n            nowValue.getMonth(),\n            nowValue.getDate()\n        ];\n    }\n    // convert an array to a date.\n    // the array should mirror the parameters below\n    // note: all values past the year are optional and will default to the lowest possible value.\n    // [year, month, day , hour, minute, second, millisecond]\n    function configFromArray(config) {\n        var i, date, input = [], currentDate, expectedWeekday, yearToUse;\n        if (config._d) {\n            return;\n        }\n        currentDate = currentDateArray(config);\n        //compute day of the year from weeks and weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n        //if the day of the year is set, figure out what it is\n        if (config._dayOfYear != null) {\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n                getParsingFlags(config)._overflowDayOfYear = true;\n            }\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n            config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE] = date.getUTCDate();\n        }\n        // Default to current date.\n        // * if no year, month, day of month are given, default to today\n        // * if day of month is given, default month and year\n        // * if month is given, default only year\n        // * if year is given, don't default anything\n        for(i = 0; i < 3 && config._a[i] == null; ++i){\n            config._a[i] = input[i] = currentDate[i];\n        }\n        // Zero out whatever was not defaulted, including time\n        for(; i < 7; i++){\n            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];\n        }\n        // Check for 24:00:00.000\n        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n        }\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();\n        // Apply timezone offset from input. The actual utcOffset can be changed\n        // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n        }\n        if (config._nextDay) {\n            config._a[HOUR] = 24;\n        }\n        // check for mismatching day of week\n        if (config._w && typeof config._w.d !== \"undefined\" && config._w.d !== expectedWeekday) {\n            getParsingFlags(config).weekdayMismatch = true;\n        }\n    }\n    function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;\n        w = config._w;\n        if (w.GG != null || w.W != null || w.E != null) {\n            dow = 1;\n            doy = 4;\n            // TODO: We need to take the current isoWeekYear, but that depends on\n            // how we interpret now (local, utc, fixed offset). So create\n            // a now version of current config (take local/utc/offset flags, and\n            // create now).\n            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n            week = defaults(w.W, 1);\n            weekday = defaults(w.E, 1);\n            if (weekday < 1 || weekday > 7) {\n                weekdayOverflow = true;\n            }\n        } else {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n            curWeek = weekOfYear(createLocal(), dow, doy);\n            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n            // Default to current week.\n            week = defaults(w.w, curWeek.week);\n            if (w.d != null) {\n                // weekday -- low day numbers are considered next week\n                weekday = w.d;\n                if (weekday < 0 || weekday > 6) {\n                    weekdayOverflow = true;\n                }\n            } else if (w.e != null) {\n                // local weekday -- counting starts from beginning of week\n                weekday = w.e + dow;\n                if (w.e < 0 || w.e > 6) {\n                    weekdayOverflow = true;\n                }\n            } else {\n                // default to beginning of week\n                weekday = dow;\n            }\n        }\n        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n            getParsingFlags(config)._overflowWeeks = true;\n        } else if (weekdayOverflow != null) {\n            getParsingFlags(config)._overflowWeekday = true;\n        } else {\n            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n            config._a[YEAR] = temp.year;\n            config._dayOfYear = temp.dayOfYear;\n        }\n    }\n    // constant that refers to the ISO standard\n    hooks.ISO_8601 = function() {};\n    // constant that refers to the RFC 2822 form\n    hooks.RFC_2822 = function() {};\n    // date from string and format string\n    function configFromStringAndFormat(config) {\n        // TODO: Move this to another part of the creation flow to prevent circular deps\n        if (config._f === hooks.ISO_8601) {\n            configFromISO(config);\n            return;\n        }\n        if (config._f === hooks.RFC_2822) {\n            configFromRFC2822(config);\n            return;\n        }\n        config._a = [];\n        getParsingFlags(config).empty = true;\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n        var string = \"\" + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;\n        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n        tokenLen = tokens.length;\n        for(i = 0; i < tokenLen; i++){\n            token = tokens[i];\n            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n            if (parsedInput) {\n                skipped = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length > 0) {\n                    getParsingFlags(config).unusedInput.push(skipped);\n                }\n                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n                totalParsedInputLength += parsedInput.length;\n            }\n            // don't parse if it's not a known token\n            if (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    getParsingFlags(config).empty = false;\n                } else {\n                    getParsingFlags(config).unusedTokens.push(token);\n                }\n                addTimeToArrayFromToken(token, parsedInput, config);\n            } else if (config._strict && !parsedInput) {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n        }\n        // add remaining unparsed input length to the string\n        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            getParsingFlags(config).unusedInput.push(string);\n        }\n        // clear _12h flag if hour is <= 12\n        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {\n            getParsingFlags(config).bigHour = undefined;\n        }\n        getParsingFlags(config).parsedDateParts = config._a.slice(0);\n        getParsingFlags(config).meridiem = config._meridiem;\n        // handle meridiem\n        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n        // handle era\n        era = getParsingFlags(config).era;\n        if (era !== null) {\n            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);\n        }\n        configFromArray(config);\n        checkOverflow(config);\n    }\n    function meridiemFixWrap(locale, hour, meridiem) {\n        var isPm;\n        if (meridiem == null) {\n            // nothing to do\n            return hour;\n        }\n        if (locale.meridiemHour != null) {\n            return locale.meridiemHour(hour, meridiem);\n        } else if (locale.isPM != null) {\n            // Fallback\n            isPm = locale.isPM(meridiem);\n            if (isPm && hour < 12) {\n                hour += 12;\n            }\n            if (!isPm && hour === 12) {\n                hour = 0;\n            }\n            return hour;\n        } else {\n            // this is not supposed to happen\n            return hour;\n        }\n    }\n    // date from string and array of format strings\n    function configFromStringAndArray(config) {\n        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;\n        if (configfLen === 0) {\n            getParsingFlags(config).invalidFormat = true;\n            config._d = new Date(NaN);\n            return;\n        }\n        for(i = 0; i < configfLen; i++){\n            currentScore = 0;\n            validFormatFound = false;\n            tempConfig = copyConfig({}, config);\n            if (config._useUTC != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n            tempConfig._f = config._f[i];\n            configFromStringAndFormat(tempConfig);\n            if (isValid(tempConfig)) {\n                validFormatFound = true;\n            }\n            // if there is any input that was not parsed add a penalty for that format\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n            //or tokens\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n            getParsingFlags(tempConfig).score = currentScore;\n            if (!bestFormatIsValid) {\n                if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {\n                    scoreToBeat = currentScore;\n                    bestMoment = tempConfig;\n                    if (validFormatFound) {\n                        bestFormatIsValid = true;\n                    }\n                }\n            } else {\n                if (currentScore < scoreToBeat) {\n                    scoreToBeat = currentScore;\n                    bestMoment = tempConfig;\n                }\n            }\n        }\n        extend(config, bestMoment || tempConfig);\n    }\n    function configFromObject(config) {\n        if (config._d) {\n            return;\n        }\n        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === undefined ? i.date : i.day;\n        config._a = map([\n            i.year,\n            i.month,\n            dayOrDate,\n            i.hour,\n            i.minute,\n            i.second,\n            i.millisecond\n        ], function(obj) {\n            return obj && parseInt(obj, 10);\n        });\n        configFromArray(config);\n    }\n    function createFromConfig(config) {\n        var res = new Moment(checkOverflow(prepareConfig(config)));\n        if (res._nextDay) {\n            // Adding is smart enough around DST\n            res.add(1, \"d\");\n            res._nextDay = undefined;\n        }\n        return res;\n    }\n    function prepareConfig(config) {\n        var input = config._i, format = config._f;\n        config._locale = config._locale || getLocale(config._l);\n        if (input === null || format === undefined && input === \"\") {\n            return createInvalid({\n                nullInput: true\n            });\n        }\n        if (typeof input === \"string\") {\n            config._i = input = config._locale.preparse(input);\n        }\n        if (isMoment(input)) {\n            return new Moment(checkOverflow(input));\n        } else if (isDate(input)) {\n            config._d = input;\n        } else if (isArray(format)) {\n            configFromStringAndArray(config);\n        } else if (format) {\n            configFromStringAndFormat(config);\n        } else {\n            configFromInput(config);\n        }\n        if (!isValid(config)) {\n            config._d = null;\n        }\n        return config;\n    }\n    function configFromInput(config) {\n        var input = config._i;\n        if (isUndefined(input)) {\n            config._d = new Date(hooks.now());\n        } else if (isDate(input)) {\n            config._d = new Date(input.valueOf());\n        } else if (typeof input === \"string\") {\n            configFromString(config);\n        } else if (isArray(input)) {\n            config._a = map(input.slice(0), function(obj) {\n                return parseInt(obj, 10);\n            });\n            configFromArray(config);\n        } else if (isObject(input)) {\n            configFromObject(config);\n        } else if (isNumber(input)) {\n            // from milliseconds\n            config._d = new Date(input);\n        } else {\n            hooks.createFromInputFallback(config);\n        }\n    }\n    function createLocalOrUTC(input, format, locale, strict, isUTC) {\n        var c = {};\n        if (format === true || format === false) {\n            strict = format;\n            format = undefined;\n        }\n        if (locale === true || locale === false) {\n            strict = locale;\n            locale = undefined;\n        }\n        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {\n            input = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c._isAMomentObject = true;\n        c._useUTC = c._isUTC = isUTC;\n        c._l = locale;\n        c._i = input;\n        c._f = format;\n        c._strict = strict;\n        return createFromConfig(c);\n    }\n    function createLocal(input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, false);\n    }\n    var prototypeMin = deprecate(\"moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/\", function() {\n        var other = createLocal.apply(null, arguments);\n        if (this.isValid() && other.isValid()) {\n            return other < this ? this : other;\n        } else {\n            return createInvalid();\n        }\n    }), prototypeMax = deprecate(\"moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/\", function() {\n        var other = createLocal.apply(null, arguments);\n        if (this.isValid() && other.isValid()) {\n            return other > this ? this : other;\n        } else {\n            return createInvalid();\n        }\n    });\n    // Pick a moment m from moments so that m[fn](other) is true for all\n    // other. This relies on the function fn to be transitive.\n    //\n    // moments should either be an array of moment objects or an array, whose\n    // first element is an array of moment objects.\n    function pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if (!moments.length) {\n            return createLocal();\n        }\n        res = moments[0];\n        for(i = 1; i < moments.length; ++i){\n            if (!moments[i].isValid() || moments[i][fn](res)) {\n                res = moments[i];\n            }\n        }\n        return res;\n    }\n    // TODO: Use [].sort instead?\n    function min() {\n        var args = [].slice.call(arguments, 0);\n        return pickBy(\"isBefore\", args);\n    }\n    function max() {\n        var args = [].slice.call(arguments, 0);\n        return pickBy(\"isAfter\", args);\n    }\n    var now = function() {\n        return Date.now ? Date.now() : +new Date();\n    };\n    var ordering = [\n        \"year\",\n        \"quarter\",\n        \"month\",\n        \"week\",\n        \"day\",\n        \"hour\",\n        \"minute\",\n        \"second\",\n        \"millisecond\"\n    ];\n    function isDurationValid(m) {\n        var key, unitHasDecimal = false, i, orderLen = ordering.length;\n        for(key in m){\n            if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n                return false;\n            }\n        }\n        for(i = 0; i < orderLen; ++i){\n            if (m[ordering[i]]) {\n                if (unitHasDecimal) {\n                    return false; // only allow non-integers for smallest unit\n                }\n                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n                    unitHasDecimal = true;\n                }\n            }\n        }\n        return true;\n    }\n    function isValid$1() {\n        return this._isValid;\n    }\n    function createInvalid$1() {\n        return createDuration(NaN);\n    }\n    function Duration(duration) {\n        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || normalizedInput.isoWeek || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;\n        this._isValid = isDurationValid(normalizedInput);\n        // representation for dateAddRemove\n        this._milliseconds = +milliseconds + seconds * 1e3 + // 1000\n        minutes * 6e4 + // 1000 * 60\n        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = +days + weeks * 7;\n        // It is impossible to translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = +months + quarters * 3 + years * 12;\n        this._data = {};\n        this._locale = getLocale();\n        this._bubble();\n    }\n    function isDuration(obj) {\n        return obj instanceof Duration;\n    }\n    function absRound(number) {\n        if (number < 0) {\n            return Math.round(-1 * number) * -1;\n        } else {\n            return Math.round(number);\n        }\n    }\n    // compare two arrays, return the number of differences\n    function compareArrays(array1, array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;\n        for(i = 0; i < len; i++){\n            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {\n                diffs++;\n            }\n        }\n        return diffs + lengthDiff;\n    }\n    // FORMATTING\n    function offset(token, separator) {\n        addFormatToken(token, 0, 0, function() {\n            var offset = this.utcOffset(), sign = \"+\";\n            if (offset < 0) {\n                offset = -offset;\n                sign = \"-\";\n            }\n            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);\n        });\n    }\n    offset(\"Z\", \":\");\n    offset(\"ZZ\", \"\");\n    // PARSING\n    addRegexToken(\"Z\", matchShortOffset);\n    addRegexToken(\"ZZ\", matchShortOffset);\n    addParseToken([\n        \"Z\",\n        \"ZZ\"\n    ], function(input, array, config) {\n        config._useUTC = true;\n        config._tzm = offsetFromString(matchShortOffset, input);\n    });\n    // HELPERS\n    // timezone chunker\n    // '+10:00' > ['10',  '00']\n    // '-1530'  > ['-15', '30']\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n    function offsetFromString(matcher, string) {\n        var matches = (string || \"\").match(matcher), chunk, parts, minutes;\n        if (matches === null) {\n            return null;\n        }\n        chunk = matches[matches.length - 1] || [];\n        parts = (chunk + \"\").match(chunkOffset) || [\n            \"-\",\n            0,\n            0\n        ];\n        minutes = +(parts[1] * 60) + toInt(parts[2]);\n        return minutes === 0 ? 0 : parts[0] === \"+\" ? minutes : -minutes;\n    }\n    // Return a moment from input, that is local/utc/zone equivalent to model.\n    function cloneWithOffset(input, model) {\n        var res, diff;\n        if (model._isUTC) {\n            res = model.clone();\n            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n            // Use low-level api, because this fn is low-level api.\n            res._d.setTime(res._d.valueOf() + diff);\n            hooks.updateOffset(res, false);\n            return res;\n        } else {\n            return createLocal(input).local();\n        }\n    }\n    function getDateOffset(m) {\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n        // https://github.com/moment/moment/pull/1871\n        return -Math.round(m._d.getTimezoneOffset());\n    }\n    // HOOKS\n    // This function will be called whenever a moment is mutated.\n    // It is intended to keep the offset in sync with the timezone.\n    hooks.updateOffset = function() {};\n    // MOMENTS\n    // keepLocalTime = true means only change the timezone, without\n    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n    // +0200, so we adjust the time as needed, to be valid.\n    //\n    // Keeping the time actually adds/subtracts (one hour)\n    // from the actual represented time. That is why we call updateOffset\n    // a second time. In case it wants us to change the offset again\n    // _changeInProgress == true case, then we have to adjust, because\n    // there is no such time in the given timezone.\n    function getSetOffset(input, keepLocalTime, keepMinutes) {\n        var offset = this._offset || 0, localAdjust;\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        if (input != null) {\n            if (typeof input === \"string\") {\n                input = offsetFromString(matchShortOffset, input);\n                if (input === null) {\n                    return this;\n                }\n            } else if (Math.abs(input) < 16 && !keepMinutes) {\n                input = input * 60;\n            }\n            if (!this._isUTC && keepLocalTime) {\n                localAdjust = getDateOffset(this);\n            }\n            this._offset = input;\n            this._isUTC = true;\n            if (localAdjust != null) {\n                this.add(localAdjust, \"m\");\n            }\n            if (offset !== input) {\n                if (!keepLocalTime || this._changeInProgress) {\n                    addSubtract(this, createDuration(input - offset, \"m\"), 1, false);\n                } else if (!this._changeInProgress) {\n                    this._changeInProgress = true;\n                    hooks.updateOffset(this, true);\n                    this._changeInProgress = null;\n                }\n            }\n            return this;\n        } else {\n            return this._isUTC ? offset : getDateOffset(this);\n        }\n    }\n    function getSetZone(input, keepLocalTime) {\n        if (input != null) {\n            if (typeof input !== \"string\") {\n                input = -input;\n            }\n            this.utcOffset(input, keepLocalTime);\n            return this;\n        } else {\n            return -this.utcOffset();\n        }\n    }\n    function setOffsetToUTC(keepLocalTime) {\n        return this.utcOffset(0, keepLocalTime);\n    }\n    function setOffsetToLocal(keepLocalTime) {\n        if (this._isUTC) {\n            this.utcOffset(0, keepLocalTime);\n            this._isUTC = false;\n            if (keepLocalTime) {\n                this.subtract(getDateOffset(this), \"m\");\n            }\n        }\n        return this;\n    }\n    function setOffsetToParsedOffset() {\n        if (this._tzm != null) {\n            this.utcOffset(this._tzm, false, true);\n        } else if (typeof this._i === \"string\") {\n            var tZone = offsetFromString(matchOffset, this._i);\n            if (tZone != null) {\n                this.utcOffset(tZone);\n            } else {\n                this.utcOffset(0, true);\n            }\n        }\n        return this;\n    }\n    function hasAlignedHourOffset(input) {\n        if (!this.isValid()) {\n            return false;\n        }\n        input = input ? createLocal(input).utcOffset() : 0;\n        return (this.utcOffset() - input) % 60 === 0;\n    }\n    function isDaylightSavingTime() {\n        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();\n    }\n    function isDaylightSavingTimeShifted() {\n        if (!isUndefined(this._isDSTShifted)) {\n            return this._isDSTShifted;\n        }\n        var c = {}, other;\n        copyConfig(c, this);\n        c = prepareConfig(c);\n        if (c._a) {\n            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;\n        } else {\n            this._isDSTShifted = false;\n        }\n        return this._isDSTShifted;\n    }\n    function isLocal() {\n        return this.isValid() ? !this._isUTC : false;\n    }\n    function isUtcOffset() {\n        return this.isValid() ? this._isUTC : false;\n    }\n    function isUtc() {\n        return this.isValid() ? this._isUTC && this._offset === 0 : false;\n    }\n    // ASP.NET json date format regex\n    var aspNetRegex = /^(-|\\+)?(?:(\\d*)[. ])?(\\d+):(\\d+)(?::(\\d+)(\\.\\d*)?)?$/, // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n    // and further modified to allow for strings containing both week and day\n    isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n    function createDuration(input, key) {\n        var duration = input, // matching against regexp is expensive, do it on demand\n        match = null, sign, ret, diffRes;\n        if (isDuration(input)) {\n            duration = {\n                ms: input._milliseconds,\n                d: input._days,\n                M: input._months\n            };\n        } else if (isNumber(input) || !isNaN(+input)) {\n            duration = {};\n            if (key) {\n                duration[key] = +input;\n            } else {\n                duration.milliseconds = +input;\n            }\n        } else if (match = aspNetRegex.exec(input)) {\n            sign = match[1] === \"-\" ? -1 : 1;\n            duration = {\n                y: 0,\n                d: toInt(match[DATE]) * sign,\n                h: toInt(match[HOUR]) * sign,\n                m: toInt(match[MINUTE]) * sign,\n                s: toInt(match[SECOND]) * sign,\n                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign\n            };\n        } else if (match = isoRegex.exec(input)) {\n            sign = match[1] === \"-\" ? -1 : 1;\n            duration = {\n                y: parseIso(match[2], sign),\n                M: parseIso(match[3], sign),\n                w: parseIso(match[4], sign),\n                d: parseIso(match[5], sign),\n                h: parseIso(match[6], sign),\n                m: parseIso(match[7], sign),\n                s: parseIso(match[8], sign)\n            };\n        } else if (duration == null) {\n            // checks for null or undefined\n            duration = {};\n        } else if (typeof duration === \"object\" && (\"from\" in duration || \"to\" in duration)) {\n            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n            duration = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M = diffRes.months;\n        }\n        ret = new Duration(duration);\n        if (isDuration(input) && hasOwnProp(input, \"_locale\")) {\n            ret._locale = input._locale;\n        }\n        if (isDuration(input) && hasOwnProp(input, \"_isValid\")) {\n            ret._isValid = input._isValid;\n        }\n        return ret;\n    }\n    createDuration.fn = Duration.prototype;\n    createDuration.invalid = createInvalid$1;\n    function parseIso(inp, sign) {\n        // We'd normally use ~~inp for this, but unfortunately it also\n        // converts floats to ints.\n        // inp may be undefined, so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(\",\", \".\"));\n        // apply sign while we're at it\n        return (isNaN(res) ? 0 : res) * sign;\n    }\n    function positiveMomentsDifference(base, other) {\n        var res = {};\n        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months, \"M\").isAfter(other)) {\n            --res.months;\n        }\n        res.milliseconds = +other - +base.clone().add(res.months, \"M\");\n        return res;\n    }\n    function momentsDifference(base, other) {\n        var res;\n        if (!(base.isValid() && other.isValid())) {\n            return {\n                milliseconds: 0,\n                months: 0\n            };\n        }\n        other = cloneWithOffset(other, base);\n        if (base.isBefore(other)) {\n            res = positiveMomentsDifference(base, other);\n        } else {\n            res = positiveMomentsDifference(other, base);\n            res.milliseconds = -res.milliseconds;\n            res.months = -res.months;\n        }\n        return res;\n    }\n    // TODO: remove 'name' arg after deprecation is removed\n    function createAdder(direction, name) {\n        return function(val, period) {\n            var dur, tmp;\n            //invert the arguments, but complain about it\n            if (period !== null && !isNaN(+period)) {\n                deprecateSimple(name, \"moment().\" + name + \"(period, number) is deprecated. Please use moment().\" + name + \"(number, period). \" + \"See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.\");\n                tmp = val;\n                val = period;\n                period = tmp;\n            }\n            dur = createDuration(val, period);\n            addSubtract(this, dur, direction);\n            return this;\n        };\n    }\n    function addSubtract(mom, duration, isAdding, updateOffset) {\n        var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months);\n        if (!mom.isValid()) {\n            // No op\n            return;\n        }\n        updateOffset = updateOffset == null ? true : updateOffset;\n        if (months) {\n            setMonth(mom, get(mom, \"Month\") + months * isAdding);\n        }\n        if (days) {\n            set$1(mom, \"Date\", get(mom, \"Date\") + days * isAdding);\n        }\n        if (milliseconds) {\n            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n        }\n        if (updateOffset) {\n            hooks.updateOffset(mom, days || months);\n        }\n    }\n    var add = createAdder(1, \"add\"), subtract = createAdder(-1, \"subtract\");\n    function isString(input) {\n        return typeof input === \"string\" || input instanceof String;\n    }\n    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined\n    function isMomentInput(input) {\n        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;\n    }\n    function isMomentInputObject(input) {\n        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [\n            \"years\",\n            \"year\",\n            \"y\",\n            \"months\",\n            \"month\",\n            \"M\",\n            \"days\",\n            \"day\",\n            \"d\",\n            \"dates\",\n            \"date\",\n            \"D\",\n            \"hours\",\n            \"hour\",\n            \"h\",\n            \"minutes\",\n            \"minute\",\n            \"m\",\n            \"seconds\",\n            \"second\",\n            \"s\",\n            \"milliseconds\",\n            \"millisecond\",\n            \"ms\"\n        ], i, property, propertyLen = properties.length;\n        for(i = 0; i < propertyLen; i += 1){\n            property = properties[i];\n            propertyTest = propertyTest || hasOwnProp(input, property);\n        }\n        return objectTest && propertyTest;\n    }\n    function isNumberOrStringArray(input) {\n        var arrayTest = isArray(input), dataTypeTest = false;\n        if (arrayTest) {\n            dataTypeTest = input.filter(function(item) {\n                return !isNumber(item) && isString(input);\n            }).length === 0;\n        }\n        return arrayTest && dataTypeTest;\n    }\n    function isCalendarSpec(input) {\n        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [\n            \"sameDay\",\n            \"nextDay\",\n            \"lastDay\",\n            \"nextWeek\",\n            \"lastWeek\",\n            \"sameElse\"\n        ], i, property;\n        for(i = 0; i < properties.length; i += 1){\n            property = properties[i];\n            propertyTest = propertyTest || hasOwnProp(input, property);\n        }\n        return objectTest && propertyTest;\n    }\n    function getCalendarFormat(myMoment, now) {\n        var diff = myMoment.diff(now, \"days\", true);\n        return diff < -6 ? \"sameElse\" : diff < -1 ? \"lastWeek\" : diff < 0 ? \"lastDay\" : diff < 1 ? \"sameDay\" : diff < 2 ? \"nextDay\" : diff < 7 ? \"nextWeek\" : \"sameElse\";\n    }\n    function calendar$1(time, formats) {\n        // Support for single parameter, formats only overload to the calendar function\n        if (arguments.length === 1) {\n            if (!arguments[0]) {\n                time = undefined;\n                formats = undefined;\n            } else if (isMomentInput(arguments[0])) {\n                time = arguments[0];\n                formats = undefined;\n            } else if (isCalendarSpec(arguments[0])) {\n                formats = arguments[0];\n                time = undefined;\n            }\n        }\n        // We want to compare the start of today, vs this.\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\n        var now = time || createLocal(), sod = cloneWithOffset(now, this).startOf(\"day\"), format = hooks.calendarFormat(this, sod) || \"sameElse\", output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n    }\n    function clone() {\n        return new Moment(this);\n    }\n    function isAfter(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || \"millisecond\";\n        if (units === \"millisecond\") {\n            return this.valueOf() > localInput.valueOf();\n        } else {\n            return localInput.valueOf() < this.clone().startOf(units).valueOf();\n        }\n    }\n    function isBefore(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || \"millisecond\";\n        if (units === \"millisecond\") {\n            return this.valueOf() < localInput.valueOf();\n        } else {\n            return this.clone().endOf(units).valueOf() < localInput.valueOf();\n        }\n    }\n    function isBetween(from, to, units, inclusivity) {\n        var localFrom = isMoment(from) ? from : createLocal(from), localTo = isMoment(to) ? to : createLocal(to);\n        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {\n            return false;\n        }\n        inclusivity = inclusivity || \"()\";\n        return (inclusivity[0] === \"(\" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === \")\" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));\n    }\n    function isSame(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input), inputMs;\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || \"millisecond\";\n        if (units === \"millisecond\") {\n            return this.valueOf() === localInput.valueOf();\n        } else {\n            inputMs = localInput.valueOf();\n            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n        }\n    }\n    function isSameOrAfter(input, units) {\n        return this.isSame(input, units) || this.isAfter(input, units);\n    }\n    function isSameOrBefore(input, units) {\n        return this.isSame(input, units) || this.isBefore(input, units);\n    }\n    function diff(input, units, asFloat) {\n        var that, zoneDelta, output;\n        if (!this.isValid()) {\n            return NaN;\n        }\n        that = cloneWithOffset(input, this);\n        if (!that.isValid()) {\n            return NaN;\n        }\n        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n        units = normalizeUnits(units);\n        switch(units){\n            case \"year\":\n                output = monthDiff(this, that) / 12;\n                break;\n            case \"month\":\n                output = monthDiff(this, that);\n                break;\n            case \"quarter\":\n                output = monthDiff(this, that) / 3;\n                break;\n            case \"second\":\n                output = (this - that) / 1e3;\n                break; // 1000\n            case \"minute\":\n                output = (this - that) / 6e4;\n                break; // 1000 * 60\n            case \"hour\":\n                output = (this - that) / 36e5;\n                break; // 1000 * 60 * 60\n            case \"day\":\n                output = (this - that - zoneDelta) / 864e5;\n                break; // 1000 * 60 * 60 * 24, negate dst\n            case \"week\":\n                output = (this - that - zoneDelta) / 6048e5;\n                break; // 1000 * 60 * 60 * 24 * 7, negate dst\n            default:\n                output = this - that;\n        }\n        return asFloat ? output : absFloor(output);\n    }\n    function monthDiff(a, b) {\n        if (a.date() < b.date()) {\n            // end-of-month calculations work correct when the start month has more\n            // days than the end month.\n            return -monthDiff(b, a);\n        }\n        // difference in months\n        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), // b is in (anchor - 1 month, anchor + 1 month)\n        anchor = a.clone().add(wholeMonthDiff, \"months\"), anchor2, adjust;\n        if (b - anchor < 0) {\n            anchor2 = a.clone().add(wholeMonthDiff - 1, \"months\");\n            // linear across the month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, \"months\");\n            // linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n        }\n        //check for negative zero, return zero if negative zero\n        return -(wholeMonthDiff + adjust) || 0;\n    }\n    hooks.defaultFormat = \"YYYY-MM-DDTHH:mm:ssZ\";\n    hooks.defaultFormatUtc = \"YYYY-MM-DDTHH:mm:ss[Z]\";\n    function toString() {\n        return this.clone().locale(\"en\").format(\"ddd MMM DD YYYY HH:mm:ss [GMT]ZZ\");\n    }\n    function toISOString(keepOffset) {\n        if (!this.isValid()) {\n            return null;\n        }\n        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;\n        if (m.year() < 0 || m.year() > 9999) {\n            return formatMoment(m, utc ? \"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]\" : \"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ\");\n        }\n        if (isFunction(Date.prototype.toISOString)) {\n            // native implementation is ~50x faster, use it when we can\n            if (utc) {\n                return this.toDate().toISOString();\n            } else {\n                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace(\"Z\", formatMoment(m, \"Z\"));\n            }\n        }\n        return formatMoment(m, utc ? \"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]\" : \"YYYY-MM-DD[T]HH:mm:ss.SSSZ\");\n    }\n    /**\n     * Return a human readable representation of a moment that can\n     * also be evaluated to get a new moment which is the same\n     *\n     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n     */ function inspect() {\n        if (!this.isValid()) {\n            return \"moment.invalid(/* \" + this._i + \" */)\";\n        }\n        var func = \"moment\", zone = \"\", prefix, year, datetime, suffix;\n        if (!this.isLocal()) {\n            func = this.utcOffset() === 0 ? \"moment.utc\" : \"moment.parseZone\";\n            zone = \"Z\";\n        }\n        prefix = \"[\" + func + '(\"]';\n        year = 0 <= this.year() && this.year() <= 9999 ? \"YYYY\" : \"YYYYYY\";\n        datetime = \"-MM-DD[T]HH:mm:ss.SSS\";\n        suffix = zone + '[\")]';\n        return this.format(prefix + year + datetime + suffix);\n    }\n    function format(inputString) {\n        if (!inputString) {\n            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n        }\n        var output = formatMoment(this, inputString);\n        return this.localeData().postformat(output);\n    }\n    function from(time, withoutSuffix) {\n        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {\n            return createDuration({\n                to: this,\n                from: time\n            }).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n    function fromNow(withoutSuffix) {\n        return this.from(createLocal(), withoutSuffix);\n    }\n    function to(time, withoutSuffix) {\n        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {\n            return createDuration({\n                from: this,\n                to: time\n            }).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n    function toNow(withoutSuffix) {\n        return this.to(createLocal(), withoutSuffix);\n    }\n    // If passed a locale key, it will set the locale for this\n    // instance.  Otherwise, it will return the locale configuration\n    // variables for this instance.\n    function locale(key) {\n        var newLocaleData;\n        if (key === undefined) {\n            return this._locale._abbr;\n        } else {\n            newLocaleData = getLocale(key);\n            if (newLocaleData != null) {\n                this._locale = newLocaleData;\n            }\n            return this;\n        }\n    }\n    var lang = deprecate(\"moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.\", function(key) {\n        if (key === undefined) {\n            return this.localeData();\n        } else {\n            return this.locale(key);\n        }\n    });\n    function localeData() {\n        return this._locale;\n    }\n    var MS_PER_SECOND = 1000, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;\n    // actual modulo - handles negative numbers (for dates before 1970):\n    function mod$1(dividend, divisor) {\n        return (dividend % divisor + divisor) % divisor;\n    }\n    function localStartOfDate(y, m, d) {\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            return new Date(y + 400, m, d) - MS_PER_400_YEARS;\n        } else {\n            return new Date(y, m, d).valueOf();\n        }\n    }\n    function utcStartOfDate(y, m, d) {\n        // Date.UTC remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;\n        } else {\n            return Date.UTC(y, m, d);\n        }\n    }\n    function startOf(units) {\n        var time, startOfDate;\n        units = normalizeUnits(units);\n        if (units === undefined || units === \"millisecond\" || !this.isValid()) {\n            return this;\n        }\n        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n        switch(units){\n            case \"year\":\n                time = startOfDate(this.year(), 0, 1);\n                break;\n            case \"quarter\":\n                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);\n                break;\n            case \"month\":\n                time = startOfDate(this.year(), this.month(), 1);\n                break;\n            case \"week\":\n                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());\n                break;\n            case \"isoWeek\":\n                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));\n                break;\n            case \"day\":\n            case \"date\":\n                time = startOfDate(this.year(), this.month(), this.date());\n                break;\n            case \"hour\":\n                time = this._d.valueOf();\n                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);\n                break;\n            case \"minute\":\n                time = this._d.valueOf();\n                time -= mod$1(time, MS_PER_MINUTE);\n                break;\n            case \"second\":\n                time = this._d.valueOf();\n                time -= mod$1(time, MS_PER_SECOND);\n                break;\n        }\n        this._d.setTime(time);\n        hooks.updateOffset(this, true);\n        return this;\n    }\n    function endOf(units) {\n        var time, startOfDate;\n        units = normalizeUnits(units);\n        if (units === undefined || units === \"millisecond\" || !this.isValid()) {\n            return this;\n        }\n        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n        switch(units){\n            case \"year\":\n                time = startOfDate(this.year() + 1, 0, 1) - 1;\n                break;\n            case \"quarter\":\n                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;\n                break;\n            case \"month\":\n                time = startOfDate(this.year(), this.month() + 1, 1) - 1;\n                break;\n            case \"week\":\n                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;\n                break;\n            case \"isoWeek\":\n                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;\n                break;\n            case \"day\":\n            case \"date\":\n                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;\n                break;\n            case \"hour\":\n                time = this._d.valueOf();\n                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;\n                break;\n            case \"minute\":\n                time = this._d.valueOf();\n                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;\n                break;\n            case \"second\":\n                time = this._d.valueOf();\n                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;\n                break;\n        }\n        this._d.setTime(time);\n        hooks.updateOffset(this, true);\n        return this;\n    }\n    function valueOf() {\n        return this._d.valueOf() - (this._offset || 0) * 60000;\n    }\n    function unix() {\n        return Math.floor(this.valueOf() / 1000);\n    }\n    function toDate() {\n        return new Date(this.valueOf());\n    }\n    function toArray() {\n        var m = this;\n        return [\n            m.year(),\n            m.month(),\n            m.date(),\n            m.hour(),\n            m.minute(),\n            m.second(),\n            m.millisecond()\n        ];\n    }\n    function toObject() {\n        var m = this;\n        return {\n            years: m.year(),\n            months: m.month(),\n            date: m.date(),\n            hours: m.hours(),\n            minutes: m.minutes(),\n            seconds: m.seconds(),\n            milliseconds: m.milliseconds()\n        };\n    }\n    function toJSON() {\n        // new Date(NaN).toJSON() === null\n        return this.isValid() ? this.toISOString() : null;\n    }\n    function isValid$2() {\n        return isValid(this);\n    }\n    function parsingFlags() {\n        return extend({}, getParsingFlags(this));\n    }\n    function invalidAt() {\n        return getParsingFlags(this).overflow;\n    }\n    function creationData() {\n        return {\n            input: this._i,\n            format: this._f,\n            locale: this._locale,\n            isUTC: this._isUTC,\n            strict: this._strict\n        };\n    }\n    addFormatToken(\"N\", 0, 0, \"eraAbbr\");\n    addFormatToken(\"NN\", 0, 0, \"eraAbbr\");\n    addFormatToken(\"NNN\", 0, 0, \"eraAbbr\");\n    addFormatToken(\"NNNN\", 0, 0, \"eraName\");\n    addFormatToken(\"NNNNN\", 0, 0, \"eraNarrow\");\n    addFormatToken(\"y\", [\n        \"y\",\n        1\n    ], \"yo\", \"eraYear\");\n    addFormatToken(\"y\", [\n        \"yy\",\n        2\n    ], 0, \"eraYear\");\n    addFormatToken(\"y\", [\n        \"yyy\",\n        3\n    ], 0, \"eraYear\");\n    addFormatToken(\"y\", [\n        \"yyyy\",\n        4\n    ], 0, \"eraYear\");\n    addRegexToken(\"N\", matchEraAbbr);\n    addRegexToken(\"NN\", matchEraAbbr);\n    addRegexToken(\"NNN\", matchEraAbbr);\n    addRegexToken(\"NNNN\", matchEraName);\n    addRegexToken(\"NNNNN\", matchEraNarrow);\n    addParseToken([\n        \"N\",\n        \"NN\",\n        \"NNN\",\n        \"NNNN\",\n        \"NNNNN\"\n    ], function(input, array, config, token) {\n        var era = config._locale.erasParse(input, token, config._strict);\n        if (era) {\n            getParsingFlags(config).era = era;\n        } else {\n            getParsingFlags(config).invalidEra = input;\n        }\n    });\n    addRegexToken(\"y\", matchUnsigned);\n    addRegexToken(\"yy\", matchUnsigned);\n    addRegexToken(\"yyy\", matchUnsigned);\n    addRegexToken(\"yyyy\", matchUnsigned);\n    addRegexToken(\"yo\", matchEraYearOrdinal);\n    addParseToken([\n        \"y\",\n        \"yy\",\n        \"yyy\",\n        \"yyyy\"\n    ], YEAR);\n    addParseToken([\n        \"yo\"\n    ], function(input, array, config, token) {\n        var match;\n        if (config._locale._eraYearOrdinalRegex) {\n            match = input.match(config._locale._eraYearOrdinalRegex);\n        }\n        if (config._locale.eraYearOrdinalParse) {\n            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);\n        } else {\n            array[YEAR] = parseInt(input, 10);\n        }\n    });\n    function localeEras(m, format) {\n        var i, l, date, eras = this._eras || getLocale(\"en\")._eras;\n        for(i = 0, l = eras.length; i < l; ++i){\n            switch(typeof eras[i].since){\n                case \"string\":\n                    // truncate time\n                    date = hooks(eras[i].since).startOf(\"day\");\n                    eras[i].since = date.valueOf();\n                    break;\n            }\n            switch(typeof eras[i].until){\n                case \"undefined\":\n                    eras[i].until = +Infinity;\n                    break;\n                case \"string\":\n                    // truncate time\n                    date = hooks(eras[i].until).startOf(\"day\").valueOf();\n                    eras[i].until = date.valueOf();\n                    break;\n            }\n        }\n        return eras;\n    }\n    function localeErasParse(eraName, format, strict) {\n        var i, l, eras = this.eras(), name, abbr, narrow;\n        eraName = eraName.toUpperCase();\n        for(i = 0, l = eras.length; i < l; ++i){\n            name = eras[i].name.toUpperCase();\n            abbr = eras[i].abbr.toUpperCase();\n            narrow = eras[i].narrow.toUpperCase();\n            if (strict) {\n                switch(format){\n                    case \"N\":\n                    case \"NN\":\n                    case \"NNN\":\n                        if (abbr === eraName) {\n                            return eras[i];\n                        }\n                        break;\n                    case \"NNNN\":\n                        if (name === eraName) {\n                            return eras[i];\n                        }\n                        break;\n                    case \"NNNNN\":\n                        if (narrow === eraName) {\n                            return eras[i];\n                        }\n                        break;\n                }\n            } else if ([\n                name,\n                abbr,\n                narrow\n            ].indexOf(eraName) >= 0) {\n                return eras[i];\n            }\n        }\n    }\n    function localeErasConvertYear(era, year) {\n        var dir = era.since <= era.until ? +1 : -1;\n        if (year === undefined) {\n            return hooks(era.since).year();\n        } else {\n            return hooks(era.since).year() + (year - era.offset) * dir;\n        }\n    }\n    function getEraName() {\n        var i, l, val, eras = this.localeData().eras();\n        for(i = 0, l = eras.length; i < l; ++i){\n            // truncate time\n            val = this.clone().startOf(\"day\").valueOf();\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].name;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].name;\n            }\n        }\n        return \"\";\n    }\n    function getEraNarrow() {\n        var i, l, val, eras = this.localeData().eras();\n        for(i = 0, l = eras.length; i < l; ++i){\n            // truncate time\n            val = this.clone().startOf(\"day\").valueOf();\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].narrow;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].narrow;\n            }\n        }\n        return \"\";\n    }\n    function getEraAbbr() {\n        var i, l, val, eras = this.localeData().eras();\n        for(i = 0, l = eras.length; i < l; ++i){\n            // truncate time\n            val = this.clone().startOf(\"day\").valueOf();\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].abbr;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].abbr;\n            }\n        }\n        return \"\";\n    }\n    function getEraYear() {\n        var i, l, dir, val, eras = this.localeData().eras();\n        for(i = 0, l = eras.length; i < l; ++i){\n            dir = eras[i].since <= eras[i].until ? +1 : -1;\n            // truncate time\n            val = this.clone().startOf(\"day\").valueOf();\n            if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {\n                return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;\n            }\n        }\n        return this.year();\n    }\n    function erasNameRegex(isStrict) {\n        if (!hasOwnProp(this, \"_erasNameRegex\")) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasNameRegex : this._erasRegex;\n    }\n    function erasAbbrRegex(isStrict) {\n        if (!hasOwnProp(this, \"_erasAbbrRegex\")) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasAbbrRegex : this._erasRegex;\n    }\n    function erasNarrowRegex(isStrict) {\n        if (!hasOwnProp(this, \"_erasNarrowRegex\")) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasNarrowRegex : this._erasRegex;\n    }\n    function matchEraAbbr(isStrict, locale) {\n        return locale.erasAbbrRegex(isStrict);\n    }\n    function matchEraName(isStrict, locale) {\n        return locale.erasNameRegex(isStrict);\n    }\n    function matchEraNarrow(isStrict, locale) {\n        return locale.erasNarrowRegex(isStrict);\n    }\n    function matchEraYearOrdinal(isStrict, locale) {\n        return locale._eraYearOrdinalRegex || matchUnsigned;\n    }\n    function computeErasParse() {\n        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();\n        for(i = 0, l = eras.length; i < l; ++i){\n            namePieces.push(regexEscape(eras[i].name));\n            abbrPieces.push(regexEscape(eras[i].abbr));\n            narrowPieces.push(regexEscape(eras[i].narrow));\n            mixedPieces.push(regexEscape(eras[i].name));\n            mixedPieces.push(regexEscape(eras[i].abbr));\n            mixedPieces.push(regexEscape(eras[i].narrow));\n        }\n        this._erasRegex = new RegExp(\"^(\" + mixedPieces.join(\"|\") + \")\", \"i\");\n        this._erasNameRegex = new RegExp(\"^(\" + namePieces.join(\"|\") + \")\", \"i\");\n        this._erasAbbrRegex = new RegExp(\"^(\" + abbrPieces.join(\"|\") + \")\", \"i\");\n        this._erasNarrowRegex = new RegExp(\"^(\" + narrowPieces.join(\"|\") + \")\", \"i\");\n    }\n    // FORMATTING\n    addFormatToken(0, [\n        \"gg\",\n        2\n    ], 0, function() {\n        return this.weekYear() % 100;\n    });\n    addFormatToken(0, [\n        \"GG\",\n        2\n    ], 0, function() {\n        return this.isoWeekYear() % 100;\n    });\n    function addWeekYearFormatToken(token, getter) {\n        addFormatToken(0, [\n            token,\n            token.length\n        ], 0, getter);\n    }\n    addWeekYearFormatToken(\"gggg\", \"weekYear\");\n    addWeekYearFormatToken(\"ggggg\", \"weekYear\");\n    addWeekYearFormatToken(\"GGGG\", \"isoWeekYear\");\n    addWeekYearFormatToken(\"GGGGG\", \"isoWeekYear\");\n    // ALIASES\n    addUnitAlias(\"weekYear\", \"gg\");\n    addUnitAlias(\"isoWeekYear\", \"GG\");\n    // PRIORITY\n    addUnitPriority(\"weekYear\", 1);\n    addUnitPriority(\"isoWeekYear\", 1);\n    // PARSING\n    addRegexToken(\"G\", matchSigned);\n    addRegexToken(\"g\", matchSigned);\n    addRegexToken(\"GG\", match1to2, match2);\n    addRegexToken(\"gg\", match1to2, match2);\n    addRegexToken(\"GGGG\", match1to4, match4);\n    addRegexToken(\"gggg\", match1to4, match4);\n    addRegexToken(\"GGGGG\", match1to6, match6);\n    addRegexToken(\"ggggg\", match1to6, match6);\n    addWeekParseToken([\n        \"gggg\",\n        \"ggggg\",\n        \"GGGG\",\n        \"GGGGG\"\n    ], function(input, week, config, token) {\n        week[token.substr(0, 2)] = toInt(input);\n    });\n    addWeekParseToken([\n        \"gg\",\n        \"GG\"\n    ], function(input, week, config, token) {\n        week[token] = hooks.parseTwoDigitYear(input);\n    });\n    // MOMENTS\n    function getSetWeekYear(input) {\n        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);\n    }\n    function getSetISOWeekYear(input) {\n        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);\n    }\n    function getISOWeeksInYear() {\n        return weeksInYear(this.year(), 1, 4);\n    }\n    function getISOWeeksInISOWeekYear() {\n        return weeksInYear(this.isoWeekYear(), 1, 4);\n    }\n    function getWeeksInYear() {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n    }\n    function getWeeksInWeekYear() {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);\n    }\n    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n        var weeksTarget;\n        if (input == null) {\n            return weekOfYear(this, dow, doy).year;\n        } else {\n            weeksTarget = weeksInYear(input, dow, doy);\n            if (week > weeksTarget) {\n                week = weeksTarget;\n            }\n            return setWeekAll.call(this, input, week, weekday, dow, doy);\n        }\n    }\n    function setWeekAll(weekYear, week, weekday, dow, doy) {\n        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n        this.year(date.getUTCFullYear());\n        this.month(date.getUTCMonth());\n        this.date(date.getUTCDate());\n        return this;\n    }\n    // FORMATTING\n    addFormatToken(\"Q\", 0, \"Qo\", \"quarter\");\n    // ALIASES\n    addUnitAlias(\"quarter\", \"Q\");\n    // PRIORITY\n    addUnitPriority(\"quarter\", 7);\n    // PARSING\n    addRegexToken(\"Q\", match1);\n    addParseToken(\"Q\", function(input, array) {\n        array[MONTH] = (toInt(input) - 1) * 3;\n    });\n    // MOMENTS\n    function getSetQuarter(input) {\n        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n    }\n    // FORMATTING\n    addFormatToken(\"D\", [\n        \"DD\",\n        2\n    ], \"Do\", \"date\");\n    // ALIASES\n    addUnitAlias(\"date\", \"D\");\n    // PRIORITY\n    addUnitPriority(\"date\", 9);\n    // PARSING\n    addRegexToken(\"D\", match1to2);\n    addRegexToken(\"DD\", match1to2, match2);\n    addRegexToken(\"Do\", function(isStrict, locale) {\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;\n    });\n    addParseToken([\n        \"D\",\n        \"DD\"\n    ], DATE);\n    addParseToken(\"Do\", function(input, array) {\n        array[DATE] = toInt(input.match(match1to2)[0]);\n    });\n    // MOMENTS\n    var getSetDayOfMonth = makeGetSet(\"Date\", true);\n    // FORMATTING\n    addFormatToken(\"DDD\", [\n        \"DDDD\",\n        3\n    ], \"DDDo\", \"dayOfYear\");\n    // ALIASES\n    addUnitAlias(\"dayOfYear\", \"DDD\");\n    // PRIORITY\n    addUnitPriority(\"dayOfYear\", 4);\n    // PARSING\n    addRegexToken(\"DDD\", match1to3);\n    addRegexToken(\"DDDD\", match3);\n    addParseToken([\n        \"DDD\",\n        \"DDDD\"\n    ], function(input, array, config) {\n        config._dayOfYear = toInt(input);\n    });\n    // HELPERS\n    // MOMENTS\n    function getSetDayOfYear(input) {\n        var dayOfYear = Math.round((this.clone().startOf(\"day\") - this.clone().startOf(\"year\")) / 864e5) + 1;\n        return input == null ? dayOfYear : this.add(input - dayOfYear, \"d\");\n    }\n    // FORMATTING\n    addFormatToken(\"m\", [\n        \"mm\",\n        2\n    ], 0, \"minute\");\n    // ALIASES\n    addUnitAlias(\"minute\", \"m\");\n    // PRIORITY\n    addUnitPriority(\"minute\", 14);\n    // PARSING\n    addRegexToken(\"m\", match1to2);\n    addRegexToken(\"mm\", match1to2, match2);\n    addParseToken([\n        \"m\",\n        \"mm\"\n    ], MINUTE);\n    // MOMENTS\n    var getSetMinute = makeGetSet(\"Minutes\", false);\n    // FORMATTING\n    addFormatToken(\"s\", [\n        \"ss\",\n        2\n    ], 0, \"second\");\n    // ALIASES\n    addUnitAlias(\"second\", \"s\");\n    // PRIORITY\n    addUnitPriority(\"second\", 15);\n    // PARSING\n    addRegexToken(\"s\", match1to2);\n    addRegexToken(\"ss\", match1to2, match2);\n    addParseToken([\n        \"s\",\n        \"ss\"\n    ], SECOND);\n    // MOMENTS\n    var getSetSecond = makeGetSet(\"Seconds\", false);\n    // FORMATTING\n    addFormatToken(\"S\", 0, 0, function() {\n        return ~~(this.millisecond() / 100);\n    });\n    addFormatToken(0, [\n        \"SS\",\n        2\n    ], 0, function() {\n        return ~~(this.millisecond() / 10);\n    });\n    addFormatToken(0, [\n        \"SSS\",\n        3\n    ], 0, \"millisecond\");\n    addFormatToken(0, [\n        \"SSSS\",\n        4\n    ], 0, function() {\n        return this.millisecond() * 10;\n    });\n    addFormatToken(0, [\n        \"SSSSS\",\n        5\n    ], 0, function() {\n        return this.millisecond() * 100;\n    });\n    addFormatToken(0, [\n        \"SSSSSS\",\n        6\n    ], 0, function() {\n        return this.millisecond() * 1000;\n    });\n    addFormatToken(0, [\n        \"SSSSSSS\",\n        7\n    ], 0, function() {\n        return this.millisecond() * 10000;\n    });\n    addFormatToken(0, [\n        \"SSSSSSSS\",\n        8\n    ], 0, function() {\n        return this.millisecond() * 100000;\n    });\n    addFormatToken(0, [\n        \"SSSSSSSSS\",\n        9\n    ], 0, function() {\n        return this.millisecond() * 1000000;\n    });\n    // ALIASES\n    addUnitAlias(\"millisecond\", \"ms\");\n    // PRIORITY\n    addUnitPriority(\"millisecond\", 16);\n    // PARSING\n    addRegexToken(\"S\", match1to3, match1);\n    addRegexToken(\"SS\", match1to3, match2);\n    addRegexToken(\"SSS\", match1to3, match3);\n    var token, getSetMillisecond;\n    for(token = \"SSSS\"; token.length <= 9; token += \"S\"){\n        addRegexToken(token, matchUnsigned);\n    }\n    function parseMs(input, array) {\n        array[MILLISECOND] = toInt((\"0.\" + input) * 1000);\n    }\n    for(token = \"S\"; token.length <= 9; token += \"S\"){\n        addParseToken(token, parseMs);\n    }\n    getSetMillisecond = makeGetSet(\"Milliseconds\", false);\n    // FORMATTING\n    addFormatToken(\"z\", 0, 0, \"zoneAbbr\");\n    addFormatToken(\"zz\", 0, 0, \"zoneName\");\n    // MOMENTS\n    function getZoneAbbr() {\n        return this._isUTC ? \"UTC\" : \"\";\n    }\n    function getZoneName() {\n        return this._isUTC ? \"Coordinated Universal Time\" : \"\";\n    }\n    var proto = Moment.prototype;\n    proto.add = add;\n    proto.calendar = calendar$1;\n    proto.clone = clone;\n    proto.diff = diff;\n    proto.endOf = endOf;\n    proto.format = format;\n    proto.from = from;\n    proto.fromNow = fromNow;\n    proto.to = to;\n    proto.toNow = toNow;\n    proto.get = stringGet;\n    proto.invalidAt = invalidAt;\n    proto.isAfter = isAfter;\n    proto.isBefore = isBefore;\n    proto.isBetween = isBetween;\n    proto.isSame = isSame;\n    proto.isSameOrAfter = isSameOrAfter;\n    proto.isSameOrBefore = isSameOrBefore;\n    proto.isValid = isValid$2;\n    proto.lang = lang;\n    proto.locale = locale;\n    proto.localeData = localeData;\n    proto.max = prototypeMax;\n    proto.min = prototypeMin;\n    proto.parsingFlags = parsingFlags;\n    proto.set = stringSet;\n    proto.startOf = startOf;\n    proto.subtract = subtract;\n    proto.toArray = toArray;\n    proto.toObject = toObject;\n    proto.toDate = toDate;\n    proto.toISOString = toISOString;\n    proto.inspect = inspect;\n    if (typeof Symbol !== \"undefined\" && Symbol.for != null) {\n        proto[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n            return \"Moment<\" + this.format() + \">\";\n        };\n    }\n    proto.toJSON = toJSON;\n    proto.toString = toString;\n    proto.unix = unix;\n    proto.valueOf = valueOf;\n    proto.creationData = creationData;\n    proto.eraName = getEraName;\n    proto.eraNarrow = getEraNarrow;\n    proto.eraAbbr = getEraAbbr;\n    proto.eraYear = getEraYear;\n    proto.year = getSetYear;\n    proto.isLeapYear = getIsLeapYear;\n    proto.weekYear = getSetWeekYear;\n    proto.isoWeekYear = getSetISOWeekYear;\n    proto.quarter = proto.quarters = getSetQuarter;\n    proto.month = getSetMonth;\n    proto.daysInMonth = getDaysInMonth;\n    proto.week = proto.weeks = getSetWeek;\n    proto.isoWeek = proto.isoWeeks = getSetISOWeek;\n    proto.weeksInYear = getWeeksInYear;\n    proto.weeksInWeekYear = getWeeksInWeekYear;\n    proto.isoWeeksInYear = getISOWeeksInYear;\n    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;\n    proto.date = getSetDayOfMonth;\n    proto.day = proto.days = getSetDayOfWeek;\n    proto.weekday = getSetLocaleDayOfWeek;\n    proto.isoWeekday = getSetISODayOfWeek;\n    proto.dayOfYear = getSetDayOfYear;\n    proto.hour = proto.hours = getSetHour;\n    proto.minute = proto.minutes = getSetMinute;\n    proto.second = proto.seconds = getSetSecond;\n    proto.millisecond = proto.milliseconds = getSetMillisecond;\n    proto.utcOffset = getSetOffset;\n    proto.utc = setOffsetToUTC;\n    proto.local = setOffsetToLocal;\n    proto.parseZone = setOffsetToParsedOffset;\n    proto.hasAlignedHourOffset = hasAlignedHourOffset;\n    proto.isDST = isDaylightSavingTime;\n    proto.isLocal = isLocal;\n    proto.isUtcOffset = isUtcOffset;\n    proto.isUtc = isUtc;\n    proto.isUTC = isUtc;\n    proto.zoneAbbr = getZoneAbbr;\n    proto.zoneName = getZoneName;\n    proto.dates = deprecate(\"dates accessor is deprecated. Use date instead.\", getSetDayOfMonth);\n    proto.months = deprecate(\"months accessor is deprecated. Use month instead\", getSetMonth);\n    proto.years = deprecate(\"years accessor is deprecated. Use year instead\", getSetYear);\n    proto.zone = deprecate(\"moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/\", getSetZone);\n    proto.isDSTShifted = deprecate(\"isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information\", isDaylightSavingTimeShifted);\n    function createUnix(input) {\n        return createLocal(input * 1000);\n    }\n    function createInZone() {\n        return createLocal.apply(null, arguments).parseZone();\n    }\n    function preParsePostFormat(string) {\n        return string;\n    }\n    var proto$1 = Locale.prototype;\n    proto$1.calendar = calendar;\n    proto$1.longDateFormat = longDateFormat;\n    proto$1.invalidDate = invalidDate;\n    proto$1.ordinal = ordinal;\n    proto$1.preparse = preParsePostFormat;\n    proto$1.postformat = preParsePostFormat;\n    proto$1.relativeTime = relativeTime;\n    proto$1.pastFuture = pastFuture;\n    proto$1.set = set;\n    proto$1.eras = localeEras;\n    proto$1.erasParse = localeErasParse;\n    proto$1.erasConvertYear = localeErasConvertYear;\n    proto$1.erasAbbrRegex = erasAbbrRegex;\n    proto$1.erasNameRegex = erasNameRegex;\n    proto$1.erasNarrowRegex = erasNarrowRegex;\n    proto$1.months = localeMonths;\n    proto$1.monthsShort = localeMonthsShort;\n    proto$1.monthsParse = localeMonthsParse;\n    proto$1.monthsRegex = monthsRegex;\n    proto$1.monthsShortRegex = monthsShortRegex;\n    proto$1.week = localeWeek;\n    proto$1.firstDayOfYear = localeFirstDayOfYear;\n    proto$1.firstDayOfWeek = localeFirstDayOfWeek;\n    proto$1.weekdays = localeWeekdays;\n    proto$1.weekdaysMin = localeWeekdaysMin;\n    proto$1.weekdaysShort = localeWeekdaysShort;\n    proto$1.weekdaysParse = localeWeekdaysParse;\n    proto$1.weekdaysRegex = weekdaysRegex;\n    proto$1.weekdaysShortRegex = weekdaysShortRegex;\n    proto$1.weekdaysMinRegex = weekdaysMinRegex;\n    proto$1.isPM = localeIsPM;\n    proto$1.meridiem = localeMeridiem;\n    function get$1(format, index, field, setter) {\n        var locale = getLocale(), utc = createUTC().set(setter, index);\n        return locale[field](utc, format);\n    }\n    function listMonthsImpl(format, index, field) {\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n        format = format || \"\";\n        if (index != null) {\n            return get$1(format, index, field, \"month\");\n        }\n        var i, out = [];\n        for(i = 0; i < 12; i++){\n            out[i] = get$1(format, i, field, \"month\");\n        }\n        return out;\n    }\n    // ()\n    // (5)\n    // (fmt, 5)\n    // (fmt)\n    // (true)\n    // (true, 5)\n    // (true, fmt, 5)\n    // (true, fmt)\n    function listWeekdaysImpl(localeSorted, format, index, field) {\n        if (typeof localeSorted === \"boolean\") {\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n            format = format || \"\";\n        } else {\n            format = localeSorted;\n            index = format;\n            localeSorted = false;\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n            format = format || \"\";\n        }\n        var locale = getLocale(), shift = localeSorted ? locale._week.dow : 0, i, out = [];\n        if (index != null) {\n            return get$1(format, (index + shift) % 7, field, \"day\");\n        }\n        for(i = 0; i < 7; i++){\n            out[i] = get$1(format, (i + shift) % 7, field, \"day\");\n        }\n        return out;\n    }\n    function listMonths(format, index) {\n        return listMonthsImpl(format, index, \"months\");\n    }\n    function listMonthsShort(format, index) {\n        return listMonthsImpl(format, index, \"monthsShort\");\n    }\n    function listWeekdays(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, \"weekdays\");\n    }\n    function listWeekdaysShort(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, \"weekdaysShort\");\n    }\n    function listWeekdaysMin(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, \"weekdaysMin\");\n    }\n    getSetGlobalLocale(\"en\", {\n        eras: [\n            {\n                since: \"0001-01-01\",\n                until: +Infinity,\n                offset: 1,\n                name: \"Anno Domini\",\n                narrow: \"AD\",\n                abbr: \"AD\"\n            },\n            {\n                since: \"0000-12-31\",\n                until: -Infinity,\n                offset: 1,\n                name: \"Before Christ\",\n                narrow: \"BC\",\n                abbr: \"BC\"\n            }\n        ],\n        dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal: function(number) {\n            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? \"th\" : b === 1 ? \"st\" : b === 2 ? \"nd\" : b === 3 ? \"rd\" : \"th\";\n            return number + output;\n        }\n    });\n    // Side effect imports\n    hooks.lang = deprecate(\"moment.lang is deprecated. Use moment.locale instead.\", getSetGlobalLocale);\n    hooks.langData = deprecate(\"moment.langData is deprecated. Use moment.localeData instead.\", getLocale);\n    var mathAbs = Math.abs;\n    function abs() {\n        var data = this._data;\n        this._milliseconds = mathAbs(this._milliseconds);\n        this._days = mathAbs(this._days);\n        this._months = mathAbs(this._months);\n        data.milliseconds = mathAbs(data.milliseconds);\n        data.seconds = mathAbs(data.seconds);\n        data.minutes = mathAbs(data.minutes);\n        data.hours = mathAbs(data.hours);\n        data.months = mathAbs(data.months);\n        data.years = mathAbs(data.years);\n        return this;\n    }\n    function addSubtract$1(duration, input, value, direction) {\n        var other = createDuration(input, value);\n        duration._milliseconds += direction * other._milliseconds;\n        duration._days += direction * other._days;\n        duration._months += direction * other._months;\n        return duration._bubble();\n    }\n    // supports only 2.0-style add(1, 's') or add(duration)\n    function add$1(input, value) {\n        return addSubtract$1(this, input, value, 1);\n    }\n    // supports only 2.0-style subtract(1, 's') or subtract(duration)\n    function subtract$1(input, value) {\n        return addSubtract$1(this, input, value, -1);\n    }\n    function absCeil(number) {\n        if (number < 0) {\n            return Math.floor(number);\n        } else {\n            return Math.ceil(number);\n        }\n    }\n    function bubble() {\n        var milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, seconds, minutes, hours, years, monthsFromDays;\n        // if we have a mix of positive and negative values, bubble down first\n        // check: https://github.com/moment/moment/issues/2166\n        if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n            days = 0;\n            months = 0;\n        }\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n        seconds = absFloor(milliseconds / 1000);\n        data.seconds = seconds % 60;\n        minutes = absFloor(seconds / 60);\n        data.minutes = minutes % 60;\n        hours = absFloor(minutes / 60);\n        data.hours = hours % 24;\n        days += absFloor(hours / 24);\n        // convert days to months\n        monthsFromDays = absFloor(daysToMonths(days));\n        months += monthsFromDays;\n        days -= absCeil(monthsToDays(monthsFromDays));\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n        data.days = days;\n        data.months = months;\n        data.years = years;\n        return this;\n    }\n    function daysToMonths(days) {\n        // 400 years have 146097 days (taking into account leap year rules)\n        // 400 years have 12 months === 4800\n        return days * 4800 / 146097;\n    }\n    function monthsToDays(months) {\n        // the reverse of daysToMonths\n        return months * 146097 / 4800;\n    }\n    function as(units) {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        var days, months, milliseconds = this._milliseconds;\n        units = normalizeUnits(units);\n        if (units === \"month\" || units === \"quarter\" || units === \"year\") {\n            days = this._days + milliseconds / 864e5;\n            months = this._months + daysToMonths(days);\n            switch(units){\n                case \"month\":\n                    return months;\n                case \"quarter\":\n                    return months / 3;\n                case \"year\":\n                    return months / 12;\n            }\n        } else {\n            // handle milliseconds separately because of floating point math errors (issue #1867)\n            days = this._days + Math.round(monthsToDays(this._months));\n            switch(units){\n                case \"week\":\n                    return days / 7 + milliseconds / 6048e5;\n                case \"day\":\n                    return days + milliseconds / 864e5;\n                case \"hour\":\n                    return days * 24 + milliseconds / 36e5;\n                case \"minute\":\n                    return days * 1440 + milliseconds / 6e4;\n                case \"second\":\n                    return days * 86400 + milliseconds / 1000;\n                // Math.floor prevents floating point math errors here\n                case \"millisecond\":\n                    return Math.floor(days * 864e5) + milliseconds;\n                default:\n                    throw new Error(\"Unknown unit \" + units);\n            }\n        }\n    }\n    // TODO: Use this.as('ms')?\n    function valueOf$1() {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;\n    }\n    function makeAs(alias) {\n        return function() {\n            return this.as(alias);\n        };\n    }\n    var asMilliseconds = makeAs(\"ms\"), asSeconds = makeAs(\"s\"), asMinutes = makeAs(\"m\"), asHours = makeAs(\"h\"), asDays = makeAs(\"d\"), asWeeks = makeAs(\"w\"), asMonths = makeAs(\"M\"), asQuarters = makeAs(\"Q\"), asYears = makeAs(\"y\");\n    function clone$1() {\n        return createDuration(this);\n    }\n    function get$2(units) {\n        units = normalizeUnits(units);\n        return this.isValid() ? this[units + \"s\"]() : NaN;\n    }\n    function makeGetter(name) {\n        return function() {\n            return this.isValid() ? this._data[name] : NaN;\n        };\n    }\n    var milliseconds = makeGetter(\"milliseconds\"), seconds = makeGetter(\"seconds\"), minutes = makeGetter(\"minutes\"), hours = makeGetter(\"hours\"), days = makeGetter(\"days\"), months = makeGetter(\"months\"), years = makeGetter(\"years\");\n    function weeks() {\n        return absFloor(this.days() / 7);\n    }\n    var round = Math.round, thresholds = {\n        ss: 44,\n        s: 45,\n        m: 45,\n        h: 22,\n        d: 26,\n        w: null,\n        M: 11\n    };\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n    }\n    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {\n        var duration = createDuration(posNegDuration).abs(), seconds = round(duration.as(\"s\")), minutes = round(duration.as(\"m\")), hours = round(duration.as(\"h\")), days = round(duration.as(\"d\")), months = round(duration.as(\"M\")), weeks = round(duration.as(\"w\")), years = round(duration.as(\"y\")), a = seconds <= thresholds.ss && [\n            \"s\",\n            seconds\n        ] || seconds < thresholds.s && [\n            \"ss\",\n            seconds\n        ] || minutes <= 1 && [\n            \"m\"\n        ] || minutes < thresholds.m && [\n            \"mm\",\n            minutes\n        ] || hours <= 1 && [\n            \"h\"\n        ] || hours < thresholds.h && [\n            \"hh\",\n            hours\n        ] || days <= 1 && [\n            \"d\"\n        ] || days < thresholds.d && [\n            \"dd\",\n            days\n        ];\n        if (thresholds.w != null) {\n            a = a || weeks <= 1 && [\n                \"w\"\n            ] || weeks < thresholds.w && [\n                \"ww\",\n                weeks\n            ];\n        }\n        a = a || months <= 1 && [\n            \"M\"\n        ] || months < thresholds.M && [\n            \"MM\",\n            months\n        ] || years <= 1 && [\n            \"y\"\n        ] || [\n            \"yy\",\n            years\n        ];\n        a[2] = withoutSuffix;\n        a[3] = +posNegDuration > 0;\n        a[4] = locale;\n        return substituteTimeAgo.apply(null, a);\n    }\n    // This function allows you to set the rounding function for relative time strings\n    function getSetRelativeTimeRounding(roundingFunction) {\n        if (roundingFunction === undefined) {\n            return round;\n        }\n        if (typeof roundingFunction === \"function\") {\n            round = roundingFunction;\n            return true;\n        }\n        return false;\n    }\n    // This function allows you to set a threshold for relative time strings\n    function getSetRelativeTimeThreshold(threshold, limit) {\n        if (thresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return thresholds[threshold];\n        }\n        thresholds[threshold] = limit;\n        if (threshold === \"s\") {\n            thresholds.ss = limit - 1;\n        }\n        return true;\n    }\n    function humanize(argWithSuffix, argThresholds) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n        var withSuffix = false, th = thresholds, locale, output;\n        if (typeof argWithSuffix === \"object\") {\n            argThresholds = argWithSuffix;\n            argWithSuffix = false;\n        }\n        if (typeof argWithSuffix === \"boolean\") {\n            withSuffix = argWithSuffix;\n        }\n        if (typeof argThresholds === \"object\") {\n            th = Object.assign({}, thresholds, argThresholds);\n            if (argThresholds.s != null && argThresholds.ss == null) {\n                th.ss = argThresholds.s - 1;\n            }\n        }\n        locale = this.localeData();\n        output = relativeTime$1(this, !withSuffix, th, locale);\n        if (withSuffix) {\n            output = locale.pastFuture(+this, output);\n        }\n        return locale.postformat(output);\n    }\n    var abs$1 = Math.abs;\n    function sign(x) {\n        return (x > 0) - (x < 0) || +x;\n    }\n    function toISOString$1() {\n        // for ISO strings we do not use the normal bubbling rules:\n        //  * milliseconds bubble up until they become hours\n        //  * days do not bubble at all\n        //  * months bubble up until they become years\n        // This is because there is no context-free conversion between hours and days\n        // (think of clock changes)\n        // and also not between days and months (28-31 days per month)\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n        var seconds = abs$1(this._milliseconds) / 1000, days = abs$1(this._days), months = abs$1(this._months), minutes, hours, years, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;\n        if (!total) {\n            // this is the same as C#'s (Noda) and python (isodate)...\n            // but not other JS (goog.date)\n            return \"P0D\";\n        }\n        // 3600 seconds -> 60 minutes -> 1 hour\n        minutes = absFloor(seconds / 60);\n        hours = absFloor(minutes / 60);\n        seconds %= 60;\n        minutes %= 60;\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n        s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, \"\") : \"\";\n        totalSign = total < 0 ? \"-\" : \"\";\n        ymSign = sign(this._months) !== sign(total) ? \"-\" : \"\";\n        daysSign = sign(this._days) !== sign(total) ? \"-\" : \"\";\n        hmsSign = sign(this._milliseconds) !== sign(total) ? \"-\" : \"\";\n        return totalSign + \"P\" + (years ? ymSign + years + \"Y\" : \"\") + (months ? ymSign + months + \"M\" : \"\") + (days ? daysSign + days + \"D\" : \"\") + (hours || minutes || seconds ? \"T\" : \"\") + (hours ? hmsSign + hours + \"H\" : \"\") + (minutes ? hmsSign + minutes + \"M\" : \"\") + (seconds ? hmsSign + s + \"S\" : \"\");\n    }\n    var proto$2 = Duration.prototype;\n    proto$2.isValid = isValid$1;\n    proto$2.abs = abs;\n    proto$2.add = add$1;\n    proto$2.subtract = subtract$1;\n    proto$2.as = as;\n    proto$2.asMilliseconds = asMilliseconds;\n    proto$2.asSeconds = asSeconds;\n    proto$2.asMinutes = asMinutes;\n    proto$2.asHours = asHours;\n    proto$2.asDays = asDays;\n    proto$2.asWeeks = asWeeks;\n    proto$2.asMonths = asMonths;\n    proto$2.asQuarters = asQuarters;\n    proto$2.asYears = asYears;\n    proto$2.valueOf = valueOf$1;\n    proto$2._bubble = bubble;\n    proto$2.clone = clone$1;\n    proto$2.get = get$2;\n    proto$2.milliseconds = milliseconds;\n    proto$2.seconds = seconds;\n    proto$2.minutes = minutes;\n    proto$2.hours = hours;\n    proto$2.days = days;\n    proto$2.weeks = weeks;\n    proto$2.months = months;\n    proto$2.years = years;\n    proto$2.humanize = humanize;\n    proto$2.toISOString = toISOString$1;\n    proto$2.toString = toISOString$1;\n    proto$2.toJSON = toISOString$1;\n    proto$2.locale = locale;\n    proto$2.localeData = localeData;\n    proto$2.toIsoString = deprecate(\"toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)\", toISOString$1);\n    proto$2.lang = lang;\n    // FORMATTING\n    addFormatToken(\"X\", 0, 0, \"unix\");\n    addFormatToken(\"x\", 0, 0, \"valueOf\");\n    // PARSING\n    addRegexToken(\"x\", matchSigned);\n    addRegexToken(\"X\", matchTimestamp);\n    addParseToken(\"X\", function(input, array, config) {\n        config._d = new Date(parseFloat(input) * 1000);\n    });\n    addParseToken(\"x\", function(input, array, config) {\n        config._d = new Date(toInt(input));\n    });\n    //! moment.js\n    hooks.version = \"2.29.4\";\n    setHookCallback(createLocal);\n    hooks.fn = proto;\n    hooks.min = min;\n    hooks.max = max;\n    hooks.now = now;\n    hooks.utc = createUTC;\n    hooks.unix = createUnix;\n    hooks.months = listMonths;\n    hooks.isDate = isDate;\n    hooks.locale = getSetGlobalLocale;\n    hooks.invalid = createInvalid;\n    hooks.duration = createDuration;\n    hooks.isMoment = isMoment;\n    hooks.weekdays = listWeekdays;\n    hooks.parseZone = createInZone;\n    hooks.localeData = getLocale;\n    hooks.isDuration = isDuration;\n    hooks.monthsShort = listMonthsShort;\n    hooks.weekdaysMin = listWeekdaysMin;\n    hooks.defineLocale = defineLocale;\n    hooks.updateLocale = updateLocale;\n    hooks.locales = listLocales;\n    hooks.weekdaysShort = listWeekdaysShort;\n    hooks.normalizeUnits = normalizeUnits;\n    hooks.relativeTimeRounding = getSetRelativeTimeRounding;\n    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n    hooks.calendarFormat = getCalendarFormat;\n    hooks.prototype = proto;\n    // currently HTML5 input type only supports 24-hour formats\n    hooks.HTML5_FMT = {\n        DATETIME_LOCAL: \"YYYY-MM-DDTHH:mm\",\n        DATETIME_LOCAL_SECONDS: \"YYYY-MM-DDTHH:mm:ss\",\n        DATETIME_LOCAL_MS: \"YYYY-MM-DDTHH:mm:ss.SSS\",\n        DATE: \"YYYY-MM-DD\",\n        TIME: \"HH:mm\",\n        TIME_SECONDS: \"HH:mm:ss\",\n        TIME_MS: \"HH:mm:ss.SSS\",\n        WEEK: \"GGGG-[W]WW\",\n        MONTH: \"YYYY-MM\"\n    };\n    return hooks;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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MEIsU0FBUyxHQUFHTztJQUNsQnYwQixNQUFNcUssVUFBVSxHQUFHNlQ7SUFDbkJsZSxNQUFNbW5CLFVBQVUsR0FBR0E7SUFDbkJubkIsTUFBTXFULFdBQVcsR0FBR2lpQjtJQUNwQnQxQixNQUFNb1ksV0FBVyxHQUFHcWQ7SUFDcEJ6MUIsTUFBTW1lLFlBQVksR0FBR0E7SUFDckJuZSxNQUFNdWUsWUFBWSxHQUFHQTtJQUNyQnZlLE1BQU00YyxPQUFPLEdBQUc2QjtJQUNoQnplLE1BQU1xWSxhQUFhLEdBQUdtZDtJQUN0QngxQixNQUFNK04sY0FBYyxHQUFHQTtJQUN2Qi9OLE1BQU02NEIsb0JBQW9CLEdBQUdyQjtJQUM3QngzQixNQUFNODRCLHFCQUFxQixHQUFHcEI7SUFDOUIxM0IsTUFBTXdzQixjQUFjLEdBQUdQO0lBQ3ZCanNCLE1BQU1TLFNBQVMsR0FBRzZ5QjtJQUVsQiwyREFBMkQ7SUFDM0R0ekIsTUFBTSs0QixTQUFTLEdBQUc7UUFDZEMsZ0JBQWdCO1FBQ2hCQyx3QkFBd0I7UUFDeEJDLG1CQUFtQjtRQUNuQjFtQixNQUFNO1FBQ04ybUIsTUFBTTtRQUNOQyxjQUFjO1FBQ2RDLFNBQVM7UUFDVHhtQixNQUFNO1FBQ05OLE9BQU87SUFDWDtJQUVBLE9BQU92UztBQUVYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFyeS5pbmZvLy4vbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanM/OTM4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuMjkuNFxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgIGZ1bmN0aW9uIGhvb2tzKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KGlucHV0KSB7XG4gICAgICAgIC8vIElFOCB3aWxsIHRyZWF0IHVuZGVmaW5lZCBhbmQgbnVsbCBhcyBvYmplY3QgaWYgaXQgd2Fzbid0IGZvclxuICAgICAgICAvLyBpbnB1dCAhPSBudWxsXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpbnB1dCAhPSBudWxsICYmXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0RW1wdHkob2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoID09PSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGFyckxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnJMZW47ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5OiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VuczogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dDogW10sXG4gICAgICAgICAgICBvdmVyZmxvdzogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0OiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRFcmE6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGg6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkRm9ybWF0OiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZDogZmFsc2UsXG4gICAgICAgICAgICBpc286IGZhbHNlLFxuICAgICAgICAgICAgcGFyc2VkRGF0ZVBhcnRzOiBbXSxcbiAgICAgICAgICAgIGVyYTogbnVsbCxcbiAgICAgICAgICAgIG1lcmlkaWVtOiBudWxsLFxuICAgICAgICAgICAgcmZjMjgyMjogZmFsc2UsXG4gICAgICAgICAgICB3ZWVrZGF5TWlzbWF0Y2g6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XG4gICAgICAgIGlmIChtLl9wZiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5fcGY7XG4gICAgfVxuXG4gICAgdmFyIHNvbWU7XG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5zb21lKSB7XG4gICAgICAgIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzb21lID0gZnVuY3Rpb24gKGZ1bikge1xuICAgICAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyksXG4gICAgICAgICAgICAgICAgbGVuID0gdC5sZW5ndGggPj4+IDAsXG4gICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pLFxuICAgICAgICAgICAgICAgIHBhcnNlZFBhcnRzID0gc29tZS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBpc05vd1ZhbGlkID1cbiAgICAgICAgICAgICAgICAgICAgIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRXJhICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy53ZWVrZGF5TWlzbWF0Y2ggJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgICAgICghZmxhZ3MubWVyaWRpZW0gfHwgKGZsYWdzLm1lcmlkaWVtICYmIHBhcnNlZFBhcnRzKSk7XG5cbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpc05vd1ZhbGlkID1cbiAgICAgICAgICAgICAgICAgICAgaXNOb3dWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmlzRnJvemVuID09IG51bGwgfHwgIU9iamVjdC5pc0Zyb3plbihtKSkge1xuICAgICAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkKGZsYWdzKSB7XG4gICAgICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbiAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxuICAgIHZhciBtb21lbnRQcm9wZXJ0aWVzID0gKGhvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXSksXG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgbW9tZW50UHJvcGVydGllc0xlbiA9IG1vbWVudFByb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllc0xlbiA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtb21lbnRQcm9wZXJ0aWVzTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50KG9iaikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgb2JqIGluc3RhbmNlb2YgTW9tZW50IHx8IChvYmogIT0gbnVsbCAmJiBvYmouX2lzQU1vbWVudE9iamVjdCAhPSBudWxsKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgY29uc29sZS53YXJuXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIGFyZ0xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGFyZ3VtZW50c1swXSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMCwgLTIpOyAvLyBSZW1vdmUgdHJhaWxpbmcgY29tbWEgYW5kIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgIG1zZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxuQXJndW1lbnRzOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihuYW1lLCBtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG4gICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh0eXBlb2YgRnVuY3Rpb24gIT09ICd1bmRlZmluZWQnICYmIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0KGNvbmZpZykge1xuICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY29uZmlnLCBpKSkge1xuICAgICAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX2RheU9mTW9udGhPcmRpbmFsUGFyc2UuXG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgdGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgKHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2Uuc291cmNlIHx8IHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UpICtcbiAgICAgICAgICAgICAgICAnfCcgK1xuICAgICAgICAgICAgICAgIC9cXGR7MSwyfS8uc291cmNlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSxcbiAgICAgICAgICAgIHByb3A7XG4gICAgICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cztcblxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5OiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgIG5leHREYXk6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5OiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICBsYXN0V2VlazogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZTogJ0wnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhcihrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgK1xuICAgICAgICAgICAgYWJzTnVtYmVyXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPVxuICAgICAgICAgICAgLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KFtIaF1tbShzcyk/fE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFFvP3xOezEsNX18WVlZWVlZfFlZWVlZfFlZWVl8WVl8eXsyLDR9fHlvP3xnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xraz98bW0/fHNzP3xTezEsOX18eHxYfHp6P3xaWj98LikvZyxcbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZyxcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zID0ge30sXG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge307XG5cbiAgICAvLyB0b2tlbjogICAgJ00nXG4gICAgLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuICAgIC8vIG9yZGluYWw6ICAnTW8nXG4gICAgLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG4gICAgZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4odG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKFxuICAgICAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgICAgIHRva2VuXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJyxcbiAgICAgICAgICAgICAgICBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pXG4gICAgICAgICAgICAgICAgICAgID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdClcbiAgICAgICAgICAgICAgICAgICAgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPVxuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2VucyxcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb25nRGF0ZUZvcm1hdCA9IHtcbiAgICAgICAgTFRTOiAnaDptbTpzcyBBJyxcbiAgICAgICAgTFQ6ICdoOm1tIEEnLFxuICAgICAgICBMOiAnTU0vREQvWVlZWScsXG4gICAgICAgIExMOiAnTU1NTSBELCBZWVlZJyxcbiAgICAgICAgTExMOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgICAgIExMTEw6ICdkZGRkLCBNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQoa2V5KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldLFxuICAgICAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXJcbiAgICAgICAgICAgIC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodG9rKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdNTU1NJyB8fFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdNTScgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnREQnIHx8XG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ2RkZGQnXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2suc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2s7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuICAgIGZ1bmN0aW9uIGludmFsaWREYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJyxcbiAgICAgICAgZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG4gICAgZnVuY3Rpb24gb3JkaW5hbChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmU6ICdpbiAlcycsXG4gICAgICAgIHBhc3Q6ICclcyBhZ28nLFxuICAgICAgICBzOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIHNzOiAnJWQgc2Vjb25kcycsXG4gICAgICAgIG06ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tOiAnJWQgbWludXRlcycsXG4gICAgICAgIGg6ICdhbiBob3VyJyxcbiAgICAgICAgaGg6ICclZCBob3VycycsXG4gICAgICAgIGQ6ICdhIGRheScsXG4gICAgICAgIGRkOiAnJWQgZGF5cycsXG4gICAgICAgIHc6ICdhIHdlZWsnLFxuICAgICAgICB3dzogJyVkIHdlZWtzJyxcbiAgICAgICAgTTogJ2EgbW9udGgnLFxuICAgICAgICBNTTogJyVkIG1vbnRocycsXG4gICAgICAgIHk6ICdhIHllYXInLFxuICAgICAgICB5eTogJyVkIHllYXJzJyxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dClcbiAgICAgICAgICAgID8gb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSlcbiAgICAgICAgICAgIDogb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFzdEZ1dHVyZShkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRBbGlhcyh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgICAgIHByb3A7XG5cbiAgICAgICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbiAgICB9XG5cbiAgICB2YXIgcHJpb3JpdGllcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdFByaW9yaXR5KHVuaXQsIHByaW9yaXR5KSB7XG4gICAgICAgIHByaW9yaXRpZXNbdW5pdF0gPSBwcmlvcml0eTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzT2JqKSB7XG4gICAgICAgIHZhciB1bml0cyA9IFtdLFxuICAgICAgICAgICAgdTtcbiAgICAgICAgZm9yICh1IGluIHVuaXRzT2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcCh1bml0c09iaiwgdSkpIHtcbiAgICAgICAgICAgICAgICB1bml0cy5wdXNoKHsgdW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICAvLyAtMCAtPiAwXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcikgfHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgICAgIHZhciBjb2VyY2VkTnVtYmVyID0gK2FyZ3VtZW50Rm9yQ29lcmNpb24sXG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYWJzRmxvb3IoY29lcmNlZE51bWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCh1bml0LCBrZWVwVGltZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNldCQxKHRoaXMsIHVuaXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldChtb20sIHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5pc1ZhbGlkKClcbiAgICAgICAgICAgID8gbW9tLl9kWydnZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKClcbiAgICAgICAgICAgIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldCQxKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG1vbS5pc1ZhbGlkKCkgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHVuaXQgPT09ICdGdWxsWWVhcicgJiZcbiAgICAgICAgICAgICAgICBpc0xlYXBZZWFyKG1vbS55ZWFyKCkpICYmXG4gICAgICAgICAgICAgICAgbW9tLm1vbnRoKCkgPT09IDEgJiZcbiAgICAgICAgICAgICAgICBtb20uZGF0ZSgpID09PSAyOVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbW9tLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgIGRheXNJbk1vbnRoKHZhbHVlLCBtb20ubW9udGgoKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc3RyaW5nR2V0KHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1NldCh1bml0cywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplT2JqZWN0VW5pdHModW5pdHMpO1xuICAgICAgICAgICAgdmFyIHByaW9yaXRpemVkID0gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0cyksXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBwcmlvcml0aXplZExlbiA9IHByaW9yaXRpemVkLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcmlvcml0aXplZExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoMSA9IC9cXGQvLCAvLyAgICAgICAwIC0gOVxuICAgICAgICBtYXRjaDIgPSAvXFxkXFxkLywgLy8gICAgICAwMCAtIDk5XG4gICAgICAgIG1hdGNoMyA9IC9cXGR7M30vLCAvLyAgICAgMDAwIC0gOTk5XG4gICAgICAgIG1hdGNoNCA9IC9cXGR7NH0vLCAvLyAgICAwMDAwIC0gOTk5OVxuICAgICAgICBtYXRjaDYgPSAvWystXT9cXGR7Nn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoMXRvMiA9IC9cXGRcXGQ/LywgLy8gICAgICAgMCAtIDk5XG4gICAgICAgIG1hdGNoM3RvNCA9IC9cXGRcXGRcXGRcXGQ/LywgLy8gICAgIDk5OSAtIDk5OTlcbiAgICAgICAgbWF0Y2g1dG82ID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vLCAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoMXRvMyA9IC9cXGR7MSwzfS8sIC8vICAgICAgIDAgLSA5OTlcbiAgICAgICAgbWF0Y2gxdG80ID0gL1xcZHsxLDR9LywgLy8gICAgICAgMCAtIDk5OTlcbiAgICAgICAgbWF0Y2gxdG82ID0gL1srLV0/XFxkezEsNn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoVW5zaWduZWQgPSAvXFxkKy8sIC8vICAgICAgIDAgLSBpbmZcbiAgICAgICAgbWF0Y2hTaWduZWQgPSAvWystXT9cXGQrLywgLy8gICAgLWluZiAtIGluZlxuICAgICAgICBtYXRjaE9mZnNldCA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naSwgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgICAgIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naSwgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICAgICAgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vLCAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuICAgICAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAgICAgLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xuICAgICAgICBtYXRjaFdvcmQgPVxuICAgICAgICAgICAgL1swLTldezAsMjU2fVsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRjA3XFx1RkYxMC1cXHVGRkVGXXsxLDI1Nn18W1xcdTA2MDAtXFx1MDZGRlxcL117MSwyNTZ9KFxccyo/W1xcdTA2MDAtXFx1MDZGRl17MSwyNTZ9KXsxLDJ9L2ksXG4gICAgICAgIHJlZ2V4ZXM7XG5cbiAgICByZWdleGVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRSZWdleFRva2VuKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KVxuICAgICAgICAgICAgPyByZWdleFxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpc1N0cmljdCAmJiBzdHJpY3RSZWdleCA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShcbiAgICAgICAgICAgIHNcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgnXFxcXCcsICcnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgZnVuYyA9IGNhbGxiYWNrLFxuICAgICAgICAgICAgdG9rZW5MZW47XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRva2VuTGVuID0gdG9rZW4ubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5MZW47IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbih0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgWUVBUiA9IDAsXG4gICAgICAgIE1PTlRIID0gMSxcbiAgICAgICAgREFURSA9IDIsXG4gICAgICAgIEhPVVIgPSAzLFxuICAgICAgICBNSU5VVEUgPSA0LFxuICAgICAgICBTRUNPTkQgPSA1LFxuICAgICAgICBNSUxMSVNFQ09ORCA9IDYsXG4gICAgICAgIFdFRUsgPSA3LFxuICAgICAgICBXRUVLREFZID0gODtcblxuICAgIGZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXhPZjtcblxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICAgICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcbiAgICAgICAgcmV0dXJuIG1vZE1vbnRoID09PSAxXG4gICAgICAgICAgICA/IGlzTGVhcFllYXIoeWVhcilcbiAgICAgICAgICAgICAgICA/IDI5XG4gICAgICAgICAgICAgICAgOiAyOFxuICAgICAgICAgICAgOiAzMSAtICgobW9kTW9udGggJSA3KSAlIDIpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9XG4gICAgICAgICAgICAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoXG4gICAgICAgICAgICAgICAgJ18nXG4gICAgICAgICAgICApLFxuICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPVxuICAgICAgICAgICAgJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpLFxuICAgICAgICBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vLFxuICAgICAgICBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZCxcbiAgICAgICAgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocylcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1xuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKVxuICAgICAgICAgICAgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXVxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNbXG4gICAgICAgICAgICAgICAgICAodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICAgID8gJ2Zvcm1hdCdcbiAgICAgICAgICAgICAgICAgICAgICA6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgICAgICBdW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydClcbiAgICAgICAgICAgID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXVxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFtcbiAgICAgICAgICAgICAgICAgIE1PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCB1c2VkXG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRoc1Nob3J0KFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgICAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9XG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTU0nICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTScgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb207XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/IHplcm9GaWxsKHksIDQpIDogJysnICsgeTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCA0XSwgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgNV0sIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3llYXInLCAxKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWScsIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID1cbiAgICAgICAgICAgIGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICBob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4MTM0OFxuICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSh5KSB7XG4gICAgICAgIHZhciBkYXRlLCBhcmdzO1xuICAgICAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgYXJnc1swXSA9IHkgKyA0MDA7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJncykpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbiAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgICAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcblxuICAgICAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgICAgICByZXNZZWFyLFxuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlayxcbiAgICAgICAgICAgIHJlc1llYXI7XG5cbiAgICAgICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2VlazogcmVzV2VlayxcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1cnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oXG4gICAgICAgIFsndycsICd3dycsICdXJywgJ1dXJ10sXG4gICAgICAgIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93OiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgZG95OiA2LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA2dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRveTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZGQnLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG4gICAgZnVuY3Rpb24gc2hpZnRXZWVrZGF5cyh3cywgbikge1xuICAgICAgICByZXR1cm4gd3Muc2xpY2UobiwgNykuY29uY2F0KHdzLnNsaWNlKDAsIG4pKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID1cbiAgICAgICAgICAgICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpLFxuICAgICAgICBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNNaW5SZWdleCA9IG1hdGNoV29yZDtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgd2Vla2RheXMgPSBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKVxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1xuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1tcbiAgICAgICAgICAgICAgICAgIG0gJiYgbSAhPT0gdHJ1ZSAmJiB0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdClcbiAgICAgICAgICAgICAgICAgICAgICA/ICdmb3JtYXQnXG4gICAgICAgICAgICAgICAgICAgICAgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh3ZWVrZGF5cywgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gd2Vla2RheXNbbS5kYXkoKV1cbiAgICAgICAgICAgIDogd2Vla2RheXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydChtKSB7XG4gICAgICAgIHJldHVybiBtID09PSB0cnVlXG4gICAgICAgICAgICA/IHNoaWZ0V2Vla2RheXModGhpcy5fd2Vla2RheXNTaG9ydCwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXVxuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluKG0pIHtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c01pbiwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV1cbiAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNNaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4oXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c1Nob3J0KFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UkMS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9XG4gICAgICAgICAgICAgICAgICAgICdeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXMobW9tLCAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnfF4nICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICtcbiAgICAgICAgICAgICAgICAgICAgJ3xeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnZGRkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ2RkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sXG4gICAgICAgICAgICBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb20sXG4gICAgICAgICAgICBtaW5wLFxuICAgICAgICAgICAgc2hvcnRwLFxuICAgICAgICAgICAgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHJlZ2V4RXNjYXBlKHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykpO1xuICAgICAgICAgICAgc2hvcnRwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5cyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICcnICtcbiAgICAgICAgICAgIGhGb3JtYXQuYXBwbHkodGhpcykgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgdGhpcy5ob3VycygpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMilcbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbShcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXJzKCksXG4gICAgICAgICAgICAgICAgdGhpcy5taW51dGVzKCksXG4gICAgICAgICAgICAgICAgbG93ZXJjYXNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbShpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgfVxuXG4gICAgYWRkUmVnZXhUb2tlbignYScsIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdoJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdrJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNCxcbiAgICAgICAgICAgIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQsXG4gICAgICAgICAgICBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNKGlucHV0KSB7XG4gICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgICAgIHJldHVybiAoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaSxcbiAgICAgICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIHRoZXkgd2FudC4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgICAgICAvLyB0aGlzIHJ1bGUuXG4gICAgICAgIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0oaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSxcbiAgICB9O1xuXG4gICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xuICAgIHZhciBsb2NhbGVzID0ge30sXG4gICAgICAgIGxvY2FsZUZhbWlsaWVzID0ge30sXG4gICAgICAgIGdsb2JhbExvY2FsZTtcblxuICAgIGZ1bmN0aW9uIGNvbW1vblByZWZpeChhcnIxLCBhcnIyKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbWlubCA9IE1hdGgubWluKGFycjEubGVuZ3RoLCBhcnIyLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5sOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbmw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgc3BsaXQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbmV4dCAmJlxuICAgICAgICAgICAgICAgICAgICBuZXh0Lmxlbmd0aCA+PSBqICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vblByZWZpeChzcGxpdCwgbmV4dCkgPj0gaiAtIDFcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbGVOYW1lU2FuZShuYW1lKSB7XG4gICAgICAgIC8vIFByZXZlbnQgbmFtZXMgdGhhdCBsb29rIGxpa2UgZmlsZXN5c3RlbSBwYXRocywgaS5lIGNvbnRhaW4gJy8nIG9yICdcXCdcbiAgICAgICAgcmV0dXJuIG5hbWUubWF0Y2goJ15bXi9cXFxcXFxcXF0qJCcpICE9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsLFxuICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmU7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIG1vZHVsZSAmJlxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgJiZcbiAgICAgICAgICAgIGlzTG9jYWxlTmFtZVNhbmUobmFtZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIG5vdCBmb3VuZCB0byBhdm9pZCByZXBlYXRpbmcgZXhwZW5zaXZlIGZpbGUgcmVxdWlyZSBjYWxsIGNhdXNpbmcgaGlnaCBDUFVcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRyeWluZyB0byBmaW5kIGVuLVVTLCBlbl9VUywgZW4tdXMgZm9yIGV2ZXJ5IGZvcm1hdCBjYWxsXG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG51bGw7IC8vIG51bGwgbWVhbnMgbm90IGZvdW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZShrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xvY2FsZSAnICsga2V5ICsgJyBub3QgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIGxvYWQgaXQ/J1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKFxuICAgICAgICAgICAgICAgICAgICAnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZUxvY2FsZSh4Lm5hbWUsIHguY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSxcbiAgICAgICAgICAgICAgICB0bXBMb2NhbGUsXG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcblxuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCAmJiBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIGNoaWxkIGxvY2FsZSBpbi1wbGFjZSB0byBhdm9pZCBtZW1vcnktbGVha3NcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdLnNldChtZXJnZUNvbmZpZ3MobG9jYWxlc1tuYW1lXS5fY29uZmlnLCBjb25maWcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSB0bXBMb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBpZiAodG1wTG9jYWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlTG9jYWxlIGlzIGNhbGxlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhYmJyIHNvIGl0IHdpbGwgaGF2ZSBhIG5hbWUgKGdldHRlcnMgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBvdGhlcndpc2UpLlxuICAgICAgICAgICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gZ2V0U2V0R2xvYmFsTG9jYWxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlKGtleSkge1xuICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TG9jYWxlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyhtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdyxcbiAgICAgICAgICAgIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSA8IDAgfHwgYVtNT05USF0gPiAxMVxuICAgICAgICAgICAgICAgICAgICA/IE1PTlRIXG4gICAgICAgICAgICAgICAgICAgIDogYVtEQVRFXSA8IDEgfHwgYVtEQVRFXSA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKVxuICAgICAgICAgICAgICAgICAgICA/IERBVEVcbiAgICAgICAgICAgICAgICAgICAgOiBhW0hPVVJdIDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICAgIGFbSE9VUl0gPiAyNCB8fFxuICAgICAgICAgICAgICAgICAgICAgIChhW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoYVtNSU5VVEVdICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW1NFQ09ORF0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdICE9PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgPyBIT1VSXG4gICAgICAgICAgICAgICAgICAgIDogYVtNSU5VVEVdIDwgMCB8fCBhW01JTlVURV0gPiA1OVxuICAgICAgICAgICAgICAgICAgICA/IE1JTlVURVxuICAgICAgICAgICAgICAgICAgICA6IGFbU0VDT05EXSA8IDAgfHwgYVtTRUNPTkRdID4gNTlcbiAgICAgICAgICAgICAgICAgICAgPyBTRUNPTkRcbiAgICAgICAgICAgICAgICAgICAgOiBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTlcbiAgICAgICAgICAgICAgICAgICAgPyBNSUxMSVNFQ09ORFxuICAgICAgICAgICAgICAgICAgICA6IC0xO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJlxuICAgICAgICAgICAgICAgIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrcyAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtkYXkgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPVxuICAgICAgICAgICAgL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoWystXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC8sXG4gICAgICAgIGJhc2ljSXNvUmVnZXggPVxuICAgICAgICAgICAgL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZHwpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbKy1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcbiAgICAgICAgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LyxcbiAgICAgICAgaXNvRGF0ZXMgPSBbXG4gICAgICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAgICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICAgICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L10sXG4gICAgICAgICAgICBbJ1lZWVlNTScsIC9cXGR7Nn0vLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVknLCAvXFxkezR9LywgZmFsc2VdLFxuICAgICAgICBdLFxuICAgICAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgICAgIGlzb1RpbWVzID0gW1xuICAgICAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICAgICAgWydISDptbTpzcyxTU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkLFxcZCsvXSxcbiAgICAgICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICAgICAgWydISG1tc3MuU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEhtbScsIC9cXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEgnLCAvXFxkXFxkL10sXG4gICAgICAgIF0sXG4gICAgICAgIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoLT9cXGQrKS9pLFxuICAgICAgICAvLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG4gICAgICAgIHJmYzI4MjIgPVxuICAgICAgICAgICAgL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSw/XFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfChbKy1dXFxkezR9KSkkLyxcbiAgICAgICAgb2JzT2Zmc2V0cyA9IHtcbiAgICAgICAgICAgIFVUOiAwLFxuICAgICAgICAgICAgR01UOiAwLFxuICAgICAgICAgICAgRURUOiAtNCAqIDYwLFxuICAgICAgICAgICAgRVNUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ0RUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ1NUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTURUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTVNUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUERUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUFNUOiAtOCAqIDYwLFxuICAgICAgICB9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICAgICAgYWxsb3dUaW1lLFxuICAgICAgICAgICAgZGF0ZUZvcm1hdCxcbiAgICAgICAgICAgIHRpbWVGb3JtYXQsXG4gICAgICAgICAgICB0ekZvcm1hdCxcbiAgICAgICAgICAgIGlzb0RhdGVzTGVuID0gaXNvRGF0ZXMubGVuZ3RoLFxuICAgICAgICAgICAgaXNvVGltZXNMZW4gPSBpc29UaW1lcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzTGVuOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzTGVuOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhcbiAgICAgICAgeWVhclN0cixcbiAgICAgICAgbW9udGhTdHIsXG4gICAgICAgIGRheVN0cixcbiAgICAgICAgaG91clN0cixcbiAgICAgICAgbWludXRlU3RyLFxuICAgICAgICBzZWNvbmRTdHJcbiAgICApIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgICAgICAgIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpLFxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpLFxuICAgICAgICAgICAgcGFyc2VJbnQoZGF5U3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChob3VyU3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChtaW51dGVTdHIsIDEwKSxcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgIHJldHVybiBzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwoW14oKV0qXFwpfFtcXG5cXHRdL2csICcgJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXFxzXFxzKykvZywgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXHNcXHMqLywgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tXZWVrZGF5KHdlZWtkYXlTdHIsIHBhcnNlZElucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhlIHZhbmlsbGEgSlMgRGF0ZSBvYmplY3Qgd2l0aCBhbiBpbmRlcGVuZGVudCBkYXktb2Ytd2VlayBjaGVjay5cbiAgICAgICAgICAgIHZhciB3ZWVrZGF5UHJvdmlkZWQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydC5pbmRleE9mKHdlZWtkYXlTdHIpLFxuICAgICAgICAgICAgICAgIHdlZWtkYXlBY3R1YWwgPSBuZXcgRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElucHV0WzFdLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFsyXVxuICAgICAgICAgICAgICAgICkuZ2V0RGF5KCk7XG4gICAgICAgICAgICBpZiAod2Vla2RheVByb3ZpZGVkICE9PSB3ZWVrZGF5QWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xuICAgICAgICBpZiAob2JzT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzT2Zmc2V0c1tvYnNPZmZzZXRdO1xuICAgICAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyB0aGUgb25seSBhbGxvd2VkIG1pbGl0YXJ5IHR6IGlzIFpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhtID0gcGFyc2VJbnQobnVtT2Zmc2V0LCAxMCksXG4gICAgICAgICAgICAgICAgbSA9IGhtICUgMTAwLFxuICAgICAgICAgICAgICAgIGggPSAoaG0gLSBtKSAvIDEwMDtcbiAgICAgICAgICAgIHJldHVybiBoICogNjAgKyBtO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBhbmQgdGltZSBmcm9tIHJlZiAyODIyIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2ggPSByZmMyODIyLmV4ZWMocHJlcHJvY2Vzc1JGQzI4MjIoY29uZmlnLl9pKSksXG4gICAgICAgICAgICBwYXJzZWRBcnJheTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBwYXJzZWRBcnJheSA9IGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MoXG4gICAgICAgICAgICAgICAgbWF0Y2hbNF0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbM10sXG4gICAgICAgICAgICAgICAgbWF0Y2hbMl0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbNV0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbNl0sXG4gICAgICAgICAgICAgICAgbWF0Y2hbN11cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWNoZWNrV2Vla2RheShtYXRjaFsxXSwgcGFyc2VkQXJyYXksIGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IHBhcnNlZEFycmF5O1xuICAgICAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xuXG4gICAgICAgICAgICBjb25maWcuX2QgPSBjcmVhdGVVVENEYXRlLmFwcGx5KG51bGwsIGNvbmZpZy5fYSk7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIDEpIEFTUC5ORVQsIDIpIElTTywgMykgUkZDIDI4MjIgZm9ybWF0cywgb3IgNCkgb3B0aW9uYWwgZmFsbGJhY2sgaWYgcGFyc2luZyBpc24ndCBzdHJpY3RcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9zdHJpY3QpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmluYWwgYXR0ZW1wdCwgdXNlIElucHV0IEZhbGxiYWNrXG4gICAgICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2sgPSBkZXByZWNhdGUoXG4gICAgICAgICd2YWx1ZSBwcm92aWRlZCBpcyBub3QgaW4gYSByZWNvZ25pemVkIFJGQzI4MjIgb3IgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXG4gICAgICAgICAgICAnd2hpY2ggaXMgbm90IHJlbGlhYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnMgYW5kIHZlcnNpb25zLiBOb24gUkZDMjgyMi9JU08gZGF0ZSBmb3JtYXRzIGFyZSAnICtcbiAgICAgICAgICAgICdkaXNjb3VyYWdlZC4gUGxlYXNlIHJlZmVyIHRvIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XG4gICAgICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5vd1ZhbHVlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgICAgICAgICAgbm93VmFsdWUuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgICAgICAgICBub3dWYWx1ZS5nZXRVVENEYXRlKCksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgaW5wdXQgPSBbXSxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlLFxuICAgICAgICAgICAgZXhwZWN0ZWRXZWVrZGF5LFxuICAgICAgICAgICAgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpIHx8XG4gICAgICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPT09IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAgICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAgICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID1cbiAgICAgICAgICAgICAgICBjb25maWcuX2FbaV0gPT0gbnVsbCA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBpbnB1dFxuICAgICAgICApO1xuICAgICAgICBleHBlY3RlZFdlZWtkYXkgPSBjb25maWcuX3VzZVVUQ1xuICAgICAgICAgICAgPyBjb25maWcuX2QuZ2V0VVRDRGF5KClcbiAgICAgICAgICAgIDogY29uZmlnLl9kLmdldERheSgpO1xuXG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgICAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICAgICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGZvciBtaXNtYXRjaGluZyBkYXkgb2Ygd2Vla1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb25maWcuX3cgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25maWcuX3cuZCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fdy5kICE9PSBleHBlY3RlZFdlZWtkYXlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCB3ZWVrZGF5T3ZlcmZsb3csIGN1cldlZWs7XG5cbiAgICAgICAgdyA9IGNvbmZpZy5fdztcbiAgICAgICAgaWYgKHcuR0cgIT0gbnVsbCB8fCB3LlcgIT0gbnVsbCB8fCB3LkUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZG93ID0gMTtcbiAgICAgICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxuICAgICAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBub3cpLlxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyhcbiAgICAgICAgICAgICAgICB3LkdHLFxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSxcbiAgICAgICAgICAgICAgICB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICAgICAgY3VyV2VlayA9IHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpO1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCBjdXJXZWVrLndlZWspO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2lubmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIGhvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxuICAgIGhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xuICAgICAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25maWcuX2EgPSBbXTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwYXJzZWRJbnB1dCxcbiAgICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMCxcbiAgICAgICAgICAgIGVyYSxcbiAgICAgICAgICAgIHRva2VuTGVuO1xuXG4gICAgICAgIHRva2VucyA9XG4gICAgICAgICAgICBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG4gICAgICAgIHRva2VuTGVuID0gdG9rZW5zLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHxcbiAgICAgICAgICAgICAgICBbXSlbMF07XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGhcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPVxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoXG4gICAgICAgICAgICBjb25maWcuX2xvY2FsZSxcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSxcbiAgICAgICAgICAgIGNvbmZpZy5fbWVyaWRpZW1cbiAgICAgICAgKTtcblxuICAgICAgICAvLyBoYW5kbGUgZXJhXG4gICAgICAgIGVyYSA9IGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVyYTtcbiAgICAgICAgaWYgKGVyYSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gY29uZmlnLl9sb2NhbGUuZXJhc0NvbnZlcnRZZWFyKGVyYSwgY29uZmlnLl9hW1lFQVJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG4gICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUsXG4gICAgICAgICAgICB2YWxpZEZvcm1hdEZvdW5kLFxuICAgICAgICAgICAgYmVzdEZvcm1hdElzVmFsaWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ2ZMZW4gPSBjb25maWcuX2YubGVuZ3RoO1xuXG4gICAgICAgIGlmIChjb25maWdmTGVuID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnZkxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoIWJlc3RGb3JtYXRJc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0IHx8XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRGb3JtYXRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZvcm1hdElzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpLFxuICAgICAgICAgICAgZGF5T3JEYXRlID0gaS5kYXkgPT09IHVuZGVmaW5lZCA/IGkuZGF0ZSA6IGkuZGF5O1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoXG4gICAgICAgICAgICBbaS55ZWFyLCBpLm1vbnRoLCBkYXlPckRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHsgbnVsbElucHV0OiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmIChmb3JtYXQgPT09IHRydWUgfHwgZm9ybWF0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RyaWN0ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWwoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArbmV3IERhdGUoKTtcbiAgICB9O1xuXG4gICAgdmFyIG9yZGVyaW5nID0gW1xuICAgICAgICAneWVhcicsXG4gICAgICAgICdxdWFydGVyJyxcbiAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgJ3dlZWsnLFxuICAgICAgICAnZGF5JyxcbiAgICAgICAgJ2hvdXInLFxuICAgICAgICAnbWludXRlJyxcbiAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb25WYWxpZChtKSB7XG4gICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IGZhbHNlLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG9yZGVyTGVuID0gb3JkZXJpbmcubGVuZ3RoO1xuICAgICAgICBmb3IgKGtleSBpbiBtKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaGFzT3duUHJvcChtLCBrZXkpICYmXG4gICAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhPZi5jYWxsKG9yZGVyaW5nLCBrZXkpICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAobVtrZXldID09IG51bGwgfHwgIWlzTmFOKG1ba2V5XSkpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9yZGVyTGVuOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChtW29yZGVyaW5nW2ldXSkge1xuICAgICAgICAgICAgICAgIGlmICh1bml0SGFzRGVjaW1hbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG9ubHkgYWxsb3cgbm9uLWludGVnZXJzIGZvciBzbWFsbGVzdCB1bml0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KG1bb3JkZXJpbmdbaV1dKSAhPT0gdG9JbnQobVtvcmRlcmluZ1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKE5hTik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCBub3JtYWxpemVkSW5wdXQuaXNvV2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9XG4gICAgICAgICAgICArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICsgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRvIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICsgcXVhcnRlcnMgKiAzICsgeWVhcnMgKiAxMjtcblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgICAgdGhpcy5fbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG5cbiAgICAgICAgdGhpcy5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic1JvdW5kKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29tcGFyZSB0d28gYXJyYXlzLCByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlc1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIG9mZnNldCh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKSxcbiAgICAgICAgICAgICAgICBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHNpZ24gK1xuICAgICAgICAgICAgICAgIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgK1xuICAgICAgICAgICAgICAgIHNlcGFyYXRvciArXG4gICAgICAgICAgICAgICAgemVyb0ZpbGwofn5vZmZzZXQgJSA2MCwgMilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9mZnNldCgnWicsICc6Jyk7XG4gICAgb2Zmc2V0KCdaWicsICcnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1onLCBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKSxcbiAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgcGFydHMsXG4gICAgICAgICAgICBtaW51dGVzO1xuXG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNodW5rID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICBwYXJ0cyA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgICAgIHJldHVybiBtaW51dGVzID09PSAwID8gMCA6IHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID1cbiAgICAgICAgICAgICAgICAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dClcbiAgICAgICAgICAgICAgICAgICAgPyBpbnB1dC52YWx1ZU9mKClcbiAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldChtKSB7XG4gICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIGhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lLCBrZWVwTWludXRlcykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYgJiYgIWtlZXBNaW51dGVzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZShpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvVVRDKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgdFpvbmUgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKTtcbiAgICAgICAgICAgIGlmICh0Wm9uZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodFpvbmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKCkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9LFxuICAgICAgICAgICAgb3RoZXI7XG5cbiAgICAgICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICAgICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICAgICAgaWYgKGMuX2EpIHtcbiAgICAgICAgICAgIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVVVEMoYy5fYSkgOiBjcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9XG4gICAgICAgICAgICAgICAgdGhpcy5pc1ZhbGlkKCkgJiYgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG4gICAgdmFyIGFzcE5ldFJlZ2V4ID0gL14oLXxcXCspPyg/OihcXGQqKVsuIF0pPyhcXGQrKTooXFxkKykoPzo6KFxcZCspKFxcLlxcZCopPyk/JC8sXG4gICAgICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbiAgICAgICAgLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxuICAgICAgICBpc29SZWdleCA9XG4gICAgICAgICAgICAvXigtfFxcKyk/UCg/OihbLStdP1swLTksLl0qKVkpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVcpPyg/OihbLStdP1swLTksLl0qKUQpPyg/OlQoPzooWy0rXT9bMC05LC5dKilIKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilTKT8pPyQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24oaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgIGQ6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE06IGlucHV0Ll9tb250aHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSB8fCAhaXNOYU4oK2lucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gK2lucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSAraW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gbWF0Y2hbMV0gPT09ICctJyA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgZDogdG9JbnQobWF0Y2hbREFURV0pICogc2lnbixcbiAgICAgICAgICAgICAgICBoOiB0b0ludChtYXRjaFtIT1VSXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIG06IHRvSW50KG1hdGNoW01JTlVURV0pICogc2lnbixcbiAgICAgICAgICAgICAgICBzOiB0b0ludChtYXRjaFtTRUNPTkRdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXM6IHRvSW50KGFic1JvdW5kKG1hdGNoW01JTExJU0VDT05EXSAqIDEwMDApKSAqIHNpZ24sIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICgobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSBtYXRjaFsxXSA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeTogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIE06IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3OiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgZDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGg6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgczogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShcbiAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbChkdXJhdGlvbi50bylcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfaXNWYWxpZCcpKSB7XG4gICAgICAgICAgICByZXQuX2lzVmFsaWQgPSBpbnB1dC5faXNWYWxpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG4gICAgY3JlYXRlRHVyYXRpb24uaW52YWxpZCA9IGNyZWF0ZUludmFsaWQkMTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge307XG5cbiAgICAgICAgcmVzLm1vbnRocyA9XG4gICAgICAgICAgICBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICsgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gK2Jhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwIH07XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAnbW9tZW50KCkuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsO1xuICAgICAgICAgICAgICAgIHZhbCA9IHBlcmlvZDtcbiAgICAgICAgICAgICAgICBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0KG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGQgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyksXG4gICAgICAgIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmc7XG4gICAgfVxuXG4gICAgLy8gdHlwZSBNb21lbnRJbnB1dCA9IE1vbWVudCB8IERhdGUgfCBzdHJpbmcgfCBudW1iZXIgfCAobnVtYmVyIHwgc3RyaW5nKVtdIHwgTW9tZW50SW5wdXRPYmplY3QgfCB2b2lkOyAvLyBudWxsIHwgdW5kZWZpbmVkXG4gICAgZnVuY3Rpb24gaXNNb21lbnRJbnB1dChpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNNb21lbnQoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc0RhdGUoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc1N0cmluZyhpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzTnVtYmVyKGlucHV0KSB8fFxuICAgICAgICAgICAgaXNOdW1iZXJPclN0cmluZ0FycmF5KGlucHV0KSB8fFxuICAgICAgICAgICAgaXNNb21lbnRJbnB1dE9iamVjdChpbnB1dCkgfHxcbiAgICAgICAgICAgIGlucHV0ID09PSBudWxsIHx8XG4gICAgICAgICAgICBpbnB1dCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnRJbnB1dE9iamVjdChpbnB1dCkge1xuICAgICAgICB2YXIgb2JqZWN0VGVzdCA9IGlzT2JqZWN0KGlucHV0KSAmJiAhaXNPYmplY3RFbXB0eShpbnB1dCksXG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBmYWxzZSxcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICAgICAgJ3llYXJzJyxcbiAgICAgICAgICAgICAgICAneWVhcicsXG4gICAgICAgICAgICAgICAgJ3knLFxuICAgICAgICAgICAgICAgICdtb250aHMnLFxuICAgICAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAgICAgJ00nLFxuICAgICAgICAgICAgICAgICdkYXlzJyxcbiAgICAgICAgICAgICAgICAnZGF5JyxcbiAgICAgICAgICAgICAgICAnZCcsXG4gICAgICAgICAgICAgICAgJ2RhdGVzJyxcbiAgICAgICAgICAgICAgICAnZGF0ZScsXG4gICAgICAgICAgICAgICAgJ0QnLFxuICAgICAgICAgICAgICAgICdob3VycycsXG4gICAgICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgICAgICdoJyxcbiAgICAgICAgICAgICAgICAnbWludXRlcycsXG4gICAgICAgICAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICAgICAgICAgJ20nLFxuICAgICAgICAgICAgICAgICdzZWNvbmRzJyxcbiAgICAgICAgICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgICAgICAgICAncycsXG4gICAgICAgICAgICAgICAgJ21pbGxpc2Vjb25kcycsXG4gICAgICAgICAgICAgICAgJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgICAgICAgICAnbXMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgIHByb3BlcnR5TGVuID0gcHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHByb3BlcnR5TGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IHByb3BlcnR5VGVzdCB8fCBoYXNPd25Qcm9wKGlucHV0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqZWN0VGVzdCAmJiBwcm9wZXJ0eVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXJPclN0cmluZ0FycmF5KGlucHV0KSB7XG4gICAgICAgIHZhciBhcnJheVRlc3QgPSBpc0FycmF5KGlucHV0KSxcbiAgICAgICAgICAgIGRhdGFUeXBlVGVzdCA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJyYXlUZXN0KSB7XG4gICAgICAgICAgICBkYXRhVHlwZVRlc3QgPVxuICAgICAgICAgICAgICAgIGlucHV0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzTnVtYmVyKGl0ZW0pICYmIGlzU3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9KS5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5VGVzdCAmJiBkYXRhVHlwZVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDYWxlbmRhclNwZWMoaW5wdXQpIHtcbiAgICAgICAgdmFyIG9iamVjdFRlc3QgPSBpc09iamVjdChpbnB1dCkgJiYgIWlzT2JqZWN0RW1wdHkoaW5wdXQpLFxuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gZmFsc2UsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gW1xuICAgICAgICAgICAgICAgICdzYW1lRGF5JyxcbiAgICAgICAgICAgICAgICAnbmV4dERheScsXG4gICAgICAgICAgICAgICAgJ2xhc3REYXknLFxuICAgICAgICAgICAgICAgICduZXh0V2VlaycsXG4gICAgICAgICAgICAgICAgJ2xhc3RXZWVrJyxcbiAgICAgICAgICAgICAgICAnc2FtZUVsc2UnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwcm9wZXJ0eTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gcHJvcGVydHlUZXN0IHx8IGhhc093blByb3AoaW5wdXQsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmplY3RUZXN0ICYmIHByb3BlcnR5VGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTZcbiAgICAgICAgICAgID8gJ3NhbWVFbHNlJ1xuICAgICAgICAgICAgOiBkaWZmIDwgLTFcbiAgICAgICAgICAgID8gJ2xhc3RXZWVrJ1xuICAgICAgICAgICAgOiBkaWZmIDwgMFxuICAgICAgICAgICAgPyAnbGFzdERheSdcbiAgICAgICAgICAgIDogZGlmZiA8IDFcbiAgICAgICAgICAgID8gJ3NhbWVEYXknXG4gICAgICAgICAgICA6IGRpZmYgPCAyXG4gICAgICAgICAgICA/ICduZXh0RGF5J1xuICAgICAgICAgICAgOiBkaWZmIDwgN1xuICAgICAgICAgICAgPyAnbmV4dFdlZWsnXG4gICAgICAgICAgICA6ICdzYW1lRWxzZSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsZW5kYXIkMSh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIHNpbmdsZSBwYXJhbWV0ZXIsIGZvcm1hdHMgb25seSBvdmVybG9hZCB0byB0aGUgY2FsZW5kYXIgZnVuY3Rpb25cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgdGltZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01vbWVudElucHV0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ2FsZW5kYXJTcGVjKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJyxcbiAgICAgICAgICAgIG91dHB1dCA9XG4gICAgICAgICAgICAgICAgZm9ybWF0cyAmJlxuICAgICAgICAgICAgICAgIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSlcbiAgICAgICAgICAgICAgICAgICAgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpXG4gICAgICAgICAgICAgICAgICAgIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoXG4gICAgICAgICAgICBvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4oZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgICAgICB2YXIgbG9jYWxGcm9tID0gaXNNb21lbnQoZnJvbSkgPyBmcm9tIDogY3JlYXRlTG9jYWwoZnJvbSksXG4gICAgICAgICAgICBsb2NhbFRvID0gaXNNb21lbnQodG8pID8gdG8gOiBjcmVhdGVMb2NhbCh0byk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsRnJvbS5pc1ZhbGlkKCkgJiYgbG9jYWxUby5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzBdID09PSAnKCdcbiAgICAgICAgICAgICAgICA/IHRoaXMuaXNBZnRlcihsb2NhbEZyb20sIHVuaXRzKVxuICAgICAgICAgICAgICAgIDogIXRoaXMuaXNCZWZvcmUobG9jYWxGcm9tLCB1bml0cykpICYmXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5pc0JlZm9yZShsb2NhbFRvLCB1bml0cylcbiAgICAgICAgICAgICAgICA6ICF0aGlzLmlzQWZ0ZXIobG9jYWxUbywgdW5pdHMpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZShpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmXG4gICAgICAgICAgICAgICAgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZihpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsIHpvbmVEZWx0YSwgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMWUzO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuZGF0ZSgpIDwgYi5kYXRlKCkpIHtcbiAgICAgICAgICAgIC8vIGVuZC1vZi1tb250aCBjYWxjdWxhdGlvbnMgd29yayBjb3JyZWN0IHdoZW4gdGhlIHN0YXJ0IG1vbnRoIGhhcyBtb3JlXG4gICAgICAgICAgICAvLyBkYXlzIHRoYW4gdGhlIGVuZCBtb250aC5cbiAgICAgICAgICAgIHJldHVybiAtbW9udGhEaWZmKGIsIGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9IChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICAgIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG4gICAgfVxuXG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmcoa2VlcE9mZnNldCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXRjID0ga2VlcE9mZnNldCAhPT0gdHJ1ZSxcbiAgICAgICAgICAgIG0gPSB1dGMgPyB0aGlzLmNsb25lKCkudXRjKCkgOiB0aGlzO1xuICAgICAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChcbiAgICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgICAgIHV0Y1xuICAgICAgICAgICAgICAgICAgICA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nXG4gICAgICAgICAgICAgICAgICAgIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgIGlmICh1dGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkgKyB0aGlzLnV0Y09mZnNldCgpICogNjAgKiAxMDAwKVxuICAgICAgICAgICAgICAgICAgICAudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnWicsIGZvcm1hdE1vbWVudChtLCAnWicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIHV0YyA/ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICAgICAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuYyA9ICdtb21lbnQnLFxuICAgICAgICAgICAgem9uZSA9ICcnLFxuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgeWVhcixcbiAgICAgICAgICAgIGRhdGV0aW1lLFxuICAgICAgICAgICAgc3VmZml4O1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgICAgIHpvbmUgPSAnWic7XG4gICAgICAgIH1cbiAgICAgICAgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICAgICAgeWVhciA9IDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgICAgICBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgICAgICBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQocHJlZml4ICsgeWVhciArIGRhdGV0aW1lICsgc3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKClcbiAgICAgICAgICAgICAgICA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGNcbiAgICAgICAgICAgICAgICA6IGhvb2tzLmRlZmF1bHRGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fCBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgdG86IHRoaXMsIGZyb206IHRpbWUgfSlcbiAgICAgICAgICAgICAgICAubG9jYWxlKHRoaXMubG9jYWxlKCkpXG4gICAgICAgICAgICAgICAgLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8odGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHwgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGZyb206IHRoaXMsIHRvOiB0aW1lIH0pXG4gICAgICAgICAgICAgICAgLmxvY2FsZSh0aGlzLmxvY2FsZSgpKVxuICAgICAgICAgICAgICAgIC5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93KHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgZnVuY3Rpb24gbG9jYWxlKGtleSkge1xuICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgTVNfUEVSX1NFQ09ORCA9IDEwMDAsXG4gICAgICAgIE1TX1BFUl9NSU5VVEUgPSA2MCAqIE1TX1BFUl9TRUNPTkQsXG4gICAgICAgIE1TX1BFUl9IT1VSID0gNjAgKiBNU19QRVJfTUlOVVRFLFxuICAgICAgICBNU19QRVJfNDAwX1lFQVJTID0gKDM2NSAqIDQwMCArIDk3KSAqIDI0ICogTVNfUEVSX0hPVVI7XG5cbiAgICAvLyBhY3R1YWwgbW9kdWxvIC0gaGFuZGxlcyBuZWdhdGl2ZSBudW1iZXJzIChmb3IgZGF0ZXMgYmVmb3JlIDE5NzApOlxuICAgIGZ1bmN0aW9uIG1vZCQxKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiAoKGRpdmlkZW5kICUgZGl2aXNvcikgKyBkaXZpc29yKSAlIGRpdmlzb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHksIG0sIGQpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHV0Y1N0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gRGF0ZS5VVEMgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSwgbSwgZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lLCBzdGFydE9mRGF0ZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCkgLSAodGhpcy5tb250aCgpICUgMyksXG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMShcbiAgICAgICAgICAgICAgICAgICAgdGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksXG4gICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lLCBzdGFydE9mRGF0ZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSArIDEsIDAsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPVxuICAgICAgICAgICAgICAgICAgICBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpIC0gKHRoaXMubW9udGgoKSAlIDMpICsgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkgKyAxLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkgKyA3XG4gICAgICAgICAgICAgICAgICAgICkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpICsgN1xuICAgICAgICAgICAgICAgICAgICApIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgKyAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPVxuICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUiAtXG4gICAgICAgICAgICAgICAgICAgIG1vZCQxKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksXG4gICAgICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUlxuICAgICAgICAgICAgICAgICAgICApIC1cbiAgICAgICAgICAgICAgICAgICAgMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX01JTlVURSAtIG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX1NFQ09ORCAtIG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbS55ZWFyKCksXG4gICAgICAgICAgICBtLm1vbnRoKCksXG4gICAgICAgICAgICBtLmRhdGUoKSxcbiAgICAgICAgICAgIG0uaG91cigpLFxuICAgICAgICAgICAgbS5taW51dGUoKSxcbiAgICAgICAgICAgIG0uc2Vjb25kKCksXG4gICAgICAgICAgICBtLm1pbGxpc2Vjb25kKCksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDIoKSB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdOJywgMCwgMCwgJ2VyYUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk4nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk4nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk5OJywgMCwgMCwgJ2VyYU5hbWUnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk5OTk4nLCAwLCAwLCAnZXJhTmFycm93Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneScsIDFdLCAneW8nLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eScsIDJdLCAwLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eXknLCAzXSwgMCwgJ2VyYVllYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneXl5eScsIDRdLCAwLCAnZXJhWWVhcicpO1xuXG4gICAgYWRkUmVnZXhUb2tlbignTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk4nLCBtYXRjaEVyYUFiYnIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ05OTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OTicsIG1hdGNoRXJhTmFtZSk7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OTk4nLCBtYXRjaEVyYU5hcnJvdyk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFxuICAgICAgICBbJ04nLCAnTk4nLCAnTk5OJywgJ05OTk4nLCAnTk5OTk4nXSxcbiAgICAgICAgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgdmFyIGVyYSA9IGNvbmZpZy5fbG9jYWxlLmVyYXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgICAgIGlmIChlcmEpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lcmEgPSBlcmE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRFcmEgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBhZGRSZWdleFRva2VuKCd5JywgbWF0Y2hVbnNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbigneXknLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5eXknLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5eXl5JywgbWF0Y2hVbnNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbigneW8nLCBtYXRjaEVyYVllYXJPcmRpbmFsKTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWyd5JywgJ3l5JywgJ3l5eScsICd5eXl5J10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWyd5byddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgaWYgKGNvbmZpZy5fbG9jYWxlLl9lcmFZZWFyT3JkaW5hbFJlZ2V4KSB7XG4gICAgICAgICAgICBtYXRjaCA9IGlucHV0Lm1hdGNoKGNvbmZpZy5fbG9jYWxlLl9lcmFZZWFyT3JkaW5hbFJlZ2V4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX2xvY2FsZS5lcmFZZWFyT3JkaW5hbFBhcnNlKSB7XG4gICAgICAgICAgICBhcnJheVtZRUFSXSA9IGNvbmZpZy5fbG9jYWxlLmVyYVllYXJPcmRpbmFsUGFyc2UoaW5wdXQsIG1hdGNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhcyhtLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLl9lcmFzIHx8IGdldExvY2FsZSgnZW4nKS5fZXJhcztcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gaG9va3MoZXJhc1tpXS5zaW5jZSkuc3RhcnRPZignZGF5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0uc2luY2UgPSBkYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgICAgICAgICBlcmFzW2ldLnVudGlsID0gK0luZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBob29rcyhlcmFzW2ldLnVudGlsKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0udW50aWwgPSBkYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVyYXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhc1BhcnNlKGVyYU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmVyYXMoKSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhYmJyLFxuICAgICAgICAgICAgbmFycm93O1xuICAgICAgICBlcmFOYW1lID0gZXJhTmFtZS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgbmFtZSA9IGVyYXNbaV0ubmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgYWJiciA9IGVyYXNbaV0uYWJici50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgbmFycm93ID0gZXJhc1tpXS5uYXJyb3cudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWJiciA9PT0gZXJhTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gZXJhTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OTk4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hcnJvdyA9PT0gZXJhTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChbbmFtZSwgYWJiciwgbmFycm93XS5pbmRleE9mKGVyYU5hbWUpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUVyYXNDb252ZXJ0WWVhcihlcmEsIHllYXIpIHtcbiAgICAgICAgdmFyIGRpciA9IGVyYS5zaW5jZSA8PSBlcmEudW50aWwgPyArMSA6IC0xO1xuICAgICAgICBpZiAoeWVhciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9va3MoZXJhLnNpbmNlKS55ZWFyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaG9va3MoZXJhLnNpbmNlKS55ZWFyKCkgKyAoeWVhciAtIGVyYS5vZmZzZXQpICogZGlyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhTmFtZSgpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFOYXJyb3coKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgaWYgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFycm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFycm93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYUFiYnIoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgaWYgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0uYWJicjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnVudGlsIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS5zaW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLmFiYnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhWWVhcigpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBkaXIgPSBlcmFzW2ldLnNpbmNlIDw9IGVyYXNbaV0udW50aWwgPyArMSA6IC0xO1xuXG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB8fFxuICAgICAgICAgICAgICAgIChlcmFzW2ldLnVudGlsIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS5zaW5jZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnllYXIoKSAtIGhvb2tzKGVyYXNbaV0uc2luY2UpLnllYXIoKSkgKiBkaXIgK1xuICAgICAgICAgICAgICAgICAgICBlcmFzW2ldLm9mZnNldFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJhc05hbWVSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzTmFtZVJlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVFcmFzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzTmFtZVJlZ2V4IDogdGhpcy5fZXJhc1JlZ2V4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVyYXNBYmJyUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfZXJhc0FiYnJSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlRXJhc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gdGhpcy5fZXJhc0FiYnJSZWdleCA6IHRoaXMuX2VyYXNSZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcmFzTmFycm93UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfZXJhc05hcnJvd1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVFcmFzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzTmFycm93UmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFBYmJyKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5lcmFzQWJiclJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYU5hbWUoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNOYW1lUmVnZXgoaXNTdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhTmFycm93KGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5lcmFzTmFycm93UmVnZXgoaXNTdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhWWVhck9yZGluYWwoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9lcmFZZWFyT3JkaW5hbFJlZ2V4IHx8IG1hdGNoVW5zaWduZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZUVyYXNQYXJzZSgpIHtcbiAgICAgICAgdmFyIGFiYnJQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIG5hbWVQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIG5hcnJvd1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuZXJhcygpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgbmFtZVBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFtZSkpO1xuICAgICAgICAgICAgYWJiclBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0uYWJicikpO1xuICAgICAgICAgICAgbmFycm93UGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYXJyb3cpKTtcblxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hbWUpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5hYmJyKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFycm93KSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lcmFzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX2VyYXNOYW1lUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBuYW1lUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fZXJhc0FiYnJSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGFiYnJQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9lcmFzTmFycm93UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIG5hcnJvd1BpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbih0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbiAgICB9XG5cbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrWWVhcicsIDEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla1llYXInLCAxKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0cnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdHRycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHJywgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHR0cnLCBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihcbiAgICAgICAgWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSxcbiAgICAgICAgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3lcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMuaXNvV2VlaygpLFxuICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KCksXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgNFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5JU09XZWVrWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMuaXNvV2Vla1llYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luV2Vla1llYXIoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy53ZWVrWWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGxcbiAgICAgICAgICAgID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpXG4gICAgICAgICAgICA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgKHRoaXMubW9udGgoKSAlIDMpKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHJldHVybiBpc1N0cmljdFxuICAgICAgICAgICAgPyBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2VcbiAgICAgICAgICAgIDogbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIoaW5wdXQpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhciA9XG4gICAgICAgICAgICBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1XG4gICAgICAgICAgICApICsgMTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZChpbnB1dCAtIGRheU9mWWVhciwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgfSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaWxsaXNlY29uZCcsIDE2KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1MnLCBtYXRjaDF0bzMsIG1hdGNoMSk7XG4gICAgYWRkUmVnZXhUb2tlbignU1MnLCBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG4gICAgdmFyIHRva2VuLCBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG5cbiAgICBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJicigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRab25lTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5hZGQgPSBhZGQ7XG4gICAgcHJvdG8uY2FsZW5kYXIgPSBjYWxlbmRhciQxO1xuICAgIHByb3RvLmNsb25lID0gY2xvbmU7XG4gICAgcHJvdG8uZGlmZiA9IGRpZmY7XG4gICAgcHJvdG8uZW5kT2YgPSBlbmRPZjtcbiAgICBwcm90by5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgcHJvdG8uZnJvbSA9IGZyb207XG4gICAgcHJvdG8uZnJvbU5vdyA9IGZyb21Ob3c7XG4gICAgcHJvdG8udG8gPSB0bztcbiAgICBwcm90by50b05vdyA9IHRvTm93O1xuICAgIHByb3RvLmdldCA9IHN0cmluZ0dldDtcbiAgICBwcm90by5pbnZhbGlkQXQgPSBpbnZhbGlkQXQ7XG4gICAgcHJvdG8uaXNBZnRlciA9IGlzQWZ0ZXI7XG4gICAgcHJvdG8uaXNCZWZvcmUgPSBpc0JlZm9yZTtcbiAgICBwcm90by5pc0JldHdlZW4gPSBpc0JldHdlZW47XG4gICAgcHJvdG8uaXNTYW1lID0gaXNTYW1lO1xuICAgIHByb3RvLmlzU2FtZU9yQWZ0ZXIgPSBpc1NhbWVPckFmdGVyO1xuICAgIHByb3RvLmlzU2FtZU9yQmVmb3JlID0gaXNTYW1lT3JCZWZvcmU7XG4gICAgcHJvdG8uaXNWYWxpZCA9IGlzVmFsaWQkMjtcbiAgICBwcm90by5sYW5nID0gbGFuZztcbiAgICBwcm90by5sb2NhbGUgPSBsb2NhbGU7XG4gICAgcHJvdG8ubG9jYWxlRGF0YSA9IGxvY2FsZURhdGE7XG4gICAgcHJvdG8ubWF4ID0gcHJvdG90eXBlTWF4O1xuICAgIHByb3RvLm1pbiA9IHByb3RvdHlwZU1pbjtcbiAgICBwcm90by5wYXJzaW5nRmxhZ3MgPSBwYXJzaW5nRmxhZ3M7XG4gICAgcHJvdG8uc2V0ID0gc3RyaW5nU2V0O1xuICAgIHByb3RvLnN0YXJ0T2YgPSBzdGFydE9mO1xuICAgIHByb3RvLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG4gICAgcHJvdG8udG9BcnJheSA9IHRvQXJyYXk7XG4gICAgcHJvdG8udG9PYmplY3QgPSB0b09iamVjdDtcbiAgICBwcm90by50b0RhdGUgPSB0b0RhdGU7XG4gICAgcHJvdG8udG9JU09TdHJpbmcgPSB0b0lTT1N0cmluZztcbiAgICBwcm90by5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLmZvciAhPSBudWxsKSB7XG4gICAgICAgIHByb3RvW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdNb21lbnQ8JyArIHRoaXMuZm9ybWF0KCkgKyAnPic7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHByb3RvLnRvSlNPTiA9IHRvSlNPTjtcbiAgICBwcm90by50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIHByb3RvLnVuaXggPSB1bml4O1xuICAgIHByb3RvLnZhbHVlT2YgPSB2YWx1ZU9mO1xuICAgIHByb3RvLmNyZWF0aW9uRGF0YSA9IGNyZWF0aW9uRGF0YTtcbiAgICBwcm90by5lcmFOYW1lID0gZ2V0RXJhTmFtZTtcbiAgICBwcm90by5lcmFOYXJyb3cgPSBnZXRFcmFOYXJyb3c7XG4gICAgcHJvdG8uZXJhQWJiciA9IGdldEVyYUFiYnI7XG4gICAgcHJvdG8uZXJhWWVhciA9IGdldEVyYVllYXI7XG4gICAgcHJvdG8ueWVhciA9IGdldFNldFllYXI7XG4gICAgcHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG4gICAgcHJvdG8ud2Vla1llYXIgPSBnZXRTZXRXZWVrWWVhcjtcbiAgICBwcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuICAgIHByb3RvLnF1YXJ0ZXIgPSBwcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG4gICAgcHJvdG8ubW9udGggPSBnZXRTZXRNb250aDtcbiAgICBwcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuICAgIHByb3RvLndlZWsgPSBwcm90by53ZWVrcyA9IGdldFNldFdlZWs7XG4gICAgcHJvdG8uaXNvV2VlayA9IHByb3RvLmlzb1dlZWtzID0gZ2V0U2V0SVNPV2VlaztcbiAgICBwcm90by53ZWVrc0luWWVhciA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIHByb3RvLndlZWtzSW5XZWVrWWVhciA9IGdldFdlZWtzSW5XZWVrWWVhcjtcbiAgICBwcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5JU09XZWVrWWVhciA9IGdldElTT1dlZWtzSW5JU09XZWVrWWVhcjtcbiAgICBwcm90by5kYXRlID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBwcm90by5kYXkgPSBwcm90by5kYXlzID0gZ2V0U2V0RGF5T2ZXZWVrO1xuICAgIHByb3RvLndlZWtkYXkgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG4gICAgcHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbiAgICBwcm90by5kYXlPZlllYXIgPSBnZXRTZXREYXlPZlllYXI7XG4gICAgcHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcbiAgICBwcm90by5taW51dGUgPSBwcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuICAgIHByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG4gICAgcHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBwcm90by51dGNPZmZzZXQgPSBnZXRTZXRPZmZzZXQ7XG4gICAgcHJvdG8udXRjID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgcHJvdG8ubG9jYWwgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIHByb3RvLnBhcnNlWm9uZSA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIHByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgcHJvdG8uaXNEU1QgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBwcm90by5pc0xvY2FsID0gaXNMb2NhbDtcbiAgICBwcm90by5pc1V0Y09mZnNldCA9IGlzVXRjT2Zmc2V0O1xuICAgIHByb3RvLmlzVXRjID0gaXNVdGM7XG4gICAgcHJvdG8uaXNVVEMgPSBpc1V0YztcbiAgICBwcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIHByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG4gICAgcHJvdG8uZGF0ZXMgPSBkZXByZWNhdGUoXG4gICAgICAgICdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsXG4gICAgICAgIGdldFNldERheU9mTW9udGhcbiAgICApO1xuICAgIHByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsXG4gICAgICAgIGdldFNldE1vbnRoXG4gICAgKTtcbiAgICBwcm90by55ZWFycyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLFxuICAgICAgICBnZXRTZXRZZWFyXG4gICAgKTtcbiAgICBwcm90by56b25lID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLFxuICAgICAgICBnZXRTZXRab25lXG4gICAgKTtcbiAgICBwcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoXG4gICAgICAgICdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJyxcbiAgICAgICAgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkXG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVuaXgoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5ab25lKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMS5jYWxlbmRhciA9IGNhbGVuZGFyO1xuICAgIHByb3RvJDEubG9uZ0RhdGVGb3JtYXQgPSBsb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90byQxLmludmFsaWREYXRlID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG8kMS5vcmRpbmFsID0gb3JkaW5hbDtcbiAgICBwcm90byQxLnByZXBhcnNlID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucG9zdGZvcm1hdCA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90byQxLnJlbGF0aXZlVGltZSA9IHJlbGF0aXZlVGltZTtcbiAgICBwcm90byQxLnBhc3RGdXR1cmUgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvJDEuc2V0ID0gc2V0O1xuICAgIHByb3RvJDEuZXJhcyA9IGxvY2FsZUVyYXM7XG4gICAgcHJvdG8kMS5lcmFzUGFyc2UgPSBsb2NhbGVFcmFzUGFyc2U7XG4gICAgcHJvdG8kMS5lcmFzQ29udmVydFllYXIgPSBsb2NhbGVFcmFzQ29udmVydFllYXI7XG4gICAgcHJvdG8kMS5lcmFzQWJiclJlZ2V4ID0gZXJhc0FiYnJSZWdleDtcbiAgICBwcm90byQxLmVyYXNOYW1lUmVnZXggPSBlcmFzTmFtZVJlZ2V4O1xuICAgIHByb3RvJDEuZXJhc05hcnJvd1JlZ2V4ID0gZXJhc05hcnJvd1JlZ2V4O1xuXG4gICAgcHJvdG8kMS5tb250aHMgPSBsb2NhbGVNb250aHM7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydCA9IGxvY2FsZU1vbnRoc1Nob3J0O1xuICAgIHByb3RvJDEubW9udGhzUGFyc2UgPSBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90byQxLm1vbnRoc1JlZ2V4ID0gbW9udGhzUmVnZXg7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydFJlZ2V4ID0gbW9udGhzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICBwcm90byQxLndlZWtkYXlzID0gbG9jYWxlV2Vla2RheXM7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pbiA9IGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydCA9IGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG8kMS53ZWVrZGF5c1BhcnNlID0gbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvJDEud2Vla2RheXNSZWdleCA9IHdlZWtkYXlzUmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0UmVnZXggPSB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ID0gd2Vla2RheXNNaW5SZWdleDtcblxuICAgIHByb3RvJDEuaXNQTSA9IGxvY2FsZUlzUE07XG4gICAgcHJvdG8kMS5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG4gICAgZnVuY3Rpb24gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICAvLyAoKVxuICAgIC8vICg1KVxuICAgIC8vIChmbXQsIDUpXG4gICAgLy8gKGZtdClcbiAgICAvLyAodHJ1ZSlcbiAgICAvLyAodHJ1ZSwgNSlcbiAgICAvLyAodHJ1ZSwgZm10LCA1KVxuICAgIC8vICh0cnVlLCBmbXQpXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlU29ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBsb2NhbGVTb3J0ZWQ7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpLFxuICAgICAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBvdXQgPSBbXTtcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRocyhmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0KGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5cyhsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNTaG9ydChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbihsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbiAgICB9XG5cbiAgICBnZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBlcmFzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2luY2U6ICcwMDAxLTAxLTAxJyxcbiAgICAgICAgICAgICAgICB1bnRpbDogK0luZmluaXR5LFxuICAgICAgICAgICAgICAgIG9mZnNldDogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQW5ubyBEb21pbmknLFxuICAgICAgICAgICAgICAgIG5hcnJvdzogJ0FEJyxcbiAgICAgICAgICAgICAgICBhYmJyOiAnQUQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzaW5jZTogJzAwMDAtMTItMzEnLFxuICAgICAgICAgICAgICAgIHVudGlsOiAtSW5maW5pdHksXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdCZWZvcmUgQ2hyaXN0JyxcbiAgICAgICAgICAgICAgICBuYXJyb3c6ICdCQycsXG4gICAgICAgICAgICAgICAgYWJicjogJ0JDJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9XG4gICAgICAgICAgICAgICAgICAgIHRvSW50KChudW1iZXIgJSAxMDApIC8gMTApID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICd0aCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYiA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnc3QnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ25kJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBiID09PSAzXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdyZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICBob29rcy5sYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLFxuICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGVcbiAgICApO1xuICAgIGhvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsXG4gICAgICAgIGdldExvY2FsZVxuICAgICk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gYWJzKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdGhpcy5fbW9udGhzID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgZGF0YS5tb250aHMgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QkMShkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgICAgICBkdXJhdGlvbi5fbW9udGhzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gYWRkJDEoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdCQxKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1YmJsZSgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzLFxuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzLFxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICAgICAgICBzZWNvbmRzLFxuICAgICAgICAgICAgbWludXRlcyxcbiAgICAgICAgICAgIGhvdXJzLFxuICAgICAgICAgICAgeWVhcnMsXG4gICAgICAgICAgICBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMClcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzID0gaG91cnMgJSAyNDtcblxuICAgICAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICAgICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgICAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cbiAgICAgICAgZGF0YS5kYXlzID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgPSB5ZWFycztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzVG9Nb250aHMoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gKGRheXMgKiA0ODAwKSAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMobW9udGhzKSB7XG4gICAgICAgIC8vIHRoZSByZXZlcnNlIG9mIGRheXNUb01vbnRoc1xuICAgICAgICByZXR1cm4gKG1vbnRocyAqIDE0NjA5NykgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzKHVuaXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheXMsXG4gICAgICAgICAgICBtb250aHMsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHM7XG4gICAgICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHMgLyAzO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzIC8gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAvIDcgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiAyNCArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiAxNDQwICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gdmFsdWVPZiQxKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcyhhbGlhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKSxcbiAgICAgICAgYXNTZWNvbmRzID0gbWFrZUFzKCdzJyksXG4gICAgICAgIGFzTWludXRlcyA9IG1ha2VBcygnbScpLFxuICAgICAgICBhc0hvdXJzID0gbWFrZUFzKCdoJyksXG4gICAgICAgIGFzRGF5cyA9IG1ha2VBcygnZCcpLFxuICAgICAgICBhc1dlZWtzID0gbWFrZUFzKCd3JyksXG4gICAgICAgIGFzTW9udGhzID0gbWFrZUFzKCdNJyksXG4gICAgICAgIGFzUXVhcnRlcnMgPSBtYWtlQXMoJ1EnKSxcbiAgICAgICAgYXNZZWFycyA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gY2xvbmUkMSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldCQyKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzW3VuaXRzICsgJ3MnXSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5fZGF0YVtuYW1lXSA6IE5hTjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyksXG4gICAgICAgIHNlY29uZHMgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyksXG4gICAgICAgIG1pbnV0ZXMgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyksXG4gICAgICAgIGhvdXJzID0gbWFrZUdldHRlcignaG91cnMnKSxcbiAgICAgICAgZGF5cyA9IG1ha2VHZXR0ZXIoJ2RheXMnKSxcbiAgICAgICAgbW9udGhzID0gbWFrZUdldHRlcignbW9udGhzJyksXG4gICAgICAgIHllYXJzID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgIGZ1bmN0aW9uIHdlZWtzKCkge1xuICAgICAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgICAgICB0aHJlc2hvbGRzID0ge1xuICAgICAgICAgICAgc3M6IDQ0LCAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcbiAgICAgICAgICAgIHM6IDQ1LCAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICAgICAgbTogNDUsIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICAgICAgaDogMjIsIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICAgICAgZDogMjYsIC8vIGRheXMgdG8gbW9udGgvd2Vla1xuICAgICAgICAgICAgdzogbnVsbCwgLy8gd2Vla3MgdG8gbW9udGhcbiAgICAgICAgICAgIE06IDExLCAvLyBtb250aHMgdG8geWVhclxuICAgICAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUkMShwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgdGhyZXNob2xkcywgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKSxcbiAgICAgICAgICAgIHNlY29uZHMgPSByb3VuZChkdXJhdGlvbi5hcygncycpKSxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKSxcbiAgICAgICAgICAgIGhvdXJzID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSksXG4gICAgICAgICAgICBkYXlzID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSksXG4gICAgICAgICAgICBtb250aHMgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKSxcbiAgICAgICAgICAgIHdlZWtzID0gcm91bmQoZHVyYXRpb24uYXMoJ3cnKSksXG4gICAgICAgICAgICB5ZWFycyA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpLFxuICAgICAgICAgICAgYSA9XG4gICAgICAgICAgICAgICAgKHNlY29uZHMgPD0gdGhyZXNob2xkcy5zcyAmJiBbJ3MnLCBzZWNvbmRzXSkgfHxcbiAgICAgICAgICAgICAgICAoc2Vjb25kcyA8IHRocmVzaG9sZHMucyAmJiBbJ3NzJywgc2Vjb25kc10pIHx8XG4gICAgICAgICAgICAgICAgKG1pbnV0ZXMgPD0gMSAmJiBbJ20nXSkgfHxcbiAgICAgICAgICAgICAgICAobWludXRlcyA8IHRocmVzaG9sZHMubSAmJiBbJ21tJywgbWludXRlc10pIHx8XG4gICAgICAgICAgICAgICAgKGhvdXJzIDw9IDEgJiYgWydoJ10pIHx8XG4gICAgICAgICAgICAgICAgKGhvdXJzIDwgdGhyZXNob2xkcy5oICYmIFsnaGgnLCBob3Vyc10pIHx8XG4gICAgICAgICAgICAgICAgKGRheXMgPD0gMSAmJiBbJ2QnXSkgfHxcbiAgICAgICAgICAgICAgICAoZGF5cyA8IHRocmVzaG9sZHMuZCAmJiBbJ2RkJywgZGF5c10pO1xuXG4gICAgICAgIGlmICh0aHJlc2hvbGRzLncgIT0gbnVsbCkge1xuICAgICAgICAgICAgYSA9XG4gICAgICAgICAgICAgICAgYSB8fFxuICAgICAgICAgICAgICAgICh3ZWVrcyA8PSAxICYmIFsndyddKSB8fFxuICAgICAgICAgICAgICAgICh3ZWVrcyA8IHRocmVzaG9sZHMudyAmJiBbJ3d3Jywgd2Vla3NdKTtcbiAgICAgICAgfVxuICAgICAgICBhID0gYSB8fFxuICAgICAgICAgICAgKG1vbnRocyA8PSAxICYmIFsnTSddKSB8fFxuICAgICAgICAgICAgKG1vbnRocyA8IHRocmVzaG9sZHMuTSAmJiBbJ01NJywgbW9udGhzXSkgfHxcbiAgICAgICAgICAgICh5ZWFycyA8PSAxICYmIFsneSddKSB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyhyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvdW5kaW5nRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJvdW5kID0gcm91bmRpbmdGdW5jdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplKGFyZ1dpdGhTdWZmaXgsIGFyZ1RocmVzaG9sZHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd2l0aFN1ZmZpeCA9IGZhbHNlLFxuICAgICAgICAgICAgdGggPSB0aHJlc2hvbGRzLFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnV2l0aFN1ZmZpeCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGFyZ1RocmVzaG9sZHMgPSBhcmdXaXRoU3VmZml4O1xuICAgICAgICAgICAgYXJnV2l0aFN1ZmZpeCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXJnV2l0aFN1ZmZpeCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB3aXRoU3VmZml4ID0gYXJnV2l0aFN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFyZ1RocmVzaG9sZHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aCA9IE9iamVjdC5hc3NpZ24oe30sIHRocmVzaG9sZHMsIGFyZ1RocmVzaG9sZHMpO1xuICAgICAgICAgICAgaWYgKGFyZ1RocmVzaG9sZHMucyAhPSBudWxsICYmIGFyZ1RocmVzaG9sZHMuc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoLnNzID0gYXJnVGhyZXNob2xkcy5zIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICBvdXRwdXQgPSByZWxhdGl2ZVRpbWUkMSh0aGlzLCAhd2l0aFN1ZmZpeCwgdGgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICAgICAgcmV0dXJuICh4ID4gMCkgLSAoeCA8IDApIHx8ICt4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nJDEoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWNvbmRzID0gYWJzJDEodGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDAsXG4gICAgICAgICAgICBkYXlzID0gYWJzJDEodGhpcy5fZGF5cyksXG4gICAgICAgICAgICBtb250aHMgPSBhYnMkMSh0aGlzLl9tb250aHMpLFxuICAgICAgICAgICAgbWludXRlcyxcbiAgICAgICAgICAgIGhvdXJzLFxuICAgICAgICAgICAgeWVhcnMsXG4gICAgICAgICAgICBzLFxuICAgICAgICAgICAgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpLFxuICAgICAgICAgICAgdG90YWxTaWduLFxuICAgICAgICAgICAgeW1TaWduLFxuICAgICAgICAgICAgZGF5c1NpZ24sXG4gICAgICAgICAgICBobXNTaWduO1xuXG4gICAgICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAnUDBEJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgaG91cnMgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBzZWNvbmRzICU9IDYwO1xuICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICBzID0gc2Vjb25kcyA/IHNlY29uZHMudG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpIDogJyc7XG5cbiAgICAgICAgdG90YWxTaWduID0gdG90YWwgPCAwID8gJy0nIDogJyc7XG4gICAgICAgIHltU2lnbiA9IHNpZ24odGhpcy5fbW9udGhzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgZGF5c1NpZ24gPSBzaWduKHRoaXMuX2RheXMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICBobXNTaWduID0gc2lnbih0aGlzLl9taWxsaXNlY29uZHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0b3RhbFNpZ24gK1xuICAgICAgICAgICAgJ1AnICtcbiAgICAgICAgICAgICh5ZWFycyA/IHltU2lnbiArIHllYXJzICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChtb250aHMgPyB5bVNpZ24gKyBtb250aHMgKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKGRheXMgPyBkYXlzU2lnbiArIGRheXMgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgKGhvdXJzIHx8IG1pbnV0ZXMgfHwgc2Vjb25kcyA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAoaG91cnMgPyBobXNTaWduICsgaG91cnMgKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgKG1pbnV0ZXMgPyBobXNTaWduICsgbWludXRlcyArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoc2Vjb25kcyA/IGhtc1NpZ24gKyBzICsgJ1MnIDogJycpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDIgPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBwcm90byQyLmlzVmFsaWQgPSBpc1ZhbGlkJDE7XG4gICAgcHJvdG8kMi5hYnMgPSBhYnM7XG4gICAgcHJvdG8kMi5hZGQgPSBhZGQkMTtcbiAgICBwcm90byQyLnN1YnRyYWN0ID0gc3VidHJhY3QkMTtcbiAgICBwcm90byQyLmFzID0gYXM7XG4gICAgcHJvdG8kMi5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuYXNTZWNvbmRzID0gYXNTZWNvbmRzO1xuICAgIHByb3RvJDIuYXNNaW51dGVzID0gYXNNaW51dGVzO1xuICAgIHByb3RvJDIuYXNIb3VycyA9IGFzSG91cnM7XG4gICAgcHJvdG8kMi5hc0RheXMgPSBhc0RheXM7XG4gICAgcHJvdG8kMi5hc1dlZWtzID0gYXNXZWVrcztcbiAgICBwcm90byQyLmFzTW9udGhzID0gYXNNb250aHM7XG4gICAgcHJvdG8kMi5hc1F1YXJ0ZXJzID0gYXNRdWFydGVycztcbiAgICBwcm90byQyLmFzWWVhcnMgPSBhc1llYXJzO1xuICAgIHByb3RvJDIudmFsdWVPZiA9IHZhbHVlT2YkMTtcbiAgICBwcm90byQyLl9idWJibGUgPSBidWJibGU7XG4gICAgcHJvdG8kMi5jbG9uZSA9IGNsb25lJDE7XG4gICAgcHJvdG8kMi5nZXQgPSBnZXQkMjtcbiAgICBwcm90byQyLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLnNlY29uZHMgPSBzZWNvbmRzO1xuICAgIHByb3RvJDIubWludXRlcyA9IG1pbnV0ZXM7XG4gICAgcHJvdG8kMi5ob3VycyA9IGhvdXJzO1xuICAgIHByb3RvJDIuZGF5cyA9IGRheXM7XG4gICAgcHJvdG8kMi53ZWVrcyA9IHdlZWtzO1xuICAgIHByb3RvJDIubW9udGhzID0gbW9udGhzO1xuICAgIHByb3RvJDIueWVhcnMgPSB5ZWFycztcbiAgICBwcm90byQyLmh1bWFuaXplID0gaHVtYW5pemU7XG4gICAgcHJvdG8kMi50b0lTT1N0cmluZyA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b1N0cmluZyA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b0pTT04gPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIubG9jYWxlID0gbG9jYWxlO1xuICAgIHByb3RvJDIubG9jYWxlRGF0YSA9IGxvY2FsZURhdGE7XG5cbiAgICBwcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLFxuICAgICAgICB0b0lTT1N0cmluZyQxXG4gICAgKTtcbiAgICBwcm90byQyLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQpICogMTAwMCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgIH0pO1xuXG4gICAgLy8hIG1vbWVudC5qc1xuXG4gICAgaG9va3MudmVyc2lvbiA9ICcyLjI5LjQnO1xuXG4gICAgc2V0SG9va0NhbGxiYWNrKGNyZWF0ZUxvY2FsKTtcblxuICAgIGhvb2tzLmZuID0gcHJvdG87XG4gICAgaG9va3MubWluID0gbWluO1xuICAgIGhvb2tzLm1heCA9IG1heDtcbiAgICBob29rcy5ub3cgPSBub3c7XG4gICAgaG9va3MudXRjID0gY3JlYXRlVVRDO1xuICAgIGhvb2tzLnVuaXggPSBjcmVhdGVVbml4O1xuICAgIGhvb2tzLm1vbnRocyA9IGxpc3RNb250aHM7XG4gICAgaG9va3MuaXNEYXRlID0gaXNEYXRlO1xuICAgIGhvb2tzLmxvY2FsZSA9IGdldFNldEdsb2JhbExvY2FsZTtcbiAgICBob29rcy5pbnZhbGlkID0gY3JlYXRlSW52YWxpZDtcbiAgICBob29rcy5kdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uO1xuICAgIGhvb2tzLmlzTW9tZW50ID0gaXNNb21lbnQ7XG4gICAgaG9va3Mud2Vla2RheXMgPSBsaXN0V2Vla2RheXM7XG4gICAgaG9va3MucGFyc2Vab25lID0gY3JlYXRlSW5ab25lO1xuICAgIGhvb2tzLmxvY2FsZURhdGEgPSBnZXRMb2NhbGU7XG4gICAgaG9va3MuaXNEdXJhdGlvbiA9IGlzRHVyYXRpb247XG4gICAgaG9va3MubW9udGhzU2hvcnQgPSBsaXN0TW9udGhzU2hvcnQ7XG4gICAgaG9va3Mud2Vla2RheXNNaW4gPSBsaXN0V2Vla2RheXNNaW47XG4gICAgaG9va3MuZGVmaW5lTG9jYWxlID0gZGVmaW5lTG9jYWxlO1xuICAgIGhvb2tzLnVwZGF0ZUxvY2FsZSA9IHVwZGF0ZUxvY2FsZTtcbiAgICBob29rcy5sb2NhbGVzID0gbGlzdExvY2FsZXM7XG4gICAgaG9va3Mud2Vla2RheXNTaG9ydCA9IGxpc3RXZWVrZGF5c1Nob3J0O1xuICAgIGhvb2tzLm5vcm1hbGl6ZVVuaXRzID0gbm9ybWFsaXplVW5pdHM7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lUm91bmRpbmcgPSBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG4gICAgaG9va3MuY2FsZW5kYXJGb3JtYXQgPSBnZXRDYWxlbmRhckZvcm1hdDtcbiAgICBob29rcy5wcm90b3R5cGUgPSBwcm90bztcblxuICAgIC8vIGN1cnJlbnRseSBIVE1MNSBpbnB1dCB0eXBlIG9ubHkgc3VwcG9ydHMgMjQtaG91ciBmb3JtYXRzXG4gICAgaG9va3MuSFRNTDVfRk1UID0ge1xuICAgICAgICBEQVRFVElNRV9MT0NBTDogJ1lZWVktTU0tRERUSEg6bW0nLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfU0VDT05EUzogJ1lZWVktTU0tRERUSEg6bW06c3MnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIERBVEU6ICdZWVlZLU1NLUREJywgLy8gPGlucHV0IHR5cGU9XCJkYXRlXCIgLz5cbiAgICAgICAgVElNRTogJ0hIOm1tJywgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgLz5cbiAgICAgICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIFRJTUVfTVM6ICdISDptbTpzcy5TU1MnLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBXRUVLOiAnR0dHRy1bV11XVycsIC8vIDxpbnB1dCB0eXBlPVwid2Vla1wiIC8+XG4gICAgICAgIE1PTlRIOiAnWVlZWS1NTScsIC8vIDxpbnB1dCB0eXBlPVwibW9udGhcIiAvPlxuICAgIH07XG5cbiAgICByZXR1cm4gaG9va3M7XG5cbn0pKSk7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJtb21lbnQiLCJob29rQ2FsbGJhY2siLCJob29rcyIsImFwcGx5IiwiYXJndW1lbnRzIiwic2V0SG9va0NhbGxiYWNrIiwiY2FsbGJhY2siLCJpc0FycmF5IiwiaW5wdXQiLCJBcnJheSIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImlzT2JqZWN0IiwiaGFzT3duUHJvcCIsImEiLCJiIiwiaGFzT3duUHJvcGVydHkiLCJpc09iamVjdEVtcHR5Iiwib2JqIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImxlbmd0aCIsImsiLCJpc1VuZGVmaW5lZCIsImlzTnVtYmVyIiwiaXNEYXRlIiwiRGF0ZSIsIm1hcCIsImFyciIsImZuIiwicmVzIiwiaSIsImFyckxlbiIsInB1c2giLCJleHRlbmQiLCJ2YWx1ZU9mIiwiY3JlYXRlVVRDIiwiZm9ybWF0IiwibG9jYWxlIiwic3RyaWN0IiwiY3JlYXRlTG9jYWxPclVUQyIsInV0YyIsImRlZmF1bHRQYXJzaW5nRmxhZ3MiLCJlbXB0eSIsInVudXNlZFRva2VucyIsInVudXNlZElucHV0Iiwib3ZlcmZsb3ciLCJjaGFyc0xlZnRPdmVyIiwibnVsbElucHV0IiwiaW52YWxpZEVyYSIsImludmFsaWRNb250aCIsImludmFsaWRGb3JtYXQiLCJ1c2VySW52YWxpZGF0ZWQiLCJpc28iLCJwYXJzZWREYXRlUGFydHMiLCJlcmEiLCJtZXJpZGllbSIsInJmYzI4MjIiLCJ3ZWVrZGF5TWlzbWF0Y2giLCJnZXRQYXJzaW5nRmxhZ3MiLCJtIiwiX3BmIiwic29tZSIsImZ1biIsInQiLCJsZW4iLCJpc1ZhbGlkIiwiX2lzVmFsaWQiLCJmbGFncyIsInBhcnNlZFBhcnRzIiwiaXNOb3dWYWxpZCIsImlzTmFOIiwiX2QiLCJnZXRUaW1lIiwiaW52YWxpZFdlZWtkYXkiLCJfc3RyaWN0IiwiYmlnSG91ciIsInVuZGVmaW5lZCIsImlzRnJvemVuIiwiY3JlYXRlSW52YWxpZCIsIk5hTiIsIm1vbWVudFByb3BlcnRpZXMiLCJ1cGRhdGVJblByb2dyZXNzIiwiY29weUNvbmZpZyIsInRvIiwiZnJvbSIsInByb3AiLCJ2YWwiLCJtb21lbnRQcm9wZXJ0aWVzTGVuIiwiX2lzQU1vbWVudE9iamVjdCIsIl9pIiwiX2YiLCJfbCIsIl90em0iLCJfaXNVVEMiLCJfb2Zmc2V0IiwiX2xvY2FsZSIsIk1vbWVudCIsImNvbmZpZyIsInVwZGF0ZU9mZnNldCIsImlzTW9tZW50Iiwid2FybiIsIm1zZyIsInN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyIsImNvbnNvbGUiLCJkZXByZWNhdGUiLCJmaXJzdFRpbWUiLCJkZXByZWNhdGlvbkhhbmRsZXIiLCJhcmdzIiwiYXJnIiwia2V5IiwiYXJnTGVuIiwic2xpY2UiLCJqb2luIiwiRXJyb3IiLCJzdGFjayIsImRlcHJlY2F0aW9ucyIsImRlcHJlY2F0ZVNpbXBsZSIsIm5hbWUiLCJpc0Z1bmN0aW9uIiwiRnVuY3Rpb24iLCJzZXQiLCJfY29uZmlnIiwiX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50IiwiUmVnRXhwIiwiX2RheU9mTW9udGhPcmRpbmFsUGFyc2UiLCJzb3VyY2UiLCJfb3JkaW5hbFBhcnNlIiwibWVyZ2VDb25maWdzIiwicGFyZW50Q29uZmlnIiwiY2hpbGRDb25maWciLCJMb2NhbGUiLCJrZXlzIiwiZGVmYXVsdENhbGVuZGFyIiwic2FtZURheSIsIm5leHREYXkiLCJuZXh0V2VlayIsImxhc3REYXkiLCJsYXN0V2VlayIsInNhbWVFbHNlIiwiY2FsZW5kYXIiLCJtb20iLCJub3ciLCJvdXRwdXQiLCJfY2FsZW5kYXIiLCJ6ZXJvRmlsbCIsIm51bWJlciIsInRhcmdldExlbmd0aCIsImZvcmNlU2lnbiIsImFic051bWJlciIsIk1hdGgiLCJhYnMiLCJ6ZXJvc1RvRmlsbCIsInNpZ24iLCJwb3ciLCJtYXgiLCJzdWJzdHIiLCJmb3JtYXR0aW5nVG9rZW5zIiwibG9jYWxGb3JtYXR0aW5nVG9rZW5zIiwiZm9ybWF0RnVuY3Rpb25zIiwiZm9ybWF0VG9rZW5GdW5jdGlvbnMiLCJhZGRGb3JtYXRUb2tlbiIsInRva2VuIiwicGFkZGVkIiwib3JkaW5hbCIsImZ1bmMiLCJsb2NhbGVEYXRhIiwicmVtb3ZlRm9ybWF0dGluZ1Rva2VucyIsIm1hdGNoIiwicmVwbGFjZSIsIm1ha2VGb3JtYXRGdW5jdGlvbiIsImFycmF5IiwiZm9ybWF0TW9tZW50IiwiaW52YWxpZERhdGUiLCJleHBhbmRGb3JtYXQiLCJyZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMiLCJsb25nRGF0ZUZvcm1hdCIsImxhc3RJbmRleCIsInRlc3QiLCJkZWZhdWx0TG9uZ0RhdGVGb3JtYXQiLCJMVFMiLCJMVCIsIkwiLCJMTCIsIkxMTCIsIkxMTEwiLCJfbG9uZ0RhdGVGb3JtYXQiLCJmb3JtYXRVcHBlciIsInRvVXBwZXJDYXNlIiwidG9rIiwiZGVmYXVsdEludmFsaWREYXRlIiwiX2ludmFsaWREYXRlIiwiZGVmYXVsdE9yZGluYWwiLCJkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSIsIl9vcmRpbmFsIiwiZGVmYXVsdFJlbGF0aXZlVGltZSIsImZ1dHVyZSIsInBhc3QiLCJzIiwic3MiLCJtbSIsImgiLCJoaCIsImQiLCJkZCIsInciLCJ3dyIsIk0iLCJNTSIsInkiLCJ5eSIsInJlbGF0aXZlVGltZSIsIndpdGhvdXRTdWZmaXgiLCJzdHJpbmciLCJpc0Z1dHVyZSIsIl9yZWxhdGl2ZVRpbWUiLCJwYXN0RnV0dXJlIiwiZGlmZiIsImFsaWFzZXMiLCJhZGRVbml0QWxpYXMiLCJ1bml0Iiwic2hvcnRoYW5kIiwibG93ZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJub3JtYWxpemVVbml0cyIsInVuaXRzIiwibm9ybWFsaXplT2JqZWN0VW5pdHMiLCJpbnB1dE9iamVjdCIsIm5vcm1hbGl6ZWRJbnB1dCIsIm5vcm1hbGl6ZWRQcm9wIiwicHJpb3JpdGllcyIsImFkZFVuaXRQcmlvcml0eSIsInByaW9yaXR5IiwiZ2V0UHJpb3JpdGl6ZWRVbml0cyIsInVuaXRzT2JqIiwidSIsInNvcnQiLCJpc0xlYXBZZWFyIiwieWVhciIsImFic0Zsb29yIiwiY2VpbCIsImZsb29yIiwidG9JbnQiLCJhcmd1bWVudEZvckNvZXJjaW9uIiwiY29lcmNlZE51bWJlciIsInZhbHVlIiwiaXNGaW5pdGUiLCJtYWtlR2V0U2V0Iiwia2VlcFRpbWUiLCJzZXQkMSIsImdldCIsIm1vbnRoIiwiZGF0ZSIsImRheXNJbk1vbnRoIiwic3RyaW5nR2V0Iiwic3RyaW5nU2V0IiwicHJpb3JpdGl6ZWQiLCJwcmlvcml0aXplZExlbiIsIm1hdGNoMSIsIm1hdGNoMiIsIm1hdGNoMyIsIm1hdGNoNCIsIm1hdGNoNiIsIm1hdGNoMXRvMiIsIm1hdGNoM3RvNCIsIm1hdGNoNXRvNiIsIm1hdGNoMXRvMyIsIm1hdGNoMXRvNCIsIm1hdGNoMXRvNiIsIm1hdGNoVW5zaWduZWQiLCJtYXRjaFNpZ25lZCIsIm1hdGNoT2Zmc2V0IiwibWF0Y2hTaG9ydE9mZnNldCIsIm1hdGNoVGltZXN0YW1wIiwibWF0Y2hXb3JkIiwicmVnZXhlcyIsImFkZFJlZ2V4VG9rZW4iLCJyZWdleCIsInN0cmljdFJlZ2V4IiwiaXNTdHJpY3QiLCJnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4iLCJ1bmVzY2FwZUZvcm1hdCIsInJlZ2V4RXNjYXBlIiwibWF0Y2hlZCIsInAxIiwicDIiLCJwMyIsInA0IiwidG9rZW5zIiwiYWRkUGFyc2VUb2tlbiIsInRva2VuTGVuIiwiYWRkV2Vla1BhcnNlVG9rZW4iLCJfdyIsImFkZFRpbWVUb0FycmF5RnJvbVRva2VuIiwiX2EiLCJZRUFSIiwiTU9OVEgiLCJEQVRFIiwiSE9VUiIsIk1JTlVURSIsIlNFQ09ORCIsIk1JTExJU0VDT05EIiwiV0VFSyIsIldFRUtEQVkiLCJtb2QiLCJuIiwieCIsImluZGV4T2YiLCJvIiwibW9kTW9udGgiLCJtb250aHNTaG9ydCIsIm1vbnRocyIsIm1vbnRoc1Nob3J0UmVnZXgiLCJtb250aHNSZWdleCIsIm1vbnRoc1BhcnNlIiwiZGVmYXVsdExvY2FsZU1vbnRocyIsInNwbGl0IiwiZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0IiwiTU9OVEhTX0lOX0ZPUk1BVCIsImRlZmF1bHRNb250aHNTaG9ydFJlZ2V4IiwiZGVmYXVsdE1vbnRoc1JlZ2V4IiwibG9jYWxlTW9udGhzIiwiX21vbnRocyIsImlzRm9ybWF0IiwibG9jYWxlTW9udGhzU2hvcnQiLCJfbW9udGhzU2hvcnQiLCJoYW5kbGVTdHJpY3RQYXJzZSIsIm1vbnRoTmFtZSIsImlpIiwibGxjIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJfbW9udGhzUGFyc2UiLCJfbG9uZ01vbnRoc1BhcnNlIiwiX3Nob3J0TW9udGhzUGFyc2UiLCJsb2NhbGVNb250aHNQYXJzZSIsIl9tb250aHNQYXJzZUV4YWN0Iiwic2V0TW9udGgiLCJkYXlPZk1vbnRoIiwibWluIiwiZ2V0U2V0TW9udGgiLCJnZXREYXlzSW5Nb250aCIsImNvbXB1dGVNb250aHNQYXJzZSIsIl9tb250aHNTaG9ydFN0cmljdFJlZ2V4IiwiX21vbnRoc1Nob3J0UmVnZXgiLCJfbW9udGhzU3RyaWN0UmVnZXgiLCJfbW9udGhzUmVnZXgiLCJjbXBMZW5SZXYiLCJzaG9ydFBpZWNlcyIsImxvbmdQaWVjZXMiLCJtaXhlZFBpZWNlcyIsInBhcnNlVHdvRGlnaXRZZWFyIiwicGFyc2VJbnQiLCJkYXlzSW5ZZWFyIiwiZ2V0U2V0WWVhciIsImdldElzTGVhcFllYXIiLCJjcmVhdGVEYXRlIiwibXMiLCJnZXRGdWxsWWVhciIsInNldEZ1bGxZZWFyIiwiY3JlYXRlVVRDRGF0ZSIsIlVUQyIsImdldFVUQ0Z1bGxZZWFyIiwic2V0VVRDRnVsbFllYXIiLCJmaXJzdFdlZWtPZmZzZXQiLCJkb3ciLCJkb3kiLCJmd2QiLCJmd2RsdyIsImdldFVUQ0RheSIsImRheU9mWWVhckZyb21XZWVrcyIsIndlZWsiLCJ3ZWVrZGF5IiwibG9jYWxXZWVrZGF5Iiwid2Vla09mZnNldCIsImRheU9mWWVhciIsInJlc1llYXIiLCJyZXNEYXlPZlllYXIiLCJ3ZWVrT2ZZZWFyIiwicmVzV2VlayIsIndlZWtzSW5ZZWFyIiwid2Vla09mZnNldE5leHQiLCJsb2NhbGVXZWVrIiwiX3dlZWsiLCJkZWZhdWx0TG9jYWxlV2VlayIsImxvY2FsZUZpcnN0RGF5T2ZXZWVrIiwibG9jYWxlRmlyc3REYXlPZlllYXIiLCJnZXRTZXRXZWVrIiwiYWRkIiwiZ2V0U2V0SVNPV2VlayIsIndlZWtkYXlzTWluIiwid2Vla2RheXNTaG9ydCIsIndlZWtkYXlzIiwid2Vla2RheXNNaW5SZWdleCIsIndlZWtkYXlzU2hvcnRSZWdleCIsIndlZWtkYXlzUmVnZXgiLCJ3ZWVrZGF5c1BhcnNlIiwicGFyc2VXZWVrZGF5IiwicGFyc2VJc29XZWVrZGF5Iiwic2hpZnRXZWVrZGF5cyIsIndzIiwiY29uY2F0IiwiZGVmYXVsdExvY2FsZVdlZWtkYXlzIiwiZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQiLCJkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4iLCJkZWZhdWx0V2Vla2RheXNSZWdleCIsImRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXgiLCJkZWZhdWx0V2Vla2RheXNNaW5SZWdleCIsImxvY2FsZVdlZWtkYXlzIiwiX3dlZWtkYXlzIiwiZGF5IiwibG9jYWxlV2Vla2RheXNTaG9ydCIsIl93ZWVrZGF5c1Nob3J0IiwibG9jYWxlV2Vla2RheXNNaW4iLCJfd2Vla2RheXNNaW4iLCJoYW5kbGVTdHJpY3RQYXJzZSQxIiwid2Vla2RheU5hbWUiLCJfd2Vla2RheXNQYXJzZSIsIl9zaG9ydFdlZWtkYXlzUGFyc2UiLCJfbWluV2Vla2RheXNQYXJzZSIsImxvY2FsZVdlZWtkYXlzUGFyc2UiLCJfd2Vla2RheXNQYXJzZUV4YWN0IiwiX2Z1bGxXZWVrZGF5c1BhcnNlIiwiZ2V0U2V0RGF5T2ZXZWVrIiwiZ2V0RGF5IiwiZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIiwiZ2V0U2V0SVNPRGF5T2ZXZWVrIiwiY29tcHV0ZVdlZWtkYXlzUGFyc2UiLCJfd2Vla2RheXNTdHJpY3RSZWdleCIsIl93ZWVrZGF5c1JlZ2V4IiwiX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCIsIl93ZWVrZGF5c1Nob3J0UmVnZXgiLCJfd2Vla2RheXNNaW5TdHJpY3RSZWdleCIsIl93ZWVrZGF5c01pblJlZ2V4IiwibWluUGllY2VzIiwibWlucCIsInNob3J0cCIsImxvbmdwIiwiaEZvcm1hdCIsImhvdXJzIiwia0Zvcm1hdCIsIm1pbnV0ZXMiLCJzZWNvbmRzIiwibG93ZXJjYXNlIiwibWF0Y2hNZXJpZGllbSIsIl9tZXJpZGllbVBhcnNlIiwia0lucHV0IiwiX2lzUG0iLCJpc1BNIiwiX21lcmlkaWVtIiwicG9zIiwicG9zMSIsInBvczIiLCJsb2NhbGVJc1BNIiwiY2hhckF0IiwiZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UiLCJnZXRTZXRIb3VyIiwibG9jYWxlTWVyaWRpZW0iLCJpc0xvd2VyIiwiYmFzZUNvbmZpZyIsImRheU9mTW9udGhPcmRpbmFsUGFyc2UiLCJtZXJpZGllbVBhcnNlIiwibG9jYWxlcyIsImxvY2FsZUZhbWlsaWVzIiwiZ2xvYmFsTG9jYWxlIiwiY29tbW9uUHJlZml4IiwiYXJyMSIsImFycjIiLCJtaW5sIiwibm9ybWFsaXplTG9jYWxlIiwiY2hvb3NlTG9jYWxlIiwibmFtZXMiLCJqIiwibmV4dCIsImxvYWRMb2NhbGUiLCJpc0xvY2FsZU5hbWVTYW5lIiwib2xkTG9jYWxlIiwiYWxpYXNlZFJlcXVpcmUiLCJfYWJiciIsInJlcXVpcmUiLCJnZXRTZXRHbG9iYWxMb2NhbGUiLCJlIiwidmFsdWVzIiwiZGF0YSIsImdldExvY2FsZSIsImRlZmluZUxvY2FsZSIsImFiYnIiLCJwYXJlbnRMb2NhbGUiLCJmb3JFYWNoIiwidXBkYXRlTG9jYWxlIiwidG1wTG9jYWxlIiwibGlzdExvY2FsZXMiLCJjaGVja092ZXJmbG93IiwiX292ZXJmbG93RGF5T2ZZZWFyIiwiX292ZXJmbG93V2Vla3MiLCJfb3ZlcmZsb3dXZWVrZGF5IiwiZXh0ZW5kZWRJc29SZWdleCIsImJhc2ljSXNvUmVnZXgiLCJ0elJlZ2V4IiwiaXNvRGF0ZXMiLCJpc29UaW1lcyIsImFzcE5ldEpzb25SZWdleCIsIm9ic09mZnNldHMiLCJVVCIsIkdNVCIsIkVEVCIsIkVTVCIsIkNEVCIsIkNTVCIsIk1EVCIsIk1TVCIsIlBEVCIsIlBTVCIsImNvbmZpZ0Zyb21JU08iLCJsIiwiZXhlYyIsImFsbG93VGltZSIsImRhdGVGb3JtYXQiLCJ0aW1lRm9ybWF0IiwidHpGb3JtYXQiLCJpc29EYXRlc0xlbiIsImlzb1RpbWVzTGVuIiwiY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCIsImV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MiLCJ5ZWFyU3RyIiwibW9udGhTdHIiLCJkYXlTdHIiLCJob3VyU3RyIiwibWludXRlU3RyIiwic2Vjb25kU3RyIiwicmVzdWx0IiwidW50cnVuY2F0ZVllYXIiLCJwcmVwcm9jZXNzUkZDMjgyMiIsImNoZWNrV2Vla2RheSIsIndlZWtkYXlTdHIiLCJwYXJzZWRJbnB1dCIsIndlZWtkYXlQcm92aWRlZCIsIndlZWtkYXlBY3R1YWwiLCJjYWxjdWxhdGVPZmZzZXQiLCJvYnNPZmZzZXQiLCJtaWxpdGFyeU9mZnNldCIsIm51bU9mZnNldCIsImhtIiwiY29uZmlnRnJvbVJGQzI4MjIiLCJwYXJzZWRBcnJheSIsInNldFVUQ01pbnV0ZXMiLCJnZXRVVENNaW51dGVzIiwiY29uZmlnRnJvbVN0cmluZyIsImNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrIiwiX3VzZVVUQyIsImRlZmF1bHRzIiwiYyIsImN1cnJlbnREYXRlQXJyYXkiLCJub3dWYWx1ZSIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRGF0ZSIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImNvbmZpZ0Zyb21BcnJheSIsImN1cnJlbnREYXRlIiwiZXhwZWN0ZWRXZWVrZGF5IiwieWVhclRvVXNlIiwiZGF5T2ZZZWFyRnJvbVdlZWtJbmZvIiwiX2RheU9mWWVhciIsIl9uZXh0RGF5Iiwid2Vla1llYXIiLCJ0ZW1wIiwid2Vla2RheU92ZXJmbG93IiwiY3VyV2VlayIsIkdHIiwiVyIsIkUiLCJjcmVhdGVMb2NhbCIsImdnIiwiSVNPXzg2MDEiLCJSRkNfMjgyMiIsInNraXBwZWQiLCJzdHJpbmdMZW5ndGgiLCJ0b3RhbFBhcnNlZElucHV0TGVuZ3RoIiwibWVyaWRpZW1GaXhXcmFwIiwiZXJhc0NvbnZlcnRZZWFyIiwiaG91ciIsImlzUG0iLCJtZXJpZGllbUhvdXIiLCJjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkiLCJ0ZW1wQ29uZmlnIiwiYmVzdE1vbWVudCIsInNjb3JlVG9CZWF0IiwiY3VycmVudFNjb3JlIiwidmFsaWRGb3JtYXRGb3VuZCIsImJlc3RGb3JtYXRJc1ZhbGlkIiwiY29uZmlnZkxlbiIsInNjb3JlIiwiY29uZmlnRnJvbU9iamVjdCIsImRheU9yRGF0ZSIsIm1pbnV0ZSIsInNlY29uZCIsIm1pbGxpc2Vjb25kIiwiY3JlYXRlRnJvbUNvbmZpZyIsInByZXBhcmVDb25maWciLCJwcmVwYXJzZSIsImNvbmZpZ0Zyb21JbnB1dCIsImlzVVRDIiwicHJvdG90eXBlTWluIiwib3RoZXIiLCJwcm90b3R5cGVNYXgiLCJwaWNrQnkiLCJtb21lbnRzIiwib3JkZXJpbmciLCJpc0R1cmF0aW9uVmFsaWQiLCJ1bml0SGFzRGVjaW1hbCIsIm9yZGVyTGVuIiwicGFyc2VGbG9hdCIsImlzVmFsaWQkMSIsImNyZWF0ZUludmFsaWQkMSIsImNyZWF0ZUR1cmF0aW9uIiwiRHVyYXRpb24iLCJkdXJhdGlvbiIsInllYXJzIiwicXVhcnRlcnMiLCJxdWFydGVyIiwid2Vla3MiLCJpc29XZWVrIiwiZGF5cyIsIm1pbGxpc2Vjb25kcyIsIl9taWxsaXNlY29uZHMiLCJfZGF5cyIsIl9kYXRhIiwiX2J1YmJsZSIsImlzRHVyYXRpb24iLCJhYnNSb3VuZCIsInJvdW5kIiwiY29tcGFyZUFycmF5cyIsImFycmF5MSIsImFycmF5MiIsImRvbnRDb252ZXJ0IiwibGVuZ3RoRGlmZiIsImRpZmZzIiwib2Zmc2V0Iiwic2VwYXJhdG9yIiwidXRjT2Zmc2V0Iiwib2Zmc2V0RnJvbVN0cmluZyIsImNodW5rT2Zmc2V0IiwibWF0Y2hlciIsIm1hdGNoZXMiLCJjaHVuayIsInBhcnRzIiwiY2xvbmVXaXRoT2Zmc2V0IiwibW9kZWwiLCJjbG9uZSIsInNldFRpbWUiLCJsb2NhbCIsImdldERhdGVPZmZzZXQiLCJnZXRUaW1lem9uZU9mZnNldCIsImdldFNldE9mZnNldCIsImtlZXBMb2NhbFRpbWUiLCJrZWVwTWludXRlcyIsImxvY2FsQWRqdXN0IiwiX2NoYW5nZUluUHJvZ3Jlc3MiLCJhZGRTdWJ0cmFjdCIsImdldFNldFpvbmUiLCJzZXRPZmZzZXRUb1VUQyIsInNldE9mZnNldFRvTG9jYWwiLCJzdWJ0cmFjdCIsInNldE9mZnNldFRvUGFyc2VkT2Zmc2V0IiwidFpvbmUiLCJoYXNBbGlnbmVkSG91ck9mZnNldCIsImlzRGF5bGlnaHRTYXZpbmdUaW1lIiwiaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkIiwiX2lzRFNUU2hpZnRlZCIsInRvQXJyYXkiLCJpc0xvY2FsIiwiaXNVdGNPZmZzZXQiLCJpc1V0YyIsImFzcE5ldFJlZ2V4IiwiaXNvUmVnZXgiLCJyZXQiLCJkaWZmUmVzIiwicGFyc2VJc28iLCJtb21lbnRzRGlmZmVyZW5jZSIsImludmFsaWQiLCJpbnAiLCJwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlIiwiYmFzZSIsImlzQWZ0ZXIiLCJpc0JlZm9yZSIsImNyZWF0ZUFkZGVyIiwiZGlyZWN0aW9uIiwicGVyaW9kIiwiZHVyIiwidG1wIiwiaXNBZGRpbmciLCJpc1N0cmluZyIsIlN0cmluZyIsImlzTW9tZW50SW5wdXQiLCJpc051bWJlck9yU3RyaW5nQXJyYXkiLCJpc01vbWVudElucHV0T2JqZWN0Iiwib2JqZWN0VGVzdCIsInByb3BlcnR5VGVzdCIsInByb3BlcnRpZXMiLCJwcm9wZXJ0eSIsInByb3BlcnR5TGVuIiwiYXJyYXlUZXN0IiwiZGF0YVR5cGVUZXN0IiwiZmlsdGVyIiwiaXRlbSIsImlzQ2FsZW5kYXJTcGVjIiwiZ2V0Q2FsZW5kYXJGb3JtYXQiLCJteU1vbWVudCIsImNhbGVuZGFyJDEiLCJ0aW1lIiwiZm9ybWF0cyIsInNvZCIsInN0YXJ0T2YiLCJjYWxlbmRhckZvcm1hdCIsImxvY2FsSW5wdXQiLCJlbmRPZiIsImlzQmV0d2VlbiIsImluY2x1c2l2aXR5IiwibG9jYWxGcm9tIiwibG9jYWxUbyIsImlzU2FtZSIsImlucHV0TXMiLCJpc1NhbWVPckFmdGVyIiwiaXNTYW1lT3JCZWZvcmUiLCJhc0Zsb2F0IiwidGhhdCIsInpvbmVEZWx0YSIsIm1vbnRoRGlmZiIsIndob2xlTW9udGhEaWZmIiwiYW5jaG9yIiwiYW5jaG9yMiIsImFkanVzdCIsImRlZmF1bHRGb3JtYXQiLCJkZWZhdWx0Rm9ybWF0VXRjIiwidG9JU09TdHJpbmciLCJrZWVwT2Zmc2V0IiwidG9EYXRlIiwiaW5zcGVjdCIsInpvbmUiLCJwcmVmaXgiLCJkYXRldGltZSIsInN1ZmZpeCIsImlucHV0U3RyaW5nIiwicG9zdGZvcm1hdCIsImh1bWFuaXplIiwiZnJvbU5vdyIsInRvTm93IiwibmV3TG9jYWxlRGF0YSIsImxhbmciLCJNU19QRVJfU0VDT05EIiwiTVNfUEVSX01JTlVURSIsIk1TX1BFUl9IT1VSIiwiTVNfUEVSXzQwMF9ZRUFSUyIsIm1vZCQxIiwiZGl2aWRlbmQiLCJkaXZpc29yIiwibG9jYWxTdGFydE9mRGF0ZSIsInV0Y1N0YXJ0T2ZEYXRlIiwic3RhcnRPZkRhdGUiLCJpc29XZWVrZGF5IiwidW5peCIsInRvT2JqZWN0IiwidG9KU09OIiwiaXNWYWxpZCQyIiwicGFyc2luZ0ZsYWdzIiwiaW52YWxpZEF0IiwiY3JlYXRpb25EYXRhIiwibWF0Y2hFcmFBYmJyIiwibWF0Y2hFcmFOYW1lIiwibWF0Y2hFcmFOYXJyb3ciLCJlcmFzUGFyc2UiLCJtYXRjaEVyYVllYXJPcmRpbmFsIiwiX2VyYVllYXJPcmRpbmFsUmVnZXgiLCJlcmFZZWFyT3JkaW5hbFBhcnNlIiwibG9jYWxlRXJhcyIsImVyYXMiLCJfZXJhcyIsInNpbmNlIiwidW50aWwiLCJJbmZpbml0eSIsImxvY2FsZUVyYXNQYXJzZSIsImVyYU5hbWUiLCJuYXJyb3ciLCJsb2NhbGVFcmFzQ29udmVydFllYXIiLCJkaXIiLCJnZXRFcmFOYW1lIiwiZ2V0RXJhTmFycm93IiwiZ2V0RXJhQWJiciIsImdldEVyYVllYXIiLCJlcmFzTmFtZVJlZ2V4IiwiY29tcHV0ZUVyYXNQYXJzZSIsIl9lcmFzTmFtZVJlZ2V4IiwiX2VyYXNSZWdleCIsImVyYXNBYmJyUmVnZXgiLCJfZXJhc0FiYnJSZWdleCIsImVyYXNOYXJyb3dSZWdleCIsIl9lcmFzTmFycm93UmVnZXgiLCJhYmJyUGllY2VzIiwibmFtZVBpZWNlcyIsIm5hcnJvd1BpZWNlcyIsImlzb1dlZWtZZWFyIiwiYWRkV2Vla1llYXJGb3JtYXRUb2tlbiIsImdldHRlciIsImdldFNldFdlZWtZZWFyIiwiZ2V0U2V0V2Vla1llYXJIZWxwZXIiLCJnZXRTZXRJU09XZWVrWWVhciIsImdldElTT1dlZWtzSW5ZZWFyIiwiZ2V0SVNPV2Vla3NJbklTT1dlZWtZZWFyIiwiZ2V0V2Vla3NJblllYXIiLCJ3ZWVrSW5mbyIsImdldFdlZWtzSW5XZWVrWWVhciIsIndlZWtzVGFyZ2V0Iiwic2V0V2Vla0FsbCIsImRheU9mWWVhckRhdGEiLCJnZXRTZXRRdWFydGVyIiwiZ2V0U2V0RGF5T2ZNb250aCIsImdldFNldERheU9mWWVhciIsImdldFNldE1pbnV0ZSIsImdldFNldFNlY29uZCIsImdldFNldE1pbGxpc2Vjb25kIiwicGFyc2VNcyIsImdldFpvbmVBYmJyIiwiZ2V0Wm9uZU5hbWUiLCJwcm90byIsIlN5bWJvbCIsImZvciIsImVyYU5hcnJvdyIsImVyYUFiYnIiLCJlcmFZZWFyIiwiaXNvV2Vla3MiLCJ3ZWVrc0luV2Vla1llYXIiLCJpc29XZWVrc0luWWVhciIsImlzb1dlZWtzSW5JU09XZWVrWWVhciIsInBhcnNlWm9uZSIsImlzRFNUIiwiem9uZUFiYnIiLCJ6b25lTmFtZSIsImRhdGVzIiwiaXNEU1RTaGlmdGVkIiwiY3JlYXRlVW5peCIsImNyZWF0ZUluWm9uZSIsInByZVBhcnNlUG9zdEZvcm1hdCIsInByb3RvJDEiLCJmaXJzdERheU9mWWVhciIsImZpcnN0RGF5T2ZXZWVrIiwiZ2V0JDEiLCJpbmRleCIsImZpZWxkIiwic2V0dGVyIiwibGlzdE1vbnRoc0ltcGwiLCJvdXQiLCJsaXN0V2Vla2RheXNJbXBsIiwibG9jYWxlU29ydGVkIiwic2hpZnQiLCJsaXN0TW9udGhzIiwibGlzdE1vbnRoc1Nob3J0IiwibGlzdFdlZWtkYXlzIiwibGlzdFdlZWtkYXlzU2hvcnQiLCJsaXN0V2Vla2RheXNNaW4iLCJsYW5nRGF0YSIsIm1hdGhBYnMiLCJhZGRTdWJ0cmFjdCQxIiwiYWRkJDEiLCJzdWJ0cmFjdCQxIiwiYWJzQ2VpbCIsImJ1YmJsZSIsIm1vbnRoc0Zyb21EYXlzIiwibW9udGhzVG9EYXlzIiwiZGF5c1RvTW9udGhzIiwiYXMiLCJ2YWx1ZU9mJDEiLCJtYWtlQXMiLCJhbGlhcyIsImFzTWlsbGlzZWNvbmRzIiwiYXNTZWNvbmRzIiwiYXNNaW51dGVzIiwiYXNIb3VycyIsImFzRGF5cyIsImFzV2Vla3MiLCJhc01vbnRocyIsImFzUXVhcnRlcnMiLCJhc1llYXJzIiwiY2xvbmUkMSIsImdldCQyIiwibWFrZUdldHRlciIsInRocmVzaG9sZHMiLCJzdWJzdGl0dXRlVGltZUFnbyIsInJlbGF0aXZlVGltZSQxIiwicG9zTmVnRHVyYXRpb24iLCJnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyIsInJvdW5kaW5nRnVuY3Rpb24iLCJnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQiLCJ0aHJlc2hvbGQiLCJsaW1pdCIsImFyZ1dpdGhTdWZmaXgiLCJhcmdUaHJlc2hvbGRzIiwid2l0aFN1ZmZpeCIsInRoIiwiYXNzaWduIiwiYWJzJDEiLCJ0b0lTT1N0cmluZyQxIiwidG90YWwiLCJ0b3RhbFNpZ24iLCJ5bVNpZ24iLCJkYXlzU2lnbiIsImhtc1NpZ24iLCJ0b0ZpeGVkIiwicHJvdG8kMiIsInRvSXNvU3RyaW5nIiwidmVyc2lvbiIsInJlbGF0aXZlVGltZVJvdW5kaW5nIiwicmVsYXRpdmVUaW1lVGhyZXNob2xkIiwiSFRNTDVfRk1UIiwiREFURVRJTUVfTE9DQUwiLCJEQVRFVElNRV9MT0NBTF9TRUNPTkRTIiwiREFURVRJTUVfTE9DQUxfTVMiLCJUSU1FIiwiVElNRV9TRUNPTkRTIiwiVElNRV9NUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/moment/moment.js\n");

/***/ })

};
;