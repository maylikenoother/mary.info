"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate";
exports.ids = ["vendor-chunks/slate"];
exports.modules = {

/***/ "(ssr)/./node_modules/slate/dist/index.es.js":
/*!*********************************************!*\
  !*** ./node_modules/slate/dist/index.es.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   Location: () => (/* binding */ Location),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   Operation: () => (/* binding */ Operation),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   PathRef: () => (/* binding */ PathRef),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   PointRef: () => (/* binding */ PointRef),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RangeRef: () => (/* binding */ RangeRef),\n/* harmony export */   Scrubber: () => (/* binding */ Scrubber),\n/* harmony export */   Span: () => (/* binding */ Span),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   Transforms: () => (/* binding */ Transforms),\n/* harmony export */   above: () => (/* binding */ above),\n/* harmony export */   addMark: () => (/* binding */ addMark),\n/* harmony export */   after: () => (/* binding */ after),\n/* harmony export */   apply: () => (/* binding */ apply),\n/* harmony export */   before: () => (/* binding */ before),\n/* harmony export */   collapse: () => (/* binding */ collapse),\n/* harmony export */   createEditor: () => (/* binding */ createEditor),\n/* harmony export */   deleteBackward: () => (/* binding */ deleteBackward),\n/* harmony export */   deleteForward: () => (/* binding */ deleteForward),\n/* harmony export */   deleteFragment: () => (/* binding */ deleteFragment),\n/* harmony export */   deleteText: () => (/* binding */ deleteText),\n/* harmony export */   deselect: () => (/* binding */ deselect),\n/* harmony export */   edges: () => (/* binding */ edges),\n/* harmony export */   elementReadOnly: () => (/* binding */ elementReadOnly),\n/* harmony export */   end: () => (/* binding */ end),\n/* harmony export */   first: () => (/* binding */ first),\n/* harmony export */   fragment: () => (/* binding */ fragment),\n/* harmony export */   getDirtyPaths: () => (/* binding */ getDirtyPaths),\n/* harmony export */   getFragment: () => (/* binding */ getFragment),\n/* harmony export */   getVoid: () => (/* binding */ getVoid),\n/* harmony export */   hasBlocks: () => (/* binding */ hasBlocks),\n/* harmony export */   hasInlines: () => (/* binding */ hasInlines),\n/* harmony export */   hasPath: () => (/* binding */ hasPath),\n/* harmony export */   hasTexts: () => (/* binding */ hasTexts),\n/* harmony export */   insertBreak: () => (/* binding */ insertBreak),\n/* harmony export */   insertFragment: () => (/* binding */ insertFragment),\n/* harmony export */   insertNode: () => (/* binding */ insertNode),\n/* harmony export */   insertNodes: () => (/* binding */ insertNodes),\n/* harmony export */   insertSoftBreak: () => (/* binding */ insertSoftBreak),\n/* harmony export */   insertText: () => (/* binding */ insertText),\n/* harmony export */   isBlock: () => (/* binding */ isBlock),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isEditor: () => (/* binding */ isEditor),\n/* harmony export */   isEmpty: () => (/* binding */ isEmpty),\n/* harmony export */   isEnd: () => (/* binding */ isEnd),\n/* harmony export */   isNormalizing: () => (/* binding */ isNormalizing),\n/* harmony export */   isStart: () => (/* binding */ isStart),\n/* harmony export */   last: () => (/* binding */ last),\n/* harmony export */   leaf: () => (/* binding */ leaf),\n/* harmony export */   levels: () => (/* binding */ levels),\n/* harmony export */   liftNodes: () => (/* binding */ liftNodes),\n/* harmony export */   marks: () => (/* binding */ marks),\n/* harmony export */   mergeNodes: () => (/* binding */ mergeNodes),\n/* harmony export */   move: () => (/* binding */ move),\n/* harmony export */   moveNodes: () => (/* binding */ moveNodes),\n/* harmony export */   next: () => (/* binding */ next),\n/* harmony export */   node: () => (/* binding */ node),\n/* harmony export */   nodes: () => (/* binding */ nodes),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   normalizeNode: () => (/* binding */ normalizeNode),\n/* harmony export */   parent: () => (/* binding */ parent),\n/* harmony export */   path: () => (/* binding */ path),\n/* harmony export */   pathRef: () => (/* binding */ pathRef),\n/* harmony export */   pathRefs: () => (/* binding */ pathRefs),\n/* harmony export */   point: () => (/* binding */ point),\n/* harmony export */   pointRef: () => (/* binding */ pointRef),\n/* harmony export */   pointRefs: () => (/* binding */ pointRefs),\n/* harmony export */   positions: () => (/* binding */ positions),\n/* harmony export */   previous: () => (/* binding */ previous),\n/* harmony export */   range: () => (/* binding */ range),\n/* harmony export */   rangeRef: () => (/* binding */ rangeRef),\n/* harmony export */   rangeRefs: () => (/* binding */ rangeRefs),\n/* harmony export */   removeMark: () => (/* binding */ removeMark),\n/* harmony export */   removeNodes: () => (/* binding */ removeNodes),\n/* harmony export */   select: () => (/* binding */ select),\n/* harmony export */   setNodes: () => (/* binding */ setNodes),\n/* harmony export */   setNormalizing: () => (/* binding */ setNormalizing),\n/* harmony export */   setPoint: () => (/* binding */ setPoint),\n/* harmony export */   setSelection: () => (/* binding */ setSelection),\n/* harmony export */   shouldNormalize: () => (/* binding */ shouldNormalize),\n/* harmony export */   splitNodes: () => (/* binding */ splitNodes),\n/* harmony export */   start: () => (/* binding */ start),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   unhangRange: () => (/* binding */ unhangRange),\n/* harmony export */   unsetNodes: () => (/* binding */ unsetNodes),\n/* harmony export */   unwrapNodes: () => (/* binding */ unwrapNodes),\n/* harmony export */   withoutNormalizing: () => (/* binding */ withoutNormalizing),\n/* harmony export */   wrapNodes: () => (/* binding */ wrapNodes)\n/* harmony export */ });\n/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ \"(ssr)/./node_modules/is-plain-object/dist/is-plain-object.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.mjs\");\n\n\n// eslint-disable-next-line no-redeclare\nvar PathRef = {\n    transform (ref, op) {\n        var { current, affinity } = ref;\n        if (current == null) {\n            return;\n        }\n        var path = Path.transform(current, op, {\n            affinity\n        });\n        ref.current = path;\n        if (path == null) {\n            ref.unref();\n        }\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar PointRef = {\n    transform (ref, op) {\n        var { current, affinity } = ref;\n        if (current == null) {\n            return;\n        }\n        var point = Point.transform(current, op, {\n            affinity\n        });\n        ref.current = point;\n        if (point == null) {\n            ref.unref();\n        }\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar RangeRef = {\n    transform (ref, op) {\n        var { current, affinity } = ref;\n        if (current == null) {\n            return;\n        }\n        var path = Range.transform(current, op, {\n            affinity\n        });\n        ref.current = path;\n        if (path == null) {\n            ref.unref();\n        }\n    }\n};\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n// eslint-disable-next-line no-redeclare\nvar Path = {\n    ancestors (path) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { reverse = false } = options;\n        var paths = Path.levels(path, options);\n        if (reverse) {\n            paths = paths.slice(1);\n        } else {\n            paths = paths.slice(0, -1);\n        }\n        return paths;\n    },\n    common (path, another) {\n        var common = [];\n        for(var i = 0; i < path.length && i < another.length; i++){\n            var av = path[i];\n            var bv = another[i];\n            if (av !== bv) {\n                break;\n            }\n            common.push(av);\n        }\n        return common;\n    },\n    compare (path, another) {\n        var min = Math.min(path.length, another.length);\n        for(var i = 0; i < min; i++){\n            if (path[i] < another[i]) return -1;\n            if (path[i] > another[i]) return 1;\n        }\n        return 0;\n    },\n    endsAfter (path, another) {\n        var i = path.length - 1;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        var av = path[i];\n        var bv = another[i];\n        return Path.equals(as, bs) && av > bv;\n    },\n    endsAt (path, another) {\n        var i = path.length;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        return Path.equals(as, bs);\n    },\n    endsBefore (path, another) {\n        var i = path.length - 1;\n        var as = path.slice(0, i);\n        var bs = another.slice(0, i);\n        var av = path[i];\n        var bv = another[i];\n        return Path.equals(as, bs) && av < bv;\n    },\n    equals (path, another) {\n        return path.length === another.length && path.every((n, i)=>n === another[i]);\n    },\n    hasPrevious (path) {\n        return path[path.length - 1] > 0;\n    },\n    isAfter (path, another) {\n        return Path.compare(path, another) === 1;\n    },\n    isAncestor (path, another) {\n        return path.length < another.length && Path.compare(path, another) === 0;\n    },\n    isBefore (path, another) {\n        return Path.compare(path, another) === -1;\n    },\n    isChild (path, another) {\n        return path.length === another.length + 1 && Path.compare(path, another) === 0;\n    },\n    isCommon (path, another) {\n        return path.length <= another.length && Path.compare(path, another) === 0;\n    },\n    isDescendant (path, another) {\n        return path.length > another.length && Path.compare(path, another) === 0;\n    },\n    isParent (path, another) {\n        return path.length + 1 === another.length && Path.compare(path, another) === 0;\n    },\n    isPath (value) {\n        return Array.isArray(value) && (value.length === 0 || typeof value[0] === \"number\");\n    },\n    isSibling (path, another) {\n        if (path.length !== another.length) {\n            return false;\n        }\n        var as = path.slice(0, -1);\n        var bs = another.slice(0, -1);\n        var al = path[path.length - 1];\n        var bl = another[another.length - 1];\n        return al !== bl && Path.equals(as, bs);\n    },\n    levels (path) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { reverse = false } = options;\n        var list = [];\n        for(var i = 0; i <= path.length; i++){\n            list.push(path.slice(0, i));\n        }\n        if (reverse) {\n            list.reverse();\n        }\n        return list;\n    },\n    next (path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n        }\n        var last = path[path.length - 1];\n        return path.slice(0, -1).concat(last + 1);\n    },\n    operationCanTransformPath (operation) {\n        switch(operation.type){\n            case \"insert_node\":\n            case \"remove_node\":\n            case \"merge_node\":\n            case \"split_node\":\n            case \"move_node\":\n                return true;\n            default:\n                return false;\n        }\n    },\n    parent (path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n        }\n        return path.slice(0, -1);\n    },\n    previous (path) {\n        if (path.length === 0) {\n            throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n        }\n        var last = path[path.length - 1];\n        if (last <= 0) {\n            throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n        }\n        return path.slice(0, -1).concat(last - 1);\n    },\n    relative (path, ancestor) {\n        if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n            throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n        }\n        return path.slice(ancestor.length);\n    },\n    transform (path, operation) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        if (!path) return null;\n        // PERF: use destructing instead of immer\n        var p = [\n            ...path\n        ];\n        var { affinity = \"forward\" } = options;\n        // PERF: Exit early if the operation is guaranteed not to have an effect.\n        if (path.length === 0) {\n            return p;\n        }\n        switch(operation.type){\n            case \"insert_node\":\n                {\n                    var { path: op } = operation;\n                    if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n                        p[op.length - 1] += 1;\n                    }\n                    break;\n                }\n            case \"remove_node\":\n                {\n                    var { path: _op } = operation;\n                    if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n                        return null;\n                    } else if (Path.endsBefore(_op, p)) {\n                        p[_op.length - 1] -= 1;\n                    }\n                    break;\n                }\n            case \"merge_node\":\n                {\n                    var { path: _op2, position } = operation;\n                    if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n                        p[_op2.length - 1] -= 1;\n                    } else if (Path.isAncestor(_op2, p)) {\n                        p[_op2.length - 1] -= 1;\n                        p[_op2.length] += position;\n                    }\n                    break;\n                }\n            case \"split_node\":\n                {\n                    var { path: _op3, position: _position } = operation;\n                    if (Path.equals(_op3, p)) {\n                        if (affinity === \"forward\") {\n                            p[p.length - 1] += 1;\n                        } else if (affinity === \"backward\") ;\n                        else {\n                            return null;\n                        }\n                    } else if (Path.endsBefore(_op3, p)) {\n                        p[_op3.length - 1] += 1;\n                    } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n                        p[_op3.length - 1] += 1;\n                        p[_op3.length] -= _position;\n                    }\n                    break;\n                }\n            case \"move_node\":\n                {\n                    var { path: _op4, newPath: onp } = operation;\n                    // If the old and new path are the same, it's a no-op.\n                    if (Path.equals(_op4, onp)) {\n                        return p;\n                    }\n                    if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n                        var copy = onp.slice();\n                        if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n                            copy[_op4.length - 1] -= 1;\n                        }\n                        return copy.concat(p.slice(_op4.length));\n                    } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n                        if (Path.endsBefore(_op4, p)) {\n                            p[_op4.length - 1] -= 1;\n                        } else {\n                            p[_op4.length - 1] += 1;\n                        }\n                    } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n                        if (Path.endsBefore(_op4, p)) {\n                            p[_op4.length - 1] -= 1;\n                        }\n                        p[onp.length - 1] += 1;\n                    } else if (Path.endsBefore(_op4, p)) {\n                        if (Path.equals(onp, p)) {\n                            p[onp.length - 1] += 1;\n                        }\n                        p[_op4.length - 1] -= 1;\n                    }\n                    break;\n                }\n        }\n        return p;\n    }\n};\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _toPrimitive(input, hint) {\n    if (_typeof(input) !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (_typeof(res) !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return _typeof(key) === \"symbol\" ? key : String(key);\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction ownKeys$e(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$e(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$e(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar applyToDraft = (editor, selection, op)=>{\n    switch(op.type){\n        case \"insert_node\":\n            {\n                var { path, node } = op;\n                var parent = Node.parent(editor, path);\n                var index = path[path.length - 1];\n                if (index > parent.children.length) {\n                    throw new Error('Cannot apply an \"insert_node\" operation at path ['.concat(path, \"] because the destination is past the end of the node.\"));\n                }\n                parent.children.splice(index, 0, node);\n                if (selection) {\n                    for (var [point, key] of Range.points(selection)){\n                        selection[key] = Point.transform(point, op);\n                    }\n                }\n                break;\n            }\n        case \"insert_text\":\n            {\n                var { path: _path, offset, text } = op;\n                if (text.length === 0) break;\n                var _node = Node.leaf(editor, _path);\n                var before = _node.text.slice(0, offset);\n                var after = _node.text.slice(offset);\n                _node.text = before + text + after;\n                if (selection) {\n                    for (var [_point, _key] of Range.points(selection)){\n                        selection[_key] = Point.transform(_point, op);\n                    }\n                }\n                break;\n            }\n        case \"merge_node\":\n            {\n                var { path: _path2 } = op;\n                var _node2 = Node.get(editor, _path2);\n                var prevPath = Path.previous(_path2);\n                var prev = Node.get(editor, prevPath);\n                var _parent = Node.parent(editor, _path2);\n                var _index = _path2[_path2.length - 1];\n                if (Text.isText(_node2) && Text.isText(prev)) {\n                    prev.text += _node2.text;\n                } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n                    prev.children.push(..._node2.children);\n                } else {\n                    throw new Error('Cannot apply a \"merge_node\" operation at path ['.concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(_node2), \" \").concat(Scrubber.stringify(prev)));\n                }\n                _parent.children.splice(_index, 1);\n                if (selection) {\n                    for (var [_point2, _key2] of Range.points(selection)){\n                        selection[_key2] = Point.transform(_point2, op);\n                    }\n                }\n                break;\n            }\n        case \"move_node\":\n            {\n                var { path: _path3, newPath } = op;\n                if (Path.isAncestor(_path3, newPath)) {\n                    throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n                }\n                var _node3 = Node.get(editor, _path3);\n                var _parent2 = Node.parent(editor, _path3);\n                var _index2 = _path3[_path3.length - 1];\n                // This is tricky, but since the `path` and `newPath` both refer to\n                // the same snapshot in time, there's a mismatch. After either\n                // removing the original position, the second step's path can be out\n                // of date. So instead of using the `op.newPath` directly, we\n                // transform `op.path` to ascertain what the `newPath` would be after\n                // the operation was applied.\n                _parent2.children.splice(_index2, 1);\n                var truePath = Path.transform(_path3, op);\n                var newParent = Node.get(editor, Path.parent(truePath));\n                var newIndex = truePath[truePath.length - 1];\n                newParent.children.splice(newIndex, 0, _node3);\n                if (selection) {\n                    for (var [_point3, _key3] of Range.points(selection)){\n                        selection[_key3] = Point.transform(_point3, op);\n                    }\n                }\n                break;\n            }\n        case \"remove_node\":\n            {\n                var { path: _path4 } = op;\n                var _index3 = _path4[_path4.length - 1];\n                var _parent3 = Node.parent(editor, _path4);\n                _parent3.children.splice(_index3, 1);\n                // Transform all the points in the value, but if the point was in the\n                // node that was removed we need to update the range or remove it.\n                if (selection) {\n                    for (var [_point4, _key4] of Range.points(selection)){\n                        var result = Point.transform(_point4, op);\n                        if (selection != null && result != null) {\n                            selection[_key4] = result;\n                        } else {\n                            var _prev = void 0;\n                            var next = void 0;\n                            for (var [n, p] of Node.texts(editor)){\n                                if (Path.compare(p, _path4) === -1) {\n                                    _prev = [\n                                        n,\n                                        p\n                                    ];\n                                } else {\n                                    next = [\n                                        n,\n                                        p\n                                    ];\n                                    break;\n                                }\n                            }\n                            var preferNext = false;\n                            if (_prev && next) {\n                                if (Path.equals(next[1], _path4)) {\n                                    preferNext = !Path.hasPrevious(next[1]);\n                                } else {\n                                    preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;\n                                }\n                            }\n                            if (_prev && !preferNext) {\n                                _point4.path = _prev[1];\n                                _point4.offset = _prev[0].text.length;\n                            } else if (next) {\n                                _point4.path = next[1];\n                                _point4.offset = 0;\n                            } else {\n                                selection = null;\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n        case \"remove_text\":\n            {\n                var { path: _path5, offset: _offset, text: _text } = op;\n                if (_text.length === 0) break;\n                var _node4 = Node.leaf(editor, _path5);\n                var _before = _node4.text.slice(0, _offset);\n                var _after = _node4.text.slice(_offset + _text.length);\n                _node4.text = _before + _after;\n                if (selection) {\n                    for (var [_point5, _key5] of Range.points(selection)){\n                        selection[_key5] = Point.transform(_point5, op);\n                    }\n                }\n                break;\n            }\n        case \"set_node\":\n            {\n                var { path: _path6, properties, newProperties } = op;\n                if (_path6.length === 0) {\n                    throw new Error(\"Cannot set properties on the root node!\");\n                }\n                var _node5 = Node.get(editor, _path6);\n                for(var _key6 in newProperties){\n                    if (_key6 === \"children\" || _key6 === \"text\") {\n                        throw new Error('Cannot set the \"'.concat(_key6, '\" property of nodes!'));\n                    }\n                    var value = newProperties[_key6];\n                    if (value == null) {\n                        delete _node5[_key6];\n                    } else {\n                        _node5[_key6] = value;\n                    }\n                }\n                // properties that were previously defined, but are now missing, must be deleted\n                for(var _key7 in properties){\n                    if (!newProperties.hasOwnProperty(_key7)) {\n                        delete _node5[_key7];\n                    }\n                }\n                break;\n            }\n        case \"set_selection\":\n            {\n                var { newProperties: _newProperties } = op;\n                if (_newProperties == null) {\n                    selection = _newProperties;\n                } else {\n                    if (selection == null) {\n                        if (!Range.isRange(_newProperties)) {\n                            throw new Error('Cannot apply an incomplete \"set_selection\" operation properties '.concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n                        }\n                        selection = _objectSpread$e({}, _newProperties);\n                    }\n                    for(var _key8 in _newProperties){\n                        var _value = _newProperties[_key8];\n                        if (_value == null) {\n                            if (_key8 === \"anchor\" || _key8 === \"focus\") {\n                                throw new Error('Cannot remove the \"'.concat(_key8, '\" selection property'));\n                            }\n                            delete selection[_key8];\n                        } else {\n                            selection[_key8] = _value;\n                        }\n                    }\n                }\n                break;\n            }\n        case \"split_node\":\n            {\n                var { path: _path7, position, properties: _properties } = op;\n                if (_path7.length === 0) {\n                    throw new Error('Cannot apply a \"split_node\" operation at path ['.concat(_path7, \"] because the root node cannot be split.\"));\n                }\n                var _node6 = Node.get(editor, _path7);\n                var _parent4 = Node.parent(editor, _path7);\n                var _index4 = _path7[_path7.length - 1];\n                var newNode;\n                if (Text.isText(_node6)) {\n                    var _before2 = _node6.text.slice(0, position);\n                    var _after2 = _node6.text.slice(position);\n                    _node6.text = _before2;\n                    newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n                        text: _after2\n                    });\n                } else {\n                    var _before3 = _node6.children.slice(0, position);\n                    var _after3 = _node6.children.slice(position);\n                    _node6.children = _before3;\n                    newNode = _objectSpread$e(_objectSpread$e({}, _properties), {}, {\n                        children: _after3\n                    });\n                }\n                _parent4.children.splice(_index4 + 1, 0, newNode);\n                if (selection) {\n                    for (var [_point6, _key9] of Range.points(selection)){\n                        selection[_key9] = Point.transform(_point6, op);\n                    }\n                }\n                break;\n            }\n    }\n    return selection;\n};\n// eslint-disable-next-line no-redeclare\nvar GeneralTransforms = {\n    transform (editor, op) {\n        editor.children = (0,immer__WEBPACK_IMPORTED_MODULE_1__.createDraft)(editor.children);\n        var selection = editor.selection && (0,immer__WEBPACK_IMPORTED_MODULE_1__.createDraft)(editor.selection);\n        try {\n            selection = applyToDraft(editor, selection, op);\n        } finally{\n            editor.children = (0,immer__WEBPACK_IMPORTED_MODULE_1__.finishDraft)(editor.children);\n            if (selection) {\n                editor.selection = (0,immer__WEBPACK_IMPORTED_MODULE_1__.isDraft)(selection) ? (0,immer__WEBPACK_IMPORTED_MODULE_1__.finishDraft)(selection) : selection;\n            } else {\n                editor.selection = null;\n            }\n        }\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar NodeTransforms = {\n    insertNodes (editor, nodes, options) {\n        editor.insertNodes(nodes, options);\n    },\n    liftNodes (editor, options) {\n        editor.liftNodes(options);\n    },\n    mergeNodes (editor, options) {\n        editor.mergeNodes(options);\n    },\n    moveNodes (editor, options) {\n        editor.moveNodes(options);\n    },\n    removeNodes (editor, options) {\n        editor.removeNodes(options);\n    },\n    setNodes (editor, props, options) {\n        editor.setNodes(props, options);\n    },\n    splitNodes (editor, options) {\n        editor.splitNodes(options);\n    },\n    unsetNodes (editor, props, options) {\n        editor.unsetNodes(props, options);\n    },\n    unwrapNodes (editor, options) {\n        editor.unwrapNodes(options);\n    },\n    wrapNodes (editor, element, options) {\n        editor.wrapNodes(element, options);\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar SelectionTransforms = {\n    collapse (editor, options) {\n        editor.collapse(options);\n    },\n    deselect (editor) {\n        editor.deselect();\n    },\n    move (editor, options) {\n        editor.move(options);\n    },\n    select (editor, target) {\n        editor.select(target);\n    },\n    setPoint (editor, props, options) {\n        editor.setPoint(props, options);\n    },\n    setSelection (editor, props) {\n        editor.setSelection(props);\n    }\n};\n/*\n  Custom deep equal comparison for Slate nodes.\n\n  We don't need general purpose deep equality;\n  Slate only supports plain values, Arrays, and nested objects.\n  Complex values nested inside Arrays are not supported.\n\n  Slate objects are designed to be serialised, so\n  missing keys are deliberately normalised to undefined.\n */ var isDeepEqual = (node, another)=>{\n    for(var key in node){\n        var a = node[key];\n        var b = another[key];\n        if ((0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(a) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(b)) {\n            if (!isDeepEqual(a, b)) return false;\n        } else if (Array.isArray(a) && Array.isArray(b)) {\n            if (a.length !== b.length) return false;\n            for(var i = 0; i < a.length; i++){\n                if (a[i] !== b[i]) return false;\n            }\n        } else if (a !== b) {\n            return false;\n        }\n    }\n    /*\n    Deep object equality is only necessary in one direction; in the reverse direction\n    we are only looking for keys that are missing.\n    As above, undefined keys are normalised to missing.\n  */ for(var _key in another){\n        if (node[_key] === undefined && another[_key] !== undefined) {\n            return false;\n        }\n    }\n    return true;\n};\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nvar _excluded$4 = [\n    \"anchor\",\n    \"focus\"\n];\nfunction ownKeys$d(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$d(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$d(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\n// eslint-disable-next-line no-redeclare\nvar Range = {\n    edges (range) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { reverse = false } = options;\n        var { anchor, focus } = range;\n        return Range.isBackward(range) === reverse ? [\n            anchor,\n            focus\n        ] : [\n            focus,\n            anchor\n        ];\n    },\n    end (range) {\n        var [, end] = Range.edges(range);\n        return end;\n    },\n    equals (range, another) {\n        return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n    },\n    includes (range, target) {\n        if (Range.isRange(target)) {\n            if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n                return true;\n            }\n            var [rs, re] = Range.edges(range);\n            var [ts, te] = Range.edges(target);\n            return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n        }\n        var [start, end] = Range.edges(range);\n        var isAfterStart = false;\n        var isBeforeEnd = false;\n        if (Point.isPoint(target)) {\n            isAfterStart = Point.compare(target, start) >= 0;\n            isBeforeEnd = Point.compare(target, end) <= 0;\n        } else {\n            isAfterStart = Path.compare(target, start.path) >= 0;\n            isBeforeEnd = Path.compare(target, end.path) <= 0;\n        }\n        return isAfterStart && isBeforeEnd;\n    },\n    intersection (range, another) {\n        var rest = _objectWithoutProperties(range, _excluded$4);\n        var [s1, e1] = Range.edges(range);\n        var [s2, e2] = Range.edges(another);\n        var start = Point.isBefore(s1, s2) ? s2 : s1;\n        var end = Point.isBefore(e1, e2) ? e1 : e2;\n        if (Point.isBefore(end, start)) {\n            return null;\n        } else {\n            return _objectSpread$d({\n                anchor: start,\n                focus: end\n            }, rest);\n        }\n    },\n    isBackward (range) {\n        var { anchor, focus } = range;\n        return Point.isAfter(anchor, focus);\n    },\n    isCollapsed (range) {\n        var { anchor, focus } = range;\n        return Point.equals(anchor, focus);\n    },\n    isExpanded (range) {\n        return !Range.isCollapsed(range);\n    },\n    isForward (range) {\n        return !Range.isBackward(range);\n    },\n    isRange (value) {\n        return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n    },\n    *points (range) {\n        yield [\n            range.anchor,\n            \"anchor\"\n        ];\n        yield [\n            range.focus,\n            \"focus\"\n        ];\n    },\n    start (range) {\n        var [start] = Range.edges(range);\n        return start;\n    },\n    transform (range, op) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(range, (r)=>{\n            if (r === null) {\n                return null;\n            }\n            var { affinity = \"inward\" } = options;\n            var affinityAnchor;\n            var affinityFocus;\n            if (affinity === \"inward\") {\n                // If the range is collapsed, make sure to use the same affinity to\n                // avoid the two points passing each other and expanding in the opposite\n                // direction\n                var isCollapsed = Range.isCollapsed(r);\n                if (Range.isForward(r)) {\n                    affinityAnchor = \"forward\";\n                    affinityFocus = isCollapsed ? affinityAnchor : \"backward\";\n                } else {\n                    affinityAnchor = \"backward\";\n                    affinityFocus = isCollapsed ? affinityAnchor : \"forward\";\n                }\n            } else if (affinity === \"outward\") {\n                if (Range.isForward(r)) {\n                    affinityAnchor = \"backward\";\n                    affinityFocus = \"forward\";\n                } else {\n                    affinityAnchor = \"forward\";\n                    affinityFocus = \"backward\";\n                }\n            } else {\n                affinityAnchor = affinity;\n                affinityFocus = affinity;\n            }\n            var anchor = Point.transform(r.anchor, op, {\n                affinity: affinityAnchor\n            });\n            var focus = Point.transform(r.focus, op, {\n                affinity: affinityFocus\n            });\n            if (!anchor || !focus) {\n                return null;\n            }\n            r.anchor = anchor;\n            r.focus = focus;\n        });\n    }\n};\n/**\n * Shared the function with isElementType utility\n */ var isElement = (value)=>{\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n};\n// eslint-disable-next-line no-redeclare\nvar Element = {\n    isAncestor (value) {\n        return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Node.isNodeList(value.children);\n    },\n    isElement,\n    isElementList (value) {\n        return Array.isArray(value) && value.every((val)=>Element.isElement(val));\n    },\n    isElementProps (props) {\n        return props.children !== undefined;\n    },\n    isElementType: function isElementType(value, elementVal) {\n        var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"type\";\n        return isElement(value) && value[elementKey] === elementVal;\n    },\n    matches (element, props) {\n        for(var key in props){\n            if (key === \"children\") {\n                continue;\n            }\n            if (element[key] !== props[key]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\nvar _excluded$3 = [\n    \"children\"\n], _excluded2$3 = [\n    \"text\"\n];\nvar IS_NODE_LIST_CACHE = new WeakMap();\n// eslint-disable-next-line no-redeclare\nvar Node = {\n    ancestor (root, path) {\n        var node = Node.get(root, path);\n        if (Text.isText(node)) {\n            throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    ancestors (root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return function*() {\n            for (var p of Path.ancestors(path, options)){\n                var n = Node.ancestor(root, p);\n                var entry = [\n                    n,\n                    p\n                ];\n                yield entry;\n            }\n        }();\n    },\n    child (root, index) {\n        if (Text.isText(root)) {\n            throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n        }\n        var c = root.children[index];\n        if (c == null) {\n            throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n        }\n        return c;\n    },\n    children (root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return function*() {\n            var { reverse = false } = options;\n            var ancestor = Node.ancestor(root, path);\n            var { children } = ancestor;\n            var index = reverse ? children.length - 1 : 0;\n            while(reverse ? index >= 0 : index < children.length){\n                var child = Node.child(ancestor, index);\n                var childPath = path.concat(index);\n                yield [\n                    child,\n                    childPath\n                ];\n                index = reverse ? index - 1 : index + 1;\n            }\n        }();\n    },\n    common (root, path, another) {\n        var p = Path.common(path, another);\n        var n = Node.get(root, p);\n        return [\n            n,\n            p\n        ];\n    },\n    descendant (root, path) {\n        var node = Node.get(root, path);\n        if (Editor.isEditor(node)) {\n            throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    descendants (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return function*() {\n            for (var [node, path] of Node.nodes(root, options)){\n                if (path.length !== 0) {\n                    // NOTE: we have to coerce here because checking the path's length does\n                    // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n                    yield [\n                        node,\n                        path\n                    ];\n                }\n            }\n        }();\n    },\n    elements (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return function*() {\n            for (var [node, path] of Node.nodes(root, options)){\n                if (Element.isElement(node)) {\n                    yield [\n                        node,\n                        path\n                    ];\n                }\n            }\n        }();\n    },\n    extractProps (node) {\n        if (Element.isAncestor(node)) {\n            var properties = _objectWithoutProperties(node, _excluded$3);\n            return properties;\n        } else {\n            var properties = _objectWithoutProperties(node, _excluded2$3);\n            return properties;\n        }\n    },\n    first (root, path) {\n        var p = path.slice();\n        var n = Node.get(root, p);\n        while(n){\n            if (Text.isText(n) || n.children.length === 0) {\n                break;\n            } else {\n                n = n.children[0];\n                p.push(0);\n            }\n        }\n        return [\n            n,\n            p\n        ];\n    },\n    fragment (root, range) {\n        if (Text.isText(root)) {\n            throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root)));\n        }\n        var newRoot = (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)({\n            children: root.children\n        }, (r)=>{\n            var [start, end] = Range.edges(range);\n            var nodeEntries = Node.nodes(r, {\n                reverse: true,\n                pass: (_ref)=>{\n                    var [, path] = _ref;\n                    return !Range.includes(range, path);\n                }\n            });\n            for (var [, path] of nodeEntries){\n                if (!Range.includes(range, path)) {\n                    var parent = Node.parent(r, path);\n                    var index = path[path.length - 1];\n                    parent.children.splice(index, 1);\n                }\n                if (Path.equals(path, end.path)) {\n                    var leaf = Node.leaf(r, path);\n                    leaf.text = leaf.text.slice(0, end.offset);\n                }\n                if (Path.equals(path, start.path)) {\n                    var _leaf = Node.leaf(r, path);\n                    _leaf.text = _leaf.text.slice(start.offset);\n                }\n            }\n            if (Editor.isEditor(r)) {\n                r.selection = null;\n            }\n        });\n        return newRoot.children;\n    },\n    get (root, path) {\n        var node = root;\n        for(var i = 0; i < path.length; i++){\n            var p = path[i];\n            if (Text.isText(node) || !node.children[p]) {\n                throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n            }\n            node = node.children[p];\n        }\n        return node;\n    },\n    has (root, path) {\n        var node = root;\n        for(var i = 0; i < path.length; i++){\n            var p = path[i];\n            if (Text.isText(node) || !node.children[p]) {\n                return false;\n            }\n            node = node.children[p];\n        }\n        return true;\n    },\n    isNode (value) {\n        return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n    },\n    isNodeList (value) {\n        if (!Array.isArray(value)) {\n            return false;\n        }\n        var cachedResult = IS_NODE_LIST_CACHE.get(value);\n        if (cachedResult !== undefined) {\n            return cachedResult;\n        }\n        var isNodeList = value.every((val)=>Node.isNode(val));\n        IS_NODE_LIST_CACHE.set(value, isNodeList);\n        return isNodeList;\n    },\n    last (root, path) {\n        var p = path.slice();\n        var n = Node.get(root, p);\n        while(n){\n            if (Text.isText(n) || n.children.length === 0) {\n                break;\n            } else {\n                var i = n.children.length - 1;\n                n = n.children[i];\n                p.push(i);\n            }\n        }\n        return [\n            n,\n            p\n        ];\n    },\n    leaf (root, path) {\n        var node = Node.get(root, path);\n        if (!Text.isText(node)) {\n            throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n        }\n        return node;\n    },\n    levels (root, path) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return function*() {\n            for (var p of Path.levels(path, options)){\n                var n = Node.get(root, p);\n                yield [\n                    n,\n                    p\n                ];\n            }\n        }();\n    },\n    matches (node, props) {\n        return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n    },\n    nodes (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return function*() {\n            var { pass, reverse = false } = options;\n            var { from = [], to } = options;\n            var visited = new Set();\n            var p = [];\n            var n = root;\n            while(true){\n                if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n                    break;\n                }\n                if (!visited.has(n)) {\n                    yield [\n                        n,\n                        p\n                    ];\n                }\n                // If we're allowed to go downward and we haven't descended yet, do.\n                if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([\n                    n,\n                    p\n                ]) === false)) {\n                    visited.add(n);\n                    var nextIndex = reverse ? n.children.length - 1 : 0;\n                    if (Path.isAncestor(p, from)) {\n                        nextIndex = from[p.length];\n                    }\n                    p = p.concat(nextIndex);\n                    n = Node.get(root, p);\n                    continue;\n                }\n                // If we're at the root and we can't go down, we're done.\n                if (p.length === 0) {\n                    break;\n                }\n                // If we're going forward...\n                if (!reverse) {\n                    var newPath = Path.next(p);\n                    if (Node.has(root, newPath)) {\n                        p = newPath;\n                        n = Node.get(root, p);\n                        continue;\n                    }\n                }\n                // If we're going backward...\n                if (reverse && p[p.length - 1] !== 0) {\n                    var _newPath = Path.previous(p);\n                    p = _newPath;\n                    n = Node.get(root, p);\n                    continue;\n                }\n                // Otherwise we're going upward...\n                p = Path.parent(p);\n                n = Node.get(root, p);\n                visited.add(n);\n            }\n        }();\n    },\n    parent (root, path) {\n        var parentPath = Path.parent(path);\n        var p = Node.get(root, parentPath);\n        if (Text.isText(p)) {\n            throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n        }\n        return p;\n    },\n    string (node) {\n        if (Text.isText(node)) {\n            return node.text;\n        } else {\n            return node.children.map(Node.string).join(\"\");\n        }\n    },\n    texts (root) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return function*() {\n            for (var [node, path] of Node.nodes(root, options)){\n                if (Text.isText(node)) {\n                    yield [\n                        node,\n                        path\n                    ];\n                }\n            }\n        }();\n    }\n};\nfunction ownKeys$c(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$c(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$c(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\n// eslint-disable-next-line no-redeclare\nvar Operation = {\n    isNodeOperation (value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_node\");\n    },\n    isOperation (value) {\n        if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {\n            return false;\n        }\n        switch(value.type){\n            case \"insert_node\":\n                return Path.isPath(value.path) && Node.isNode(value.node);\n            case \"insert_text\":\n                return typeof value.offset === \"number\" && typeof value.text === \"string\" && Path.isPath(value.path);\n            case \"merge_node\":\n                return typeof value.position === \"number\" && Path.isPath(value.path) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties);\n            case \"move_node\":\n                return Path.isPath(value.path) && Path.isPath(value.newPath);\n            case \"remove_node\":\n                return Path.isPath(value.path) && Node.isNode(value.node);\n            case \"remove_text\":\n                return typeof value.offset === \"number\" && typeof value.text === \"string\" && Path.isPath(value.path);\n            case \"set_node\":\n                return Path.isPath(value.path) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.newProperties);\n            case \"set_selection\":\n                return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.newProperties);\n            case \"split_node\":\n                return Path.isPath(value.path) && typeof value.position === \"number\" && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties);\n            default:\n                return false;\n        }\n    },\n    isOperationList (value) {\n        return Array.isArray(value) && value.every((val)=>Operation.isOperation(val));\n    },\n    isSelectionOperation (value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_selection\");\n    },\n    isTextOperation (value) {\n        return Operation.isOperation(value) && value.type.endsWith(\"_text\");\n    },\n    inverse (op) {\n        switch(op.type){\n            case \"insert_node\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"remove_node\"\n                    });\n                }\n            case \"insert_text\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"remove_text\"\n                    });\n                }\n            case \"merge_node\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"split_node\",\n                        path: Path.previous(op.path)\n                    });\n                }\n            case \"move_node\":\n                {\n                    var { newPath, path } = op;\n                    // PERF: in this case the move operation is a no-op anyways.\n                    if (Path.equals(newPath, path)) {\n                        return op;\n                    }\n                    // If the move happens completely within a single parent the path and\n                    // newPath are stable with respect to each other.\n                    if (Path.isSibling(path, newPath)) {\n                        return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                            path: newPath,\n                            newPath: path\n                        });\n                    }\n                    // If the move does not happen within a single parent it is possible\n                    // for the move to impact the true path to the location where the node\n                    // was removed from and where it was inserted. We have to adjust for this\n                    // and find the original path. We can accomplish this (only in non-sibling)\n                    // moves by looking at the impact of the move operation on the node\n                    // after the original move path.\n                    var inversePath = Path.transform(path, op);\n                    var inverseNewPath = Path.transform(Path.next(path), op);\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        path: inversePath,\n                        newPath: inverseNewPath\n                    });\n                }\n            case \"remove_node\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"insert_node\"\n                    });\n                }\n            case \"remove_text\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"insert_text\"\n                    });\n                }\n            case \"set_node\":\n                {\n                    var { properties, newProperties } = op;\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        properties: newProperties,\n                        newProperties: properties\n                    });\n                }\n            case \"set_selection\":\n                {\n                    var { properties: _properties, newProperties: _newProperties } = op;\n                    if (_properties == null) {\n                        return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                            properties: _newProperties,\n                            newProperties: null\n                        });\n                    } else if (_newProperties == null) {\n                        return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                            properties: null,\n                            newProperties: _properties\n                        });\n                    } else {\n                        return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                            properties: _newProperties,\n                            newProperties: _properties\n                        });\n                    }\n                }\n            case \"split_node\":\n                {\n                    return _objectSpread$c(_objectSpread$c({}, op), {}, {\n                        type: \"merge_node\",\n                        path: Path.next(op.path)\n                    });\n                }\n        }\n    }\n};\nvar IS_EDITOR_CACHE = new WeakMap();\nvar isEditor = (value)=>{\n    var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n    if (cachedIsEditor !== undefined) {\n        return cachedIsEditor;\n    }\n    if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {\n        return false;\n    }\n    var isEditor = typeof value.addMark === \"function\" && typeof value.apply === \"function\" && typeof value.deleteFragment === \"function\" && typeof value.insertBreak === \"function\" && typeof value.insertSoftBreak === \"function\" && typeof value.insertFragment === \"function\" && typeof value.insertNode === \"function\" && typeof value.insertText === \"function\" && typeof value.isElementReadOnly === \"function\" && typeof value.isInline === \"function\" && typeof value.isSelectable === \"function\" && typeof value.isVoid === \"function\" && typeof value.normalizeNode === \"function\" && typeof value.onChange === \"function\" && typeof value.removeMark === \"function\" && typeof value.getDirtyPaths === \"function\" && (value.marks === null || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n    IS_EDITOR_CACHE.set(value, isEditor);\n    return isEditor;\n};\n// eslint-disable-next-line no-redeclare\nvar Editor = {\n    above (editor, options) {\n        return editor.above(options);\n    },\n    addMark (editor, key, value) {\n        editor.addMark(key, value);\n    },\n    after (editor, at, options) {\n        return editor.after(at, options);\n    },\n    before (editor, at, options) {\n        return editor.before(at, options);\n    },\n    deleteBackward (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { unit = \"character\" } = options;\n        editor.deleteBackward(unit);\n    },\n    deleteForward (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { unit = \"character\" } = options;\n        editor.deleteForward(unit);\n    },\n    deleteFragment (editor, options) {\n        editor.deleteFragment(options);\n    },\n    edges (editor, at) {\n        return editor.edges(at);\n    },\n    elementReadOnly (editor) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return editor.elementReadOnly(options);\n    },\n    end (editor, at) {\n        return editor.end(at);\n    },\n    first (editor, at) {\n        return editor.first(at);\n    },\n    fragment (editor, at) {\n        return editor.fragment(at);\n    },\n    hasBlocks (editor, element) {\n        return editor.hasBlocks(element);\n    },\n    hasInlines (editor, element) {\n        return editor.hasInlines(element);\n    },\n    hasPath (editor, path) {\n        return editor.hasPath(path);\n    },\n    hasTexts (editor, element) {\n        return editor.hasTexts(element);\n    },\n    insertBreak (editor) {\n        editor.insertBreak();\n    },\n    insertFragment (editor, fragment, options) {\n        editor.insertFragment(fragment, options);\n    },\n    insertNode (editor, node) {\n        editor.insertNode(node);\n    },\n    insertSoftBreak (editor) {\n        editor.insertSoftBreak();\n    },\n    insertText (editor, text) {\n        editor.insertText(text);\n    },\n    isBlock (editor, value) {\n        return editor.isBlock(value);\n    },\n    isEdge (editor, point, at) {\n        return editor.isEdge(point, at);\n    },\n    isEditor (value) {\n        return isEditor(value);\n    },\n    isElementReadOnly (editor, element) {\n        return editor.isElementReadOnly(element);\n    },\n    isEmpty (editor, element) {\n        return editor.isEmpty(element);\n    },\n    isEnd (editor, point, at) {\n        return editor.isEnd(point, at);\n    },\n    isInline (editor, value) {\n        return editor.isInline(value);\n    },\n    isNormalizing (editor) {\n        return editor.isNormalizing();\n    },\n    isSelectable (editor, value) {\n        return editor.isSelectable(value);\n    },\n    isStart (editor, point, at) {\n        return editor.isStart(point, at);\n    },\n    isVoid (editor, value) {\n        return editor.isVoid(value);\n    },\n    last (editor, at) {\n        return editor.last(at);\n    },\n    leaf (editor, at, options) {\n        return editor.leaf(at, options);\n    },\n    levels (editor, options) {\n        return editor.levels(options);\n    },\n    marks (editor) {\n        return editor.getMarks();\n    },\n    next (editor, options) {\n        return editor.next(options);\n    },\n    node (editor, at, options) {\n        return editor.node(at, options);\n    },\n    nodes (editor, options) {\n        return editor.nodes(options);\n    },\n    normalize (editor, options) {\n        editor.normalize(options);\n    },\n    parent (editor, at, options) {\n        return editor.parent(at, options);\n    },\n    path (editor, at, options) {\n        return editor.path(at, options);\n    },\n    pathRef (editor, path, options) {\n        return editor.pathRef(path, options);\n    },\n    pathRefs (editor) {\n        return editor.pathRefs();\n    },\n    point (editor, at, options) {\n        return editor.point(at, options);\n    },\n    pointRef (editor, point, options) {\n        return editor.pointRef(point, options);\n    },\n    pointRefs (editor) {\n        return editor.pointRefs();\n    },\n    positions (editor, options) {\n        return editor.positions(options);\n    },\n    previous (editor, options) {\n        return editor.previous(options);\n    },\n    range (editor, at, to) {\n        return editor.range(at, to);\n    },\n    rangeRef (editor, range, options) {\n        return editor.rangeRef(range, options);\n    },\n    rangeRefs (editor) {\n        return editor.rangeRefs();\n    },\n    removeMark (editor, key) {\n        editor.removeMark(key);\n    },\n    setNormalizing (editor, isNormalizing) {\n        editor.setNormalizing(isNormalizing);\n    },\n    start (editor, at) {\n        return editor.start(at);\n    },\n    string (editor, at, options) {\n        return editor.string(at, options);\n    },\n    unhangRange (editor, range, options) {\n        return editor.unhangRange(range, options);\n    },\n    void (editor, options) {\n        return editor.void(options);\n    },\n    withoutNormalizing (editor, fn) {\n        editor.withoutNormalizing(fn);\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar Location = {\n    isLocation (value) {\n        return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar Span = {\n    isSpan (value) {\n        return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n    }\n};\nfunction ownKeys$b(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$b(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$b(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\n// eslint-disable-next-line no-redeclare\nvar Point = {\n    compare (point, another) {\n        var result = Path.compare(point.path, another.path);\n        if (result === 0) {\n            if (point.offset < another.offset) return -1;\n            if (point.offset > another.offset) return 1;\n            return 0;\n        }\n        return result;\n    },\n    isAfter (point, another) {\n        return Point.compare(point, another) === 1;\n    },\n    isBefore (point, another) {\n        return Point.compare(point, another) === -1;\n    },\n    equals (point, another) {\n        // PERF: ensure the offsets are equal first since they are cheaper to check.\n        return point.offset === another.offset && Path.equals(point.path, another.path);\n    },\n    isPoint (value) {\n        return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && typeof value.offset === \"number\" && Path.isPath(value.path);\n    },\n    transform (point, op) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(point, (p)=>{\n            if (p === null) {\n                return null;\n            }\n            var { affinity = \"forward\" } = options;\n            var { path, offset } = p;\n            switch(op.type){\n                case \"insert_node\":\n                case \"move_node\":\n                    {\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"insert_text\":\n                    {\n                        if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === \"forward\")) {\n                            p.offset += op.text.length;\n                        }\n                        break;\n                    }\n                case \"merge_node\":\n                    {\n                        if (Path.equals(op.path, path)) {\n                            p.offset += op.position;\n                        }\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"remove_text\":\n                    {\n                        if (Path.equals(op.path, path) && op.offset <= offset) {\n                            p.offset -= Math.min(offset - op.offset, op.text.length);\n                        }\n                        break;\n                    }\n                case \"remove_node\":\n                    {\n                        if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n                            return null;\n                        }\n                        p.path = Path.transform(path, op, options);\n                        break;\n                    }\n                case \"split_node\":\n                    {\n                        if (Path.equals(op.path, path)) {\n                            if (op.position === offset && affinity == null) {\n                                return null;\n                            } else if (op.position < offset || op.position === offset && affinity === \"forward\") {\n                                p.offset -= op.position;\n                                p.path = Path.transform(path, op, _objectSpread$b(_objectSpread$b({}, options), {}, {\n                                    affinity: \"forward\"\n                                }));\n                            }\n                        } else {\n                            p.path = Path.transform(path, op, options);\n                        }\n                        break;\n                    }\n            }\n        });\n    }\n};\nvar _scrubber = undefined;\n/**\n * This interface implements a stringify() function, which is used by Slate\n * internally when generating exceptions containing end user data. Developers\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\n * stringify() function.\n *\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\n *\n *    import { Scrubber } from 'slate';\n *    Scrubber.setScrubber((key, val) => {\n *      if (key === 'text') return '...scrubbed...'\n *      return val\n *    });\n *\n */ // eslint-disable-next-line no-redeclare\nvar Scrubber = {\n    setScrubber (scrubber) {\n        _scrubber = scrubber;\n    },\n    stringify (value) {\n        return JSON.stringify(value, _scrubber);\n    }\n};\nvar _excluded$2 = [\n    \"text\"\n], _excluded2$2 = [\n    \"anchor\",\n    \"focus\"\n];\nfunction ownKeys$a(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$a(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$a(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\n// eslint-disable-next-line no-redeclare\nvar Text = {\n    equals (text, another) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var { loose = false } = options;\n        function omitText(obj) {\n            var rest = _objectWithoutProperties(obj, _excluded$2);\n            return rest;\n        }\n        return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n    },\n    isText (value) {\n        return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && typeof value.text === \"string\";\n    },\n    isTextList (value) {\n        return Array.isArray(value) && value.every((val)=>Text.isText(val));\n    },\n    isTextProps (props) {\n        return props.text !== undefined;\n    },\n    matches (text, props) {\n        for(var key in props){\n            if (key === \"text\") {\n                continue;\n            }\n            if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n                return false;\n            }\n        }\n        return true;\n    },\n    decorations (node, decorations) {\n        var leaves = [\n            _objectSpread$a({}, node)\n        ];\n        for (var dec of decorations){\n            var rest = _objectWithoutProperties(dec, _excluded2$2);\n            var [start, end] = Range.edges(dec);\n            var next = [];\n            var leafEnd = 0;\n            var decorationStart = start.offset;\n            var decorationEnd = end.offset;\n            for (var leaf of leaves){\n                var { length } = leaf.text;\n                var leafStart = leafEnd;\n                leafEnd += length;\n                // If the range encompasses the entire leaf, add the range.\n                if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n                    Object.assign(leaf, rest);\n                    next.push(leaf);\n                    continue;\n                }\n                // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n                if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n                    next.push(leaf);\n                    continue;\n                }\n                // Otherwise we need to split the leaf, at the start, end, or both,\n                // and add the range to the middle intersecting section. Do the end\n                // split first since we don't need to update the offset that way.\n                var middle = leaf;\n                var before = void 0;\n                var after = void 0;\n                if (decorationEnd < leafEnd) {\n                    var off = decorationEnd - leafStart;\n                    after = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                        text: middle.text.slice(off)\n                    });\n                    middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                        text: middle.text.slice(0, off)\n                    });\n                }\n                if (decorationStart > leafStart) {\n                    var _off = decorationStart - leafStart;\n                    before = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                        text: middle.text.slice(0, _off)\n                    });\n                    middle = _objectSpread$a(_objectSpread$a({}, middle), {}, {\n                        text: middle.text.slice(_off)\n                    });\n                }\n                Object.assign(middle, rest);\n                if (before) {\n                    next.push(before);\n                }\n                next.push(middle);\n                if (after) {\n                    next.push(after);\n                }\n            }\n            leaves = next;\n        }\n        return leaves;\n    }\n};\n/**\n * Get the default location to insert content into the editor.\n * By default, use the selection as the target location. But if there is\n * no selection, insert at the end of the document since that is such a\n * common use case when inserting from a non-selected state.\n */ var getDefaultInsertLocation = (editor)=>{\n    if (editor.selection) {\n        return editor.selection;\n    } else if (editor.children.length > 0) {\n        return Editor.end(editor, []);\n    } else {\n        return [\n            0\n        ];\n    }\n};\nvar matchPath = (editor, path)=>{\n    var [node] = Editor.node(editor, path);\n    return (n)=>n === node;\n};\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n/**\n * Get the distance to the end of the first character in a string of text.\n */ var getCharacterDistance = function getCharacterDistance(str) {\n    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var isLTR = !isRTL;\n    var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n    var left = CodepointType.None;\n    var right = CodepointType.None;\n    var distance = 0;\n    // Evaluation of these conditions are deferred.\n    var gb11 = null; // Is GB11 applicable?\n    var gb12Or13 = null; // Is GB12 or GB13 applicable?\n    for (var char of codepoints){\n        var code = char.codePointAt(0);\n        if (!code) break;\n        var type = getCodepointType(char, code);\n        [left, right] = isLTR ? [\n            right,\n            type\n        ] : [\n            type,\n            left\n        ];\n        if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n            if (isLTR) {\n                gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n            } else {\n                gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n            }\n            if (!gb11) break;\n        }\n        if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n            if (gb12Or13 !== null) {\n                gb12Or13 = !gb12Or13;\n            } else {\n                if (isLTR) {\n                    gb12Or13 = true;\n                } else {\n                    gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n                }\n            }\n            if (!gb12Or13) break;\n        }\n        if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n            break;\n        }\n        distance += char.length;\n    }\n    return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\n * Get the distance to the end of the first word in a string of text.\n */ var getWordDistance = function getWordDistance(text) {\n    var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var dist = 0;\n    var started = false;\n    while(text.length > 0){\n        var charDist = getCharacterDistance(text, isRTL);\n        var [char, remaining] = splitByCharacterDistance(text, charDist, isRTL);\n        if (isWordCharacter(char, remaining, isRTL)) {\n            started = true;\n            dist += charDist;\n        } else if (!started) {\n            dist += charDist;\n        } else {\n            break;\n        }\n        text = remaining;\n    }\n    return dist;\n};\n/**\n * Split a string in two parts at a given distance starting from the end when\n * `isRTL` is set to `true`.\n */ var splitByCharacterDistance = (str, dist, isRTL)=>{\n    if (isRTL) {\n        var at = str.length - dist;\n        return [\n            str.slice(at, str.length),\n            str.slice(0, at)\n        ];\n    }\n    return [\n        str.slice(0, dist),\n        str.slice(dist)\n    ];\n};\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */ var isWordCharacter = function isWordCharacter(char, remaining) {\n    var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (SPACE.test(char)) {\n        return false;\n    }\n    // Chameleons count as word characters as long as they're in a word, so\n    // recurse to see if the next one is a word character or not.\n    if (CHAMELEON.test(char)) {\n        var charDist = getCharacterDistance(remaining, isRTL);\n        var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);\n        if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n            return true;\n        }\n    }\n    if (PUNCTUATION.test(char)) {\n        return false;\n    }\n    return true;\n};\n/**\n * Iterate on codepoints from right to left.\n */ var codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n    var end = str.length - 1;\n    for(var i = 0; i < str.length; i++){\n        var char1 = str.charAt(end - i);\n        if (isLowSurrogate(char1.charCodeAt(0))) {\n            var char2 = str.charAt(end - i - 1);\n            if (isHighSurrogate(char2.charCodeAt(0))) {\n                yield char2 + char1;\n                i++;\n                continue;\n            }\n        }\n        yield char1;\n    }\n};\n/**\n * Is `charCode` a high surrogate.\n *\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n */ var isHighSurrogate = (charCode)=>{\n    return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\n * Is `charCode` a low surrogate.\n *\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n */ var isLowSurrogate = (charCode)=>{\n    return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\nvar CodepointType;\n(function(CodepointType) {\n    CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n    CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n    CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n    CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n    CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n    CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n    CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n    CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n    CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n    CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n    CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n    CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n    CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0898-\\u089F\\u08CA-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3C\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732\\u1733\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u180F\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ACE\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDEFD-\\uDEFF\\uDF46-\\uDF50\\uDF82-\\uDF85]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC70\\uDC73\\uDC74\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDCC2\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDE41\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4\\uDF00\\uDF01\\uDF36-\\uDF3A\\uDF40\\uDF42]|\\uD80D[\\uDC40\\uDC47-\\uDC55]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD833[\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC8F\\uDD30-\\uDD36\\uDEAE\\uDEEC-\\uDEEF]|\\uD839[\\uDCEC-\\uDCEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\nvar getCodepointType = (char, code)=>{\n    var type = CodepointType.Any;\n    if (char.search(reExtend) !== -1) {\n        type |= CodepointType.Extend;\n    }\n    if (code === 0x200d) {\n        type |= CodepointType.ZWJ;\n    }\n    if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n        type |= CodepointType.RI;\n    }\n    if (char.search(rePrepend) !== -1) {\n        type |= CodepointType.Prepend;\n    }\n    if (char.search(reSpacingMark) !== -1) {\n        type |= CodepointType.SpacingMark;\n    }\n    if (char.search(reL) !== -1) {\n        type |= CodepointType.L;\n    }\n    if (char.search(reV) !== -1) {\n        type |= CodepointType.V;\n    }\n    if (char.search(reT) !== -1) {\n        type |= CodepointType.T;\n    }\n    if (char.search(reLV) !== -1) {\n        type |= CodepointType.LV;\n    }\n    if (char.search(reLVT) !== -1) {\n        type |= CodepointType.LVT;\n    }\n    if (char.search(reExtPict) !== -1) {\n        type |= CodepointType.ExtPict;\n    }\n    return type;\n};\nfunction intersects(x, y) {\n    return (x & y) !== 0;\n}\nvar NonBoundaryPairs = [\n    // GB6\n    [\n        CodepointType.L,\n        CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT\n    ],\n    // GB7\n    [\n        CodepointType.LV | CodepointType.V,\n        CodepointType.V | CodepointType.T\n    ],\n    // GB8\n    [\n        CodepointType.LVT | CodepointType.T,\n        CodepointType.T\n    ],\n    // GB9\n    [\n        CodepointType.Any,\n        CodepointType.Extend | CodepointType.ZWJ\n    ],\n    // GB9a\n    [\n        CodepointType.Any,\n        CodepointType.SpacingMark\n    ],\n    // GB9b\n    [\n        CodepointType.Prepend,\n        CodepointType.Any\n    ],\n    // GB11\n    [\n        CodepointType.ZWJ,\n        CodepointType.ExtPict\n    ],\n    // GB12 and GB13\n    [\n        CodepointType.RI,\n        CodepointType.RI\n    ]\n];\nfunction isBoundaryPair(left, right) {\n    return NonBoundaryPairs.findIndex((r)=>intersects(left, r[0]) && intersects(right, r[1])) === -1;\n}\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0898-\\u089F\\u08CA-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3C\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732\\u1733\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u180F\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ACE\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDEFD-\\uDEFF\\uDF46-\\uDF50\\uDF82-\\uDF85]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC70\\uDC73\\uDC74\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDCC2\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDE41\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4\\uDF00\\uDF01\\uDF36-\\uDF3A\\uDF40\\uDF42]|\\uD80D[\\uDC40\\uDC47-\\uDC55]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD833[\\uDF00-\\uDF2D\\uDF30-\\uDF46]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDC8F\\uDD30-\\uDD36\\uDEAE\\uDEEC-\\uDEEF]|\\uD839[\\uDCEC-\\uDCEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\nvar endsWithEmojiZWJ = (str)=>{\n    return str.search(endingEmojiZWJ) !== -1;\n};\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\nvar endsWithOddNumberOfRIs = (str)=>{\n    var match = str.match(endingRIs);\n    if (match === null) {\n        return false;\n    } else {\n        // A RI is represented by a surrogate pair.\n        var numRIs = match[0].length / 2;\n        return numRIs % 2 === 1;\n    }\n};\n// eslint-disable-next-line no-redeclare\nvar TextTransforms = {\n    delete (editor, options) {\n        editor.delete(options);\n    },\n    insertFragment (editor, fragment, options) {\n        editor.insertFragment(fragment, options);\n    },\n    insertText (editor, text) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        Editor.withoutNormalizing(editor, ()=>{\n            var { voids = false } = options;\n            var { at = getDefaultInsertLocation(editor) } = options;\n            if (Path.isPath(at)) {\n                at = Editor.range(editor, at);\n            }\n            if (Range.isRange(at)) {\n                if (Range.isCollapsed(at)) {\n                    at = at.anchor;\n                } else {\n                    var end = Range.end(at);\n                    if (!voids && Editor.void(editor, {\n                        at: end\n                    })) {\n                        return;\n                    }\n                    var start = Range.start(at);\n                    var startRef = Editor.pointRef(editor, start);\n                    var endRef = Editor.pointRef(editor, end);\n                    Transforms.delete(editor, {\n                        at,\n                        voids\n                    });\n                    var startPoint = startRef.unref();\n                    var endPoint = endRef.unref();\n                    at = startPoint || endPoint;\n                    Transforms.setSelection(editor, {\n                        anchor: at,\n                        focus: at\n                    });\n                }\n            }\n            if (!voids && Editor.void(editor, {\n                at\n            }) || Editor.elementReadOnly(editor, {\n                at\n            })) {\n                return;\n            }\n            var { path, offset } = at;\n            if (text.length > 0) editor.apply({\n                type: \"insert_text\",\n                path,\n                offset,\n                text\n            });\n        });\n    }\n};\nfunction ownKeys$9(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$9(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$9(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar Transforms = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\nvar apply = (editor, op)=>{\n    for (var ref of Editor.pathRefs(editor)){\n        PathRef.transform(ref, op);\n    }\n    for (var _ref of Editor.pointRefs(editor)){\n        PointRef.transform(_ref, op);\n    }\n    for (var _ref2 of Editor.rangeRefs(editor)){\n        RangeRef.transform(_ref2, op);\n    }\n    var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n    var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n    var dirtyPaths;\n    var dirtyPathKeys;\n    var add = (path)=>{\n        if (path) {\n            var key = path.join(\",\");\n            if (!dirtyPathKeys.has(key)) {\n                dirtyPathKeys.add(key);\n                dirtyPaths.push(path);\n            }\n        }\n    };\n    if (Path.operationCanTransformPath(op)) {\n        dirtyPaths = [];\n        dirtyPathKeys = new Set();\n        for (var path of oldDirtyPaths){\n            var newPath = Path.transform(path, op);\n            add(newPath);\n        }\n    } else {\n        dirtyPaths = oldDirtyPaths;\n        dirtyPathKeys = oldDirtyPathKeys;\n    }\n    var newDirtyPaths = editor.getDirtyPaths(op);\n    for (var _path of newDirtyPaths){\n        add(_path);\n    }\n    DIRTY_PATHS.set(editor, dirtyPaths);\n    DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n    Transforms.transform(editor, op);\n    editor.operations.push(op);\n    Editor.normalize(editor, {\n        operation: op\n    });\n    // Clear any formats applied to the cursor if the selection changes.\n    if (op.type === \"set_selection\") {\n        editor.marks = null;\n    }\n    if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true);\n        Promise.resolve().then(()=>{\n            FLUSHING.set(editor, false);\n            editor.onChange({\n                operation: op\n            });\n            editor.operations = [];\n        });\n    }\n};\n/**\n * Get the \"dirty\" paths generated from an operation.\n */ var getDirtyPaths = (editor, op)=>{\n    switch(op.type){\n        case \"insert_text\":\n        case \"remove_text\":\n        case \"set_node\":\n            {\n                var { path } = op;\n                return Path.levels(path);\n            }\n        case \"insert_node\":\n            {\n                var { node, path: _path } = op;\n                var levels = Path.levels(_path);\n                var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), (_ref)=>{\n                    var [, p] = _ref;\n                    return _path.concat(p);\n                });\n                return [\n                    ...levels,\n                    ...descendants\n                ];\n            }\n        case \"merge_node\":\n            {\n                var { path: _path2 } = op;\n                var ancestors = Path.ancestors(_path2);\n                var previousPath = Path.previous(_path2);\n                return [\n                    ...ancestors,\n                    previousPath\n                ];\n            }\n        case \"move_node\":\n            {\n                var { path: _path3, newPath } = op;\n                if (Path.equals(_path3, newPath)) {\n                    return [];\n                }\n                var oldAncestors = [];\n                var newAncestors = [];\n                for (var ancestor of Path.ancestors(_path3)){\n                    var p = Path.transform(ancestor, op);\n                    oldAncestors.push(p);\n                }\n                for (var _ancestor of Path.ancestors(newPath)){\n                    var _p = Path.transform(_ancestor, op);\n                    newAncestors.push(_p);\n                }\n                var newParent = newAncestors[newAncestors.length - 1];\n                var newIndex = newPath[newPath.length - 1];\n                var resultPath = newParent.concat(newIndex);\n                return [\n                    ...oldAncestors,\n                    ...newAncestors,\n                    resultPath\n                ];\n            }\n        case \"remove_node\":\n            {\n                var { path: _path4 } = op;\n                var _ancestors = Path.ancestors(_path4);\n                return [\n                    ..._ancestors\n                ];\n            }\n        case \"split_node\":\n            {\n                var { path: _path5 } = op;\n                var _levels = Path.levels(_path5);\n                var nextPath = Path.next(_path5);\n                return [\n                    ..._levels,\n                    nextPath\n                ];\n            }\n        default:\n            {\n                return [];\n            }\n    }\n};\nvar getFragment = (editor)=>{\n    var { selection } = editor;\n    if (selection) {\n        return Node.fragment(editor, selection);\n    }\n    return [];\n};\nvar normalizeNode = (editor, entry)=>{\n    var [node, path] = entry;\n    // There are no core normalizations for text nodes.\n    if (Text.isText(node)) {\n        return;\n    }\n    // Ensure that block and inline nodes have at least one text child.\n    if (Element.isElement(node) && node.children.length === 0) {\n        var child = {\n            text: \"\"\n        };\n        Transforms.insertNodes(editor, child, {\n            at: path.concat(0),\n            voids: true\n        });\n        return;\n    }\n    // Determine whether the node should have block or inline children.\n    var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0]));\n    // Since we'll be applying operations while iterating, keep track of an\n    // index that accounts for any added/removed nodes.\n    var n = 0;\n    for(var i = 0; i < node.children.length; i++, n++){\n        var currentNode = Node.get(editor, path);\n        if (Text.isText(currentNode)) continue;\n        var _child = currentNode.children[n];\n        var prev = currentNode.children[n - 1];\n        var isLast = i === node.children.length - 1;\n        var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child);\n        // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n        if (isInlineOrText !== shouldHaveInlines) {\n            Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n            });\n            n--;\n        } else if (Element.isElement(_child)) {\n            // Ensure that inline nodes are surrounded by text nodes.\n            if (editor.isInline(_child)) {\n                if (prev == null || !Text.isText(prev)) {\n                    var newChild = {\n                        text: \"\"\n                    };\n                    Transforms.insertNodes(editor, newChild, {\n                        at: path.concat(n),\n                        voids: true\n                    });\n                    n++;\n                } else if (isLast) {\n                    var _newChild = {\n                        text: \"\"\n                    };\n                    Transforms.insertNodes(editor, _newChild, {\n                        at: path.concat(n + 1),\n                        voids: true\n                    });\n                    n++;\n                }\n            }\n        } else {\n            // Merge adjacent text nodes that are empty or match.\n            if (prev != null && Text.isText(prev)) {\n                if (Text.equals(_child, prev, {\n                    loose: true\n                })) {\n                    Transforms.mergeNodes(editor, {\n                        at: path.concat(n),\n                        voids: true\n                    });\n                    n--;\n                } else if (prev.text === \"\") {\n                    Transforms.removeNodes(editor, {\n                        at: path.concat(n - 1),\n                        voids: true\n                    });\n                    n--;\n                } else if (_child.text === \"\") {\n                    Transforms.removeNodes(editor, {\n                        at: path.concat(n),\n                        voids: true\n                    });\n                    n--;\n                }\n            }\n        }\n    }\n};\nvar shouldNormalize = (editor, _ref)=>{\n    var { iteration, initialDirtyPathsLength } = _ref;\n    var maxIterations = initialDirtyPathsLength * 42; // HACK: better way?\n    if (iteration > maxIterations) {\n        throw new Error(\"Could not completely normalize the editor after \".concat(maxIterations, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\"));\n    }\n    return true;\n};\nvar above = function above(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { voids = false, mode = \"lowest\", at = editor.selection, match } = options;\n    if (!at) {\n        return;\n    }\n    var path = Editor.path(editor, at);\n    var reverse = mode === \"lowest\";\n    for (var [n, p] of Editor.levels(editor, {\n        at: path,\n        voids,\n        match,\n        reverse\n    })){\n        if (Text.isText(n)) continue;\n        if (Range.isRange(at)) {\n            if (Path.isAncestor(p, at.anchor.path) && Path.isAncestor(p, at.focus.path)) {\n                return [\n                    n,\n                    p\n                ];\n            }\n        } else {\n            if (!Path.equals(path, p)) {\n                return [\n                    n,\n                    p\n                ];\n            }\n        }\n    }\n};\nfunction ownKeys$8(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$8(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$8(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar addMark = (editor, key, value)=>{\n    var { selection } = editor;\n    if (selection) {\n        var match = (node, path)=>{\n            if (!Text.isText(node)) {\n                return false; // marks can only be applied to text\n            }\n            var [parentNode, parentPath] = Editor.parent(editor, path);\n            return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n        };\n        var expandedSelection = Range.isExpanded(selection);\n        var markAcceptingVoidSelected = false;\n        if (!expandedSelection) {\n            var [selectedNode, selectedPath] = Editor.node(editor, selection);\n            if (selectedNode && match(selectedNode, selectedPath)) {\n                var [parentNode] = Editor.parent(editor, selectedPath);\n                markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n            }\n        }\n        if (expandedSelection || markAcceptingVoidSelected) {\n            Transforms.setNodes(editor, {\n                [key]: value\n            }, {\n                match,\n                split: true,\n                voids: true\n            });\n        } else {\n            var marks = _objectSpread$8(_objectSpread$8({}, Editor.marks(editor) || {}), {}, {\n                [key]: value\n            });\n            editor.marks = marks;\n            if (!FLUSHING.get(editor)) {\n                editor.onChange();\n            }\n        }\n    }\n};\nfunction ownKeys$7(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$7(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$7(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar after = function after(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.point(editor, at, {\n        edge: \"end\"\n    });\n    var focus = Editor.end(editor, []);\n    var range = {\n        anchor,\n        focus\n    };\n    var { distance = 1 } = options;\n    var d = 0;\n    var target;\n    for (var p of Editor.positions(editor, _objectSpread$7(_objectSpread$7({}, options), {}, {\n        at: range\n    }))){\n        if (d > distance) {\n            break;\n        }\n        if (d !== 0) {\n            target = p;\n        }\n        d++;\n    }\n    return target;\n};\nfunction ownKeys$6(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$6(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$6(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar before = function before(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.start(editor, []);\n    var focus = Editor.point(editor, at, {\n        edge: \"start\"\n    });\n    var range = {\n        anchor,\n        focus\n    };\n    var { distance = 1 } = options;\n    var d = 0;\n    var target;\n    for (var p of Editor.positions(editor, _objectSpread$6(_objectSpread$6({}, options), {}, {\n        at: range,\n        reverse: true\n    }))){\n        if (d > distance) {\n            break;\n        }\n        if (d !== 0) {\n            target = p;\n        }\n        d++;\n    }\n    return target;\n};\nvar deleteBackward = (editor, unit)=>{\n    var { selection } = editor;\n    if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n            unit,\n            reverse: true\n        });\n    }\n};\nvar deleteForward = (editor, unit)=>{\n    var { selection } = editor;\n    if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n            unit\n        });\n    }\n};\nvar deleteFragment = function deleteFragment(editor) {\n    var { direction = \"forward\" } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { selection } = editor;\n    if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor, {\n            reverse: direction === \"backward\"\n        });\n    }\n};\nvar edges = (editor, at)=>{\n    return [\n        Editor.start(editor, at),\n        Editor.end(editor, at)\n    ];\n};\nfunction ownKeys$5(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$5(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$5(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar elementReadOnly = function elementReadOnly(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Editor.above(editor, _objectSpread$5(_objectSpread$5({}, options), {}, {\n        match: (n)=>Element.isElement(n) && Editor.isElementReadOnly(editor, n)\n    }));\n};\nvar end = (editor, at)=>{\n    return Editor.point(editor, at, {\n        edge: \"end\"\n    });\n};\nvar first = (editor, at)=>{\n    var path = Editor.path(editor, at, {\n        edge: \"start\"\n    });\n    return Editor.node(editor, path);\n};\nvar fragment = (editor, at)=>{\n    var range = Editor.range(editor, at);\n    return Node.fragment(editor, range);\n};\nfunction ownKeys$4(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$4(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$4(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar getVoid = function getVoid(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Editor.above(editor, _objectSpread$4(_objectSpread$4({}, options), {}, {\n        match: (n)=>Element.isElement(n) && Editor.isVoid(editor, n)\n    }));\n};\nvar hasBlocks = (editor, element)=>{\n    return element.children.some((n)=>Element.isElement(n) && Editor.isBlock(editor, n));\n};\nvar hasInlines = (editor, element)=>{\n    return element.children.some((n)=>Text.isText(n) || Editor.isInline(editor, n));\n};\nvar hasPath = (editor, path)=>{\n    return Node.has(editor, path);\n};\nvar hasTexts = (editor, element)=>{\n    return element.children.every((n)=>Text.isText(n));\n};\nvar insertBreak = (editor)=>{\n    Transforms.splitNodes(editor, {\n        always: true\n    });\n};\nvar insertNode = (editor, node, options)=>{\n    Transforms.insertNodes(editor, node, options);\n};\nvar insertSoftBreak = (editor)=>{\n    Transforms.splitNodes(editor, {\n        always: true\n    });\n};\nfunction ownKeys$3(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$3(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$3(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar insertText = function insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { selection, marks } = editor;\n    if (selection) {\n        if (marks) {\n            var node = _objectSpread$3({\n                text\n            }, marks);\n            Transforms.insertNodes(editor, node, {\n                at: options.at,\n                voids: options.voids\n            });\n        } else {\n            Transforms.insertText(editor, text, options);\n        }\n        editor.marks = null;\n    }\n};\nvar isBlock = (editor, value)=>{\n    return !editor.isInline(value);\n};\nvar isEdge = (editor, point, at)=>{\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n};\nvar isEmpty = (editor, element)=>{\n    var { children } = element;\n    var [first] = children;\n    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === \"\" && !editor.isVoid(element);\n};\nvar isEnd = (editor, point, at)=>{\n    var end = Editor.end(editor, at);\n    return Point.equals(point, end);\n};\nvar isNormalizing = (editor)=>{\n    var isNormalizing = NORMALIZING.get(editor);\n    return isNormalizing === undefined ? true : isNormalizing;\n};\nvar isStart = (editor, point, at)=>{\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n        return false;\n    }\n    var start = Editor.start(editor, at);\n    return Point.equals(point, start);\n};\nvar last = (editor, at)=>{\n    var path = Editor.path(editor, at, {\n        edge: \"end\"\n    });\n    return Editor.node(editor, path);\n};\nvar leaf = function leaf(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.leaf(editor, path);\n    return [\n        node,\n        path\n    ];\n};\nfunction levels(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function*() {\n        var { at = editor.selection, reverse = false, voids = false } = options;\n        var { match } = options;\n        if (match == null) {\n            match = ()=>true;\n        }\n        if (!at) {\n            return;\n        }\n        var levels = [];\n        var path = Editor.path(editor, at);\n        for (var [n, p] of Node.levels(editor, path)){\n            if (!match(n, p)) {\n                continue;\n            }\n            levels.push([\n                n,\n                p\n            ]);\n            if (!voids && Element.isElement(n) && Editor.isVoid(editor, n)) {\n                break;\n            }\n        }\n        if (reverse) {\n            levels.reverse();\n        }\n        yield* levels;\n    }();\n}\nvar _excluded$1 = [\n    \"text\"\n], _excluded2$1 = [\n    \"text\"\n];\nvar marks = function marks(editor) {\n    var { marks, selection } = editor;\n    if (!selection) {\n        return null;\n    }\n    if (marks) {\n        return marks;\n    }\n    if (Range.isExpanded(selection)) {\n        var [match] = Editor.nodes(editor, {\n            match: Text.isText\n        });\n        if (match) {\n            var [_node] = match;\n            var _rest = _objectWithoutProperties(_node, _excluded$1);\n            return _rest;\n        } else {\n            return {};\n        }\n    }\n    var { anchor } = selection;\n    var { path } = anchor;\n    var [node] = Editor.leaf(editor, path);\n    if (anchor.offset === 0) {\n        var prev = Editor.previous(editor, {\n            at: path,\n            match: Text.isText\n        });\n        var markedVoid = Editor.above(editor, {\n            match: (n)=>Element.isElement(n) && Editor.isVoid(editor, n) && editor.markableVoid(n)\n        });\n        if (!markedVoid) {\n            var block = Editor.above(editor, {\n                match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n)\n            });\n            if (prev && block) {\n                var [prevNode, prevPath] = prev;\n                var [, blockPath] = block;\n                if (Path.isAncestor(blockPath, prevPath)) {\n                    node = prevNode;\n                }\n            }\n        }\n    }\n    var rest = _objectWithoutProperties(node, _excluded2$1);\n    return rest;\n};\nvar next = function next(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { mode = \"lowest\", voids = false } = options;\n    var { match, at = editor.selection } = options;\n    if (!at) {\n        return;\n    }\n    var pointAfterLocation = Editor.after(editor, at, {\n        voids\n    });\n    if (!pointAfterLocation) return;\n    var [, to] = Editor.last(editor, []);\n    var span = [\n        pointAfterLocation.path,\n        to\n    ];\n    if (Path.isPath(at) && at.length === 0) {\n        throw new Error(\"Cannot get the next node from the root node!\");\n    }\n    if (match == null) {\n        if (Path.isPath(at)) {\n            var [parent] = Editor.parent(editor, at);\n            match = (n)=>parent.children.includes(n);\n        } else {\n            match = ()=>true;\n        }\n    }\n    var [next] = Editor.nodes(editor, {\n        at: span,\n        match,\n        mode,\n        voids\n    });\n    return next;\n};\nvar node = function node(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.get(editor, path);\n    return [\n        node,\n        path\n    ];\n};\nfunction nodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function*() {\n        var { at = editor.selection, mode = \"all\", universal = false, reverse = false, voids = false, ignoreNonSelectable = false } = options;\n        var { match } = options;\n        if (!match) {\n            match = ()=>true;\n        }\n        if (!at) {\n            return;\n        }\n        var from;\n        var to;\n        if (Span.isSpan(at)) {\n            from = at[0];\n            to = at[1];\n        } else {\n            var first = Editor.path(editor, at, {\n                edge: \"start\"\n            });\n            var last = Editor.path(editor, at, {\n                edge: \"end\"\n            });\n            from = reverse ? last : first;\n            to = reverse ? first : last;\n        }\n        var nodeEntries = Node.nodes(editor, {\n            reverse,\n            from,\n            to,\n            pass: (_ref)=>{\n                var [node] = _ref;\n                if (!Element.isElement(node)) return false;\n                if (!voids && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node))) return true;\n                if (ignoreNonSelectable && !Editor.isSelectable(editor, node)) return true;\n                return false;\n            }\n        });\n        var matches = [];\n        var hit;\n        for (var [node, path] of nodeEntries){\n            if (ignoreNonSelectable && Element.isElement(node) && !Editor.isSelectable(editor, node)) {\n                continue;\n            }\n            var isLower = hit && Path.compare(path, hit[1]) === 0;\n            // In highest mode any node lower than the last hit is not a match.\n            if (mode === \"highest\" && isLower) {\n                continue;\n            }\n            if (!match(node, path)) {\n                // If we've arrived at a leaf text node that is not lower than the last\n                // hit, then we've found a branch that doesn't include a match, which\n                // means the match is not universal.\n                if (universal && !isLower && Text.isText(node)) {\n                    return;\n                } else {\n                    continue;\n                }\n            }\n            // If there's a match and it's lower than the last, update the hit.\n            if (mode === \"lowest\" && isLower) {\n                hit = [\n                    node,\n                    path\n                ];\n                continue;\n            }\n            // In lowest mode we emit the last hit, once it's guaranteed lowest.\n            var emit = mode === \"lowest\" ? hit : [\n                node,\n                path\n            ];\n            if (emit) {\n                if (universal) {\n                    matches.push(emit);\n                } else {\n                    yield emit;\n                }\n            }\n            hit = [\n                node,\n                path\n            ];\n        }\n        // Since lowest is always emitting one behind, catch up at the end.\n        if (mode === \"lowest\" && hit) {\n            if (universal) {\n                matches.push(hit);\n            } else {\n                yield hit;\n            }\n        }\n        // Universal defers to ensure that the match occurs in every branch, so we\n        // yield all of the matches after iterating.\n        if (universal) {\n            yield* matches;\n        }\n    }();\n}\nvar normalize = function normalize(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { force = false, operation } = options;\n    var getDirtyPaths = (editor)=>{\n        return DIRTY_PATHS.get(editor) || [];\n    };\n    var getDirtyPathKeys = (editor)=>{\n        return DIRTY_PATH_KEYS.get(editor) || new Set();\n    };\n    var popDirtyPath = (editor)=>{\n        var path = getDirtyPaths(editor).pop();\n        var key = path.join(\",\");\n        getDirtyPathKeys(editor).delete(key);\n        return path;\n    };\n    if (!Editor.isNormalizing(editor)) {\n        return;\n    }\n    if (force) {\n        var allPaths = Array.from(Node.nodes(editor), (_ref)=>{\n            var [, p] = _ref;\n            return p;\n        });\n        var allPathKeys = new Set(allPaths.map((p)=>p.join(\",\")));\n        DIRTY_PATHS.set(editor, allPaths);\n        DIRTY_PATH_KEYS.set(editor, allPathKeys);\n    }\n    if (getDirtyPaths(editor).length === 0) {\n        return;\n    }\n    Editor.withoutNormalizing(editor, ()=>{\n        /*\n      Fix dirty elements with no children.\n      editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\n      Running an initial pass avoids the catch-22 race condition.\n    */ for (var dirtyPath of getDirtyPaths(editor)){\n            if (Node.has(editor, dirtyPath)) {\n                var entry = Editor.node(editor, dirtyPath);\n                var [node, _] = entry;\n                /*\n          The default normalizer inserts an empty text node in this scenario, but it can be customised.\n          So there is some risk here.\n                   As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\n          by definition adding children to an empty node can't cause other paths to change.\n        */ if (Element.isElement(node) && node.children.length === 0) {\n                    editor.normalizeNode(entry, {\n                        operation\n                    });\n                }\n            }\n        }\n        var dirtyPaths = getDirtyPaths(editor);\n        var initialDirtyPathsLength = dirtyPaths.length;\n        var iteration = 0;\n        while(dirtyPaths.length !== 0){\n            if (!editor.shouldNormalize({\n                dirtyPaths,\n                iteration,\n                initialDirtyPathsLength,\n                operation\n            })) {\n                return;\n            }\n            var _dirtyPath = popDirtyPath(editor);\n            // If the node doesn't exist in the tree, it does not need to be normalized.\n            if (Node.has(editor, _dirtyPath)) {\n                var _entry = Editor.node(editor, _dirtyPath);\n                editor.normalizeNode(_entry, {\n                    operation\n                });\n            }\n            iteration++;\n            dirtyPaths = getDirtyPaths(editor);\n        }\n    });\n};\nvar parent = function parent(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var parentPath = Path.parent(path);\n    var entry = Editor.node(editor, parentPath);\n    return entry;\n};\nvar pathRef = function pathRef(editor, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { affinity = \"forward\" } = options;\n    var ref = {\n        current: path,\n        affinity,\n        unref () {\n            var { current } = ref;\n            var pathRefs = Editor.pathRefs(editor);\n            pathRefs.delete(ref);\n            ref.current = null;\n            return current;\n        }\n    };\n    var refs = Editor.pathRefs(editor);\n    refs.add(ref);\n    return ref;\n};\nvar pathRefs = (editor)=>{\n    var refs = PATH_REFS.get(editor);\n    if (!refs) {\n        refs = new Set();\n        PATH_REFS.set(editor, refs);\n    }\n    return refs;\n};\nvar path = function path(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { depth, edge } = options;\n    if (Path.isPath(at)) {\n        if (edge === \"start\") {\n            var [, firstPath] = Node.first(editor, at);\n            at = firstPath;\n        } else if (edge === \"end\") {\n            var [, lastPath] = Node.last(editor, at);\n            at = lastPath;\n        }\n    }\n    if (Range.isRange(at)) {\n        if (edge === \"start\") {\n            at = Range.start(at);\n        } else if (edge === \"end\") {\n            at = Range.end(at);\n        } else {\n            at = Path.common(at.anchor.path, at.focus.path);\n        }\n    }\n    if (Point.isPoint(at)) {\n        at = at.path;\n    }\n    if (depth != null) {\n        at = at.slice(0, depth);\n    }\n    return at;\n};\nvar pointRef = function pointRef(editor, point) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { affinity = \"forward\" } = options;\n    var ref = {\n        current: point,\n        affinity,\n        unref () {\n            var { current } = ref;\n            var pointRefs = Editor.pointRefs(editor);\n            pointRefs.delete(ref);\n            ref.current = null;\n            return current;\n        }\n    };\n    var refs = Editor.pointRefs(editor);\n    refs.add(ref);\n    return ref;\n};\nvar pointRefs = (editor)=>{\n    var refs = POINT_REFS.get(editor);\n    if (!refs) {\n        refs = new Set();\n        POINT_REFS.set(editor, refs);\n    }\n    return refs;\n};\nvar point = function point(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { edge = \"start\" } = options;\n    if (Path.isPath(at)) {\n        var path;\n        if (edge === \"end\") {\n            var [, lastPath] = Node.last(editor, at);\n            path = lastPath;\n        } else {\n            var [, firstPath] = Node.first(editor, at);\n            path = firstPath;\n        }\n        var node = Node.get(editor, path);\n        if (!Text.isText(node)) {\n            throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n        }\n        return {\n            path,\n            offset: edge === \"end\" ? node.text.length : 0\n        };\n    }\n    if (Range.isRange(at)) {\n        var [start, end] = Range.edges(at);\n        return edge === \"start\" ? start : end;\n    }\n    return at;\n};\nfunction positions(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return function*() {\n        var { at = editor.selection, unit = \"offset\", reverse = false, voids = false, ignoreNonSelectable = false } = options;\n        if (!at) {\n            return;\n        }\n        /**\n     * Algorithm notes:\n     *\n     * Each step `distance` is dynamic depending on the underlying text\n     * and the `unit` specified.  Each step, e.g., a line or word, may\n     * span multiple text nodes, so we iterate through the text both on\n     * two levels in step-sync:\n     *\n     * `leafText` stores the text on a text leaf level, and is advanced\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\n     *\n     * `blockText` stores the text on a block level, and is shortened\n     * by `distance` every time it is advanced.\n     *\n     * We only maintain a window of one blockText and one leafText because\n     * a block node always appears before all of its leaf nodes.\n     */ var range = Editor.range(editor, at);\n        var [start, end] = Range.edges(range);\n        var first = reverse ? end : start;\n        var isNewBlock = false;\n        var blockText = \"\";\n        var distance = 0; // Distance for leafText to catch up to blockText.\n        var leafTextRemaining = 0;\n        var leafTextOffset = 0;\n        // Iterate through all nodes in range, grabbing entire textual content\n        // of block nodes in blockText, and text nodes in leafText.\n        // Exploits the fact that nodes are sequenced in such a way that we first\n        // encounter the block node, then all of its text nodes, so when iterating\n        // through the blockText and leafText we just need to remember a window of\n        // one block node and leaf node, respectively.\n        for (var [node, path] of Editor.nodes(editor, {\n            at,\n            reverse,\n            voids,\n            ignoreNonSelectable\n        })){\n            /*\n       * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\n       */ if (Element.isElement(node)) {\n                // Void nodes are a special case, so by default we will always\n                // yield their first point. If the `voids` option is set to true,\n                // then we will iterate over their content.\n                if (!voids && (editor.isVoid(node) || editor.isElementReadOnly(node))) {\n                    yield Editor.start(editor, path);\n                    continue;\n                }\n                // Inline element nodes are ignored as they don't themselves\n                // contribute to `blockText` or `leafText` - their parent and\n                // children do.\n                if (editor.isInline(node)) continue;\n                // Block element node - set `blockText` to its text content.\n                if (Editor.hasInlines(editor, node)) {\n                    // We always exhaust block nodes before encountering a new one:\n                    //   console.assert(blockText === '',\n                    //     `blockText='${blockText}' - `+\n                    //     `not exhausted before new block node`, path)\n                    // Ensure range considered is capped to `range`, in the\n                    // start/end edge cases where block extends beyond range.\n                    // Equivalent to this, but presumably more performant:\n                    //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n                    //   blockRange = Range.intersection(range, blockRange) // intersect\n                    //   blockText = Editor.string(editor, blockRange, { voids })\n                    var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n                    var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n                    blockText = Editor.string(editor, {\n                        anchor: s,\n                        focus: e\n                    }, {\n                        voids\n                    });\n                    isNewBlock = true;\n                }\n            }\n            /*\n       * TEXT LEAF NODE - Iterate through text content, yielding\n       * positions every `distance` offset according to `unit`.\n       */ if (Text.isText(node)) {\n                var isFirst = Path.equals(path, first.path);\n                // Proof that we always exhaust text nodes before encountering a new one:\n                //   console.assert(leafTextRemaining <= 0,\n                //     `leafTextRemaining=${leafTextRemaining} - `+\n                //     `not exhausted before new leaf text node`, path)\n                // Reset `leafText` counters for new text node.\n                if (isFirst) {\n                    leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n                    leafTextOffset = first.offset; // Works for reverse too.\n                } else {\n                    leafTextRemaining = node.text.length;\n                    leafTextOffset = reverse ? leafTextRemaining : 0;\n                }\n                // Yield position at the start of node (potentially).\n                if (isFirst || isNewBlock || unit === \"offset\") {\n                    yield {\n                        path,\n                        offset: leafTextOffset\n                    };\n                    isNewBlock = false;\n                }\n                // Yield positions every (dynamically calculated) `distance` offset.\n                while(true){\n                    // If `leafText` has caught up with `blockText` (distance=0),\n                    // and if blockText is exhausted, break to get another block node,\n                    // otherwise advance blockText forward by the new `distance`.\n                    if (distance === 0) {\n                        if (blockText === \"\") break;\n                        distance = calcDistance(blockText, unit, reverse);\n                        // Split the string at the previously found distance and use the\n                        // remaining string for the next iteration.\n                        blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n                    }\n                    // Advance `leafText` by the current `distance`.\n                    leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n                    leafTextRemaining = leafTextRemaining - distance;\n                    // If `leafText` is exhausted, break to get a new leaf node\n                    // and set distance to the overflow amount, so we'll (maybe)\n                    // catch up to blockText in the next leaf text node.\n                    if (leafTextRemaining < 0) {\n                        distance = -leafTextRemaining;\n                        break;\n                    }\n                    // Successfully walked `distance` offsets through `leafText`\n                    // to catch up with `blockText`, so we can reset `distance`\n                    // and yield this position in this node.\n                    distance = 0;\n                    yield {\n                        path,\n                        offset: leafTextOffset\n                    };\n                }\n            }\n        }\n        // Proof that upon completion, we've exahusted both leaf and block text:\n        //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n        //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n        // Helper:\n        // Return the distance in offsets for a step of size `unit` on given string.\n        function calcDistance(text, unit, reverse) {\n            if (unit === \"character\") {\n                return getCharacterDistance(text, reverse);\n            } else if (unit === \"word\") {\n                return getWordDistance(text, reverse);\n            } else if (unit === \"line\" || unit === \"block\") {\n                return text.length;\n            }\n            return 1;\n        }\n    }();\n}\nvar previous = function previous(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { mode = \"lowest\", voids = false } = options;\n    var { match, at = editor.selection } = options;\n    if (!at) {\n        return;\n    }\n    var pointBeforeLocation = Editor.before(editor, at, {\n        voids\n    });\n    if (!pointBeforeLocation) {\n        return;\n    }\n    var [, to] = Editor.first(editor, []);\n    // The search location is from the start of the document to the path of\n    // the point before the location passed in\n    var span = [\n        pointBeforeLocation.path,\n        to\n    ];\n    if (Path.isPath(at) && at.length === 0) {\n        throw new Error(\"Cannot get the previous node from the root node!\");\n    }\n    if (match == null) {\n        if (Path.isPath(at)) {\n            var [parent] = Editor.parent(editor, at);\n            match = (n)=>parent.children.includes(n);\n        } else {\n            match = ()=>true;\n        }\n    }\n    var [previous] = Editor.nodes(editor, {\n        reverse: true,\n        at: span,\n        match,\n        mode,\n        voids\n    });\n    return previous;\n};\nvar rangeRef = function rangeRef(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { affinity = \"forward\" } = options;\n    var ref = {\n        current: range,\n        affinity,\n        unref () {\n            var { current } = ref;\n            var rangeRefs = Editor.rangeRefs(editor);\n            rangeRefs.delete(ref);\n            ref.current = null;\n            return current;\n        }\n    };\n    var refs = Editor.rangeRefs(editor);\n    refs.add(ref);\n    return ref;\n};\nvar rangeRefs = (editor)=>{\n    var refs = RANGE_REFS.get(editor);\n    if (!refs) {\n        refs = new Set();\n        RANGE_REFS.set(editor, refs);\n    }\n    return refs;\n};\nvar range = (editor, at, to)=>{\n    if (Range.isRange(at) && !to) {\n        return at;\n    }\n    var start = Editor.start(editor, at);\n    var end = Editor.end(editor, to || at);\n    return {\n        anchor: start,\n        focus: end\n    };\n};\nfunction ownKeys$2(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$2(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar removeMark = (editor, key)=>{\n    var { selection } = editor;\n    if (selection) {\n        var match = (node, path)=>{\n            if (!Text.isText(node)) {\n                return false; // marks can only be applied to text\n            }\n            var [parentNode, parentPath] = Editor.parent(editor, path);\n            return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n        };\n        var expandedSelection = Range.isExpanded(selection);\n        var markAcceptingVoidSelected = false;\n        if (!expandedSelection) {\n            var [selectedNode, selectedPath] = Editor.node(editor, selection);\n            if (selectedNode && match(selectedNode, selectedPath)) {\n                var [parentNode] = Editor.parent(editor, selectedPath);\n                markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n            }\n        }\n        if (expandedSelection || markAcceptingVoidSelected) {\n            Transforms.unsetNodes(editor, key, {\n                match,\n                split: true,\n                voids: true\n            });\n        } else {\n            var marks = _objectSpread$2({}, Editor.marks(editor) || {});\n            delete marks[key];\n            editor.marks = marks;\n            if (!FLUSHING.get(editor)) {\n                editor.onChange();\n            }\n        }\n    }\n};\nvar setNormalizing = (editor, isNormalizing)=>{\n    NORMALIZING.set(editor, isNormalizing);\n};\nvar start = (editor, at)=>{\n    return Editor.point(editor, at, {\n        edge: \"start\"\n    });\n};\nvar string = function string(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { voids = false } = options;\n    var range = Editor.range(editor, at);\n    var [start, end] = Range.edges(range);\n    var text = \"\";\n    for (var [node, path] of Editor.nodes(editor, {\n        at: range,\n        match: Text.isText,\n        voids\n    })){\n        var t = node.text;\n        if (Path.equals(path, end.path)) {\n            t = t.slice(0, end.offset);\n        }\n        if (Path.equals(path, start.path)) {\n            t = t.slice(start.offset);\n        }\n        text += t;\n    }\n    return text;\n};\nvar unhangRange = function unhangRange(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { voids = false } = options;\n    var [start, end] = Range.edges(range);\n    // PERF: exit early if we can guarantee that the range isn't hanging.\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range) || Path.hasPrevious(end.path)) {\n        return range;\n    }\n    var endBlock = Editor.above(editor, {\n        at: end,\n        match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n        voids\n    });\n    var blockPath = endBlock ? endBlock[1] : [];\n    var first = Editor.start(editor, start);\n    var before = {\n        anchor: first,\n        focus: end\n    };\n    var skip = true;\n    for (var [node, path] of Editor.nodes(editor, {\n        at: before,\n        match: Text.isText,\n        reverse: true,\n        voids\n    })){\n        if (skip) {\n            skip = false;\n            continue;\n        }\n        if (node.text !== \"\" || Path.isBefore(path, blockPath)) {\n            end = {\n                path,\n                offset: node.text.length\n            };\n            break;\n        }\n    }\n    return {\n        anchor: start,\n        focus: end\n    };\n};\nvar withoutNormalizing = (editor, fn)=>{\n    var value = Editor.isNormalizing(editor);\n    Editor.setNormalizing(editor, false);\n    try {\n        fn();\n    } finally{\n        Editor.setNormalizing(editor, value);\n    }\n    Editor.normalize(editor);\n};\nvar deleteText = function deleteText(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var _Editor$void, _Editor$void2;\n        var { reverse = false, unit = \"character\", distance = 1, voids = false } = options;\n        var { at = editor.selection, hanging = false } = options;\n        if (!at) {\n            return;\n        }\n        var isCollapsed = false;\n        if (Range.isRange(at) && Range.isCollapsed(at)) {\n            isCollapsed = true;\n            at = at.anchor;\n        }\n        if (Point.isPoint(at)) {\n            var furthestVoid = Editor.void(editor, {\n                at,\n                mode: \"highest\"\n            });\n            if (!voids && furthestVoid) {\n                var [, voidPath] = furthestVoid;\n                at = voidPath;\n            } else {\n                var opts = {\n                    unit,\n                    distance\n                };\n                var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n                at = {\n                    anchor: at,\n                    focus: target\n                };\n                hanging = true;\n            }\n        }\n        if (Path.isPath(at)) {\n            Transforms.removeNodes(editor, {\n                at,\n                voids\n            });\n            return;\n        }\n        if (Range.isCollapsed(at)) {\n            return;\n        }\n        if (!hanging) {\n            var [, _end] = Range.edges(at);\n            var endOfDoc = Editor.end(editor, []);\n            if (!Point.equals(_end, endOfDoc)) {\n                at = Editor.unhangRange(editor, at, {\n                    voids\n                });\n            }\n        }\n        var [start, end] = Range.edges(at);\n        var startBlock = Editor.above(editor, {\n            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n            at: start,\n            voids\n        });\n        var endBlock = Editor.above(editor, {\n            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n            at: end,\n            voids\n        });\n        var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n        var isSingleText = Path.equals(start.path, end.path);\n        var startNonEditable = voids ? null : (_Editor$void = Editor.void(editor, {\n            at: start,\n            mode: \"highest\"\n        })) !== null && _Editor$void !== void 0 ? _Editor$void : Editor.elementReadOnly(editor, {\n            at: start,\n            mode: \"highest\"\n        });\n        var endNonEditable = voids ? null : (_Editor$void2 = Editor.void(editor, {\n            at: end,\n            mode: \"highest\"\n        })) !== null && _Editor$void2 !== void 0 ? _Editor$void2 : Editor.elementReadOnly(editor, {\n            at: end,\n            mode: \"highest\"\n        });\n        // If the start or end points are inside an inline void, nudge them out.\n        if (startNonEditable) {\n            var before = Editor.before(editor, start);\n            if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n                start = before;\n            }\n        }\n        if (endNonEditable) {\n            var after = Editor.after(editor, end);\n            if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n                end = after;\n            }\n        }\n        // Get the highest nodes that are completely inside the range, as well as\n        // the start and end nodes.\n        var matches = [];\n        var lastPath;\n        for (var entry of Editor.nodes(editor, {\n            at,\n            voids\n        })){\n            var [node, path] = entry;\n            if (lastPath && Path.compare(path, lastPath) === 0) {\n                continue;\n            }\n            if (!voids && Element.isElement(node) && (Editor.isVoid(editor, node) || Editor.isElementReadOnly(editor, node)) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n                matches.push(entry);\n                lastPath = path;\n            }\n        }\n        var pathRefs = Array.from(matches, (_ref)=>{\n            var [, p] = _ref;\n            return Editor.pathRef(editor, p);\n        });\n        var startRef = Editor.pointRef(editor, start);\n        var endRef = Editor.pointRef(editor, end);\n        var removedText = \"\";\n        if (!isSingleText && !startNonEditable) {\n            var _point = startRef.current;\n            var [_node] = Editor.leaf(editor, _point);\n            var { path: _path } = _point;\n            var { offset } = start;\n            var text = _node.text.slice(offset);\n            if (text.length > 0) {\n                editor.apply({\n                    type: \"remove_text\",\n                    path: _path,\n                    offset,\n                    text\n                });\n                removedText = text;\n            }\n        }\n        pathRefs.reverse().map((r)=>r.unref()).filter((r)=>r !== null).forEach((p)=>Transforms.removeNodes(editor, {\n                at: p,\n                voids\n            }));\n        if (!endNonEditable) {\n            var _point2 = endRef.current;\n            var [_node2] = Editor.leaf(editor, _point2);\n            var { path: _path2 } = _point2;\n            var _offset = isSingleText ? start.offset : 0;\n            var _text = _node2.text.slice(_offset, end.offset);\n            if (_text.length > 0) {\n                editor.apply({\n                    type: \"remove_text\",\n                    path: _path2,\n                    offset: _offset,\n                    text: _text\n                });\n                removedText = _text;\n            }\n        }\n        if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n            Transforms.mergeNodes(editor, {\n                at: endRef.current,\n                hanging: true,\n                voids\n            });\n        }\n        // For Thai script, deleting N character(s) backward should delete\n        // N code point(s) instead of an entire grapheme cluster.\n        // Therefore, the remaining code points should be inserted back.\n        if (isCollapsed && reverse && unit === \"character\" && removedText.length > 1 && removedText.match(/[\\u0E00-\\u0E7F]+/)) {\n            Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n        }\n        var startUnref = startRef.unref();\n        var endUnref = endRef.unref();\n        var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n        if (options.at == null && point) {\n            Transforms.select(editor, point);\n        }\n    });\n};\nvar insertFragment = function insertFragment(editor, fragment) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { hanging = false, voids = false } = options;\n        var { at = getDefaultInsertLocation(editor) } = options;\n        if (!fragment.length) {\n            return;\n        }\n        if (Range.isRange(at)) {\n            if (!hanging) {\n                at = Editor.unhangRange(editor, at, {\n                    voids\n                });\n            }\n            if (Range.isCollapsed(at)) {\n                at = at.anchor;\n            } else {\n                var [, end] = Range.edges(at);\n                if (!voids && Editor.void(editor, {\n                    at: end\n                })) {\n                    return;\n                }\n                var pointRef = Editor.pointRef(editor, end);\n                Transforms.delete(editor, {\n                    at\n                });\n                at = pointRef.unref();\n            }\n        } else if (Path.isPath(at)) {\n            at = Editor.start(editor, at);\n        }\n        if (!voids && Editor.void(editor, {\n            at\n        })) {\n            return;\n        }\n        // If the insert point is at the edge of an inline node, move it outside\n        // instead since it will need to be split otherwise.\n        var inlineElementMatch = Editor.above(editor, {\n            at,\n            match: (n)=>Element.isElement(n) && Editor.isInline(editor, n),\n            mode: \"highest\",\n            voids\n        });\n        if (inlineElementMatch) {\n            var [, _inlinePath] = inlineElementMatch;\n            if (Editor.isEnd(editor, at, _inlinePath)) {\n                var after = Editor.after(editor, _inlinePath);\n                at = after;\n            } else if (Editor.isStart(editor, at, _inlinePath)) {\n                var before = Editor.before(editor, _inlinePath);\n                at = before;\n            }\n        }\n        var blockMatch = Editor.above(editor, {\n            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n            at,\n            voids\n        });\n        var [, blockPath] = blockMatch;\n        var isBlockStart = Editor.isStart(editor, at, blockPath);\n        var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n        var isBlockEmpty = isBlockStart && isBlockEnd;\n        var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n        var mergeEnd = !isBlockEnd;\n        var [, firstPath] = Node.first({\n            children: fragment\n        }, []);\n        var [, lastPath] = Node.last({\n            children: fragment\n        }, []);\n        var matches = [];\n        var matcher = (_ref)=>{\n            var [n, p] = _ref;\n            var isRoot = p.length === 0;\n            if (isRoot) {\n                return false;\n            }\n            if (isBlockEmpty) {\n                return true;\n            }\n            if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n                return false;\n            }\n            if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n                return false;\n            }\n            return true;\n        };\n        for (var entry of Node.nodes({\n            children: fragment\n        }, {\n            pass: matcher\n        })){\n            if (matcher(entry)) {\n                matches.push(entry);\n            }\n        }\n        var starts = [];\n        var middles = [];\n        var ends = [];\n        var starting = true;\n        var hasBlocks = false;\n        for (var [node] of matches){\n            if (Element.isElement(node) && !editor.isInline(node)) {\n                starting = false;\n                hasBlocks = true;\n                middles.push(node);\n            } else if (starting) {\n                starts.push(node);\n            } else {\n                ends.push(node);\n            }\n        }\n        var [inlineMatch] = Editor.nodes(editor, {\n            at,\n            match: (n)=>Text.isText(n) || Editor.isInline(editor, n),\n            mode: \"highest\",\n            voids\n        });\n        var [, inlinePath] = inlineMatch;\n        var isInlineStart = Editor.isStart(editor, at, inlinePath);\n        var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n        var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n        var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n        Transforms.splitNodes(editor, {\n            at,\n            match: (n)=>hasBlocks ? Element.isElement(n) && Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n),\n            mode: hasBlocks ? \"lowest\" : \"highest\",\n            always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n            voids\n        });\n        var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n        Transforms.insertNodes(editor, starts, {\n            at: startRef.current,\n            match: (n)=>Text.isText(n) || Editor.isInline(editor, n),\n            mode: \"highest\",\n            voids\n        });\n        if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n            Transforms.delete(editor, {\n                at: blockPath,\n                voids\n            });\n        }\n        Transforms.insertNodes(editor, middles, {\n            at: middleRef.current,\n            match: (n)=>Element.isElement(n) && Editor.isBlock(editor, n),\n            mode: \"lowest\",\n            voids\n        });\n        Transforms.insertNodes(editor, ends, {\n            at: endRef.current,\n            match: (n)=>Text.isText(n) || Editor.isInline(editor, n),\n            mode: \"highest\",\n            voids\n        });\n        if (!options.at) {\n            var path;\n            if (ends.length > 0 && endRef.current) {\n                path = Path.previous(endRef.current);\n            } else if (middles.length > 0 && middleRef.current) {\n                path = Path.previous(middleRef.current);\n            } else if (startRef.current) {\n                path = Path.previous(startRef.current);\n            }\n            if (path) {\n                var _end = Editor.end(editor, path);\n                Transforms.select(editor, _end);\n            }\n        }\n        startRef.unref();\n        middleRef.unref();\n        endRef.unref();\n    });\n};\nvar collapse = function collapse(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { edge = \"anchor\" } = options;\n    var { selection } = editor;\n    if (!selection) {\n        return;\n    } else if (edge === \"anchor\") {\n        Transforms.select(editor, selection.anchor);\n    } else if (edge === \"focus\") {\n        Transforms.select(editor, selection.focus);\n    } else if (edge === \"start\") {\n        var [start] = Range.edges(selection);\n        Transforms.select(editor, start);\n    } else if (edge === \"end\") {\n        var [, end] = Range.edges(selection);\n        Transforms.select(editor, end);\n    }\n};\nvar deselect = (editor)=>{\n    var { selection } = editor;\n    if (selection) {\n        editor.apply({\n            type: \"set_selection\",\n            properties: selection,\n            newProperties: null\n        });\n    }\n};\nvar move = function move(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var { selection } = editor;\n    var { distance = 1, unit = \"character\", reverse = false } = options;\n    var { edge = null } = options;\n    if (!selection) {\n        return;\n    }\n    if (edge === \"start\") {\n        edge = Range.isBackward(selection) ? \"focus\" : \"anchor\";\n    }\n    if (edge === \"end\") {\n        edge = Range.isBackward(selection) ? \"anchor\" : \"focus\";\n    }\n    var { anchor, focus } = selection;\n    var opts = {\n        distance,\n        unit,\n        ignoreNonSelectable: true\n    };\n    var props = {};\n    if (edge == null || edge === \"anchor\") {\n        var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n        if (point) {\n            props.anchor = point;\n        }\n    }\n    if (edge == null || edge === \"focus\") {\n        var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n        if (_point) {\n            props.focus = _point;\n        }\n    }\n    Transforms.setSelection(editor, props);\n};\nvar select = (editor, target)=>{\n    var { selection } = editor;\n    target = Editor.range(editor, target);\n    if (selection) {\n        Transforms.setSelection(editor, target);\n        return;\n    }\n    if (!Range.isRange(target)) {\n        throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n    }\n    editor.apply({\n        type: \"set_selection\",\n        properties: selection,\n        newProperties: target\n    });\n};\nfunction ownKeys$1(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread$1(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys$1(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar setPoint = function setPoint(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var { selection } = editor;\n    var { edge = \"both\" } = options;\n    if (!selection) {\n        return;\n    }\n    if (edge === \"start\") {\n        edge = Range.isBackward(selection) ? \"focus\" : \"anchor\";\n    }\n    if (edge === \"end\") {\n        edge = Range.isBackward(selection) ? \"anchor\" : \"focus\";\n    }\n    var { anchor, focus } = selection;\n    var point = edge === \"anchor\" ? anchor : focus;\n    Transforms.setSelection(editor, {\n        [edge === \"anchor\" ? \"anchor\" : \"focus\"]: _objectSpread$1(_objectSpread$1({}, point), props)\n    });\n};\nvar setSelection = (editor, props)=>{\n    var { selection } = editor;\n    var oldProps = {};\n    var newProps = {};\n    if (!selection) {\n        return;\n    }\n    for(var k in props){\n        if (k === \"anchor\" && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === \"focus\" && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== \"anchor\" && k !== \"focus\" && props[k] !== selection[k]) {\n            oldProps[k] = selection[k];\n            newProps[k] = props[k];\n        }\n    }\n    if (Object.keys(oldProps).length > 0) {\n        editor.apply({\n            type: \"set_selection\",\n            properties: oldProps,\n            newProperties: newProps\n        });\n    }\n};\nvar insertNodes = function insertNodes(editor, nodes) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { hanging = false, voids = false, mode = \"lowest\" } = options;\n        var { at, match, select } = options;\n        if (Node.isNode(nodes)) {\n            nodes = [\n                nodes\n            ];\n        }\n        if (nodes.length === 0) {\n            return;\n        }\n        var [node] = nodes;\n        if (!at) {\n            at = getDefaultInsertLocation(editor);\n            select = true;\n        }\n        if (select == null) {\n            select = false;\n        }\n        if (Range.isRange(at)) {\n            if (!hanging) {\n                at = Editor.unhangRange(editor, at, {\n                    voids\n                });\n            }\n            if (Range.isCollapsed(at)) {\n                at = at.anchor;\n            } else {\n                var [, end] = Range.edges(at);\n                var pointRef = Editor.pointRef(editor, end);\n                Transforms.delete(editor, {\n                    at\n                });\n                at = pointRef.unref();\n            }\n        }\n        if (Point.isPoint(at)) {\n            if (match == null) {\n                if (Text.isText(node)) {\n                    match = (n)=>Text.isText(n);\n                } else if (editor.isInline(node)) {\n                    match = (n)=>Text.isText(n) || Editor.isInline(editor, n);\n                } else {\n                    match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n                }\n            }\n            var [entry] = Editor.nodes(editor, {\n                at: at.path,\n                match,\n                mode,\n                voids\n            });\n            if (entry) {\n                var [, matchPath] = entry;\n                var pathRef = Editor.pathRef(editor, matchPath);\n                var isAtEnd = Editor.isEnd(editor, at, matchPath);\n                Transforms.splitNodes(editor, {\n                    at,\n                    match,\n                    mode,\n                    voids\n                });\n                var path = pathRef.unref();\n                at = isAtEnd ? Path.next(path) : path;\n            } else {\n                return;\n            }\n        }\n        var parentPath = Path.parent(at);\n        var index = at[at.length - 1];\n        if (!voids && Editor.void(editor, {\n            at: parentPath\n        })) {\n            return;\n        }\n        for (var _node of nodes){\n            var _path = parentPath.concat(index);\n            index++;\n            editor.apply({\n                type: \"insert_node\",\n                path: _path,\n                node: _node\n            });\n            at = Path.next(at);\n        }\n        at = Path.previous(at);\n        if (select) {\n            var point = Editor.end(editor, at);\n            if (point) {\n                Transforms.select(editor, point);\n            }\n        }\n    });\n};\nvar liftNodes = function liftNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { at = editor.selection, mode = \"lowest\", voids = false } = options;\n        var { match } = options;\n        if (match == null) {\n            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        if (!at) {\n            return;\n        }\n        var matches = Editor.nodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n        });\n        var pathRefs = Array.from(matches, (_ref)=>{\n            var [, p] = _ref;\n            return Editor.pathRef(editor, p);\n        });\n        for (var pathRef of pathRefs){\n            var path = pathRef.unref();\n            if (path.length < 2) {\n                throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n            }\n            var parentNodeEntry = Editor.node(editor, Path.parent(path));\n            var [parent, parentPath] = parentNodeEntry;\n            var index = path[path.length - 1];\n            var { length } = parent.children;\n            if (length === 1) {\n                var toPath = Path.next(parentPath);\n                Transforms.moveNodes(editor, {\n                    at: path,\n                    to: toPath,\n                    voids\n                });\n                Transforms.removeNodes(editor, {\n                    at: parentPath,\n                    voids\n                });\n            } else if (index === 0) {\n                Transforms.moveNodes(editor, {\n                    at: path,\n                    to: parentPath,\n                    voids\n                });\n            } else if (index === length - 1) {\n                var _toPath = Path.next(parentPath);\n                Transforms.moveNodes(editor, {\n                    at: path,\n                    to: _toPath,\n                    voids\n                });\n            } else {\n                var splitPath = Path.next(path);\n                var _toPath2 = Path.next(parentPath);\n                Transforms.splitNodes(editor, {\n                    at: splitPath,\n                    voids\n                });\n                Transforms.moveNodes(editor, {\n                    at: path,\n                    to: _toPath2,\n                    voids\n                });\n            }\n        }\n    });\n};\nvar _excluded = [\n    \"text\"\n], _excluded2 = [\n    \"children\"\n];\nvar hasSingleChildNest = (editor, node)=>{\n    if (Element.isElement(node)) {\n        var element = node;\n        if (Editor.isVoid(editor, node)) {\n            return true;\n        } else if (element.children.length === 1) {\n            return hasSingleChildNest(editor, element.children[0]);\n        } else {\n            return false;\n        }\n    } else if (Editor.isEditor(node)) {\n        return false;\n    } else {\n        return true;\n    }\n};\nvar mergeNodes = function mergeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { match, at = editor.selection } = options;\n        var { hanging = false, voids = false, mode = \"lowest\" } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            if (Path.isPath(at)) {\n                var [parent] = Editor.parent(editor, at);\n                match = (n)=>parent.children.includes(n);\n            } else {\n                match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n        }\n        if (!hanging && Range.isRange(at)) {\n            at = Editor.unhangRange(editor, at, {\n                voids\n            });\n        }\n        if (Range.isRange(at)) {\n            if (Range.isCollapsed(at)) {\n                at = at.anchor;\n            } else {\n                var [, end] = Range.edges(at);\n                var pointRef = Editor.pointRef(editor, end);\n                Transforms.delete(editor, {\n                    at\n                });\n                at = pointRef.unref();\n                if (options.at == null) {\n                    Transforms.select(editor, at);\n                }\n            }\n        }\n        var [current] = Editor.nodes(editor, {\n            at,\n            match,\n            voids,\n            mode\n        });\n        var prev = Editor.previous(editor, {\n            at,\n            match,\n            voids,\n            mode\n        });\n        if (!current || !prev) {\n            return;\n        }\n        var [node, path] = current;\n        var [prevNode, prevPath] = prev;\n        if (path.length === 0 || prevPath.length === 0) {\n            return;\n        }\n        var newPath = Path.next(prevPath);\n        var commonPath = Path.common(path, prevPath);\n        var isPreviousSibling = Path.isSibling(path, prevPath);\n        var levels = Array.from(Editor.levels(editor, {\n            at: path\n        }), (_ref)=>{\n            var [n] = _ref;\n            return n;\n        }).slice(commonPath.length).slice(0, -1);\n        // Determine if the merge will leave an ancestor of the path empty as a\n        // result, in which case we'll want to remove it after merging.\n        var emptyAncestor = Editor.above(editor, {\n            at: path,\n            mode: \"highest\",\n            match: (n)=>levels.includes(n) && hasSingleChildNest(editor, n)\n        });\n        var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n        var properties;\n        var position;\n        // Ensure that the nodes are equivalent, and figure out what the position\n        // and extra properties of the merge will be.\n        if (Text.isText(node) && Text.isText(prevNode)) {\n            var rest = _objectWithoutProperties(node, _excluded);\n            position = prevNode.text.length;\n            properties = rest;\n        } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n            var rest = _objectWithoutProperties(node, _excluded2);\n            position = prevNode.children.length;\n            properties = rest;\n        } else {\n            throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n        }\n        // If the node isn't already the next sibling of the previous node, move\n        // it so that it is before merging.\n        if (!isPreviousSibling) {\n            Transforms.moveNodes(editor, {\n                at: path,\n                to: newPath,\n                voids\n            });\n        }\n        // If there was going to be an empty ancestor of the node that was merged,\n        // we remove it from the tree.\n        if (emptyRef) {\n            Transforms.removeNodes(editor, {\n                at: emptyRef.current,\n                voids\n            });\n        }\n        // If the target node that we're merging with is empty, remove it instead\n        // of merging the two. This is a common rich text editor behavior to\n        // prevent losing formatting when deleting entire nodes when you have a\n        // hanging selection.\n        // if prevNode is first child in parent,don't remove it.\n        if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === \"\" && prevPath[prevPath.length - 1] !== 0) {\n            Transforms.removeNodes(editor, {\n                at: prevPath,\n                voids\n            });\n        } else {\n            editor.apply({\n                type: \"merge_node\",\n                path: newPath,\n                position,\n                properties\n            });\n        }\n        if (emptyRef) {\n            emptyRef.unref();\n        }\n    });\n};\nvar moveNodes = (editor, options)=>{\n    Editor.withoutNormalizing(editor, ()=>{\n        var { to, at = editor.selection, mode = \"lowest\", voids = false } = options;\n        var { match } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        var toRef = Editor.pathRef(editor, to);\n        var targets = Editor.nodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n        });\n        var pathRefs = Array.from(targets, (_ref)=>{\n            var [, p] = _ref;\n            return Editor.pathRef(editor, p);\n        });\n        for (var pathRef of pathRefs){\n            var path = pathRef.unref();\n            var newPath = toRef.current;\n            if (path.length !== 0) {\n                editor.apply({\n                    type: \"move_node\",\n                    path,\n                    newPath\n                });\n            }\n            if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n                // When performing a sibling move to a later index, the path at the destination is shifted\n                // to before the insertion point instead of after. To ensure our group of nodes are inserted\n                // in the correct order we increment toRef to account for that\n                toRef.current = Path.next(toRef.current);\n            }\n        }\n        toRef.unref();\n    });\n};\nvar removeNodes = function removeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { hanging = false, voids = false, mode = \"lowest\" } = options;\n        var { at = editor.selection, match } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        if (!hanging && Range.isRange(at)) {\n            at = Editor.unhangRange(editor, at, {\n                voids\n            });\n        }\n        var depths = Editor.nodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n        });\n        var pathRefs = Array.from(depths, (_ref)=>{\n            var [, p] = _ref;\n            return Editor.pathRef(editor, p);\n        });\n        for (var pathRef of pathRefs){\n            var path = pathRef.unref();\n            if (path) {\n                var [node] = Editor.node(editor, path);\n                editor.apply({\n                    type: \"remove_node\",\n                    path,\n                    node\n                });\n            }\n        }\n    });\n};\nvar setNodes = function setNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { match, at = editor.selection, compare, merge } = options;\n        var { hanging = false, mode = \"lowest\", split = false, voids = false } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        if (!hanging && Range.isRange(at)) {\n            at = Editor.unhangRange(editor, at, {\n                voids\n            });\n        }\n        if (split && Range.isRange(at)) {\n            if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n                // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n                // set that won't get normalized away\n                return;\n            }\n            var rangeRef = Editor.rangeRef(editor, at, {\n                affinity: \"inward\"\n            });\n            var [start, end] = Range.edges(at);\n            var splitMode = mode === \"lowest\" ? \"lowest\" : \"highest\";\n            var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n            Transforms.splitNodes(editor, {\n                at: end,\n                match,\n                mode: splitMode,\n                voids,\n                always: !endAtEndOfNode\n            });\n            var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n            Transforms.splitNodes(editor, {\n                at: start,\n                match,\n                mode: splitMode,\n                voids,\n                always: !startAtStartOfNode\n            });\n            at = rangeRef.unref();\n            if (options.at == null) {\n                Transforms.select(editor, at);\n            }\n        }\n        if (!compare) {\n            compare = (prop, nodeProp)=>prop !== nodeProp;\n        }\n        for (var [node, path] of Editor.nodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n        })){\n            var properties = {};\n            // FIXME: is this correct?\n            var newProperties = {};\n            // You can't set properties on the editor node.\n            if (path.length === 0) {\n                continue;\n            }\n            var hasChanges = false;\n            for(var k in props){\n                if (k === \"children\" || k === \"text\") {\n                    continue;\n                }\n                if (compare(props[k], node[k])) {\n                    hasChanges = true;\n                    // Omit new properties from the old properties list\n                    if (node.hasOwnProperty(k)) properties[k] = node[k];\n                    // Omit properties that have been removed from the new properties list\n                    if (merge) {\n                        if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n                    } else {\n                        if (props[k] != null) newProperties[k] = props[k];\n                    }\n                }\n            }\n            if (hasChanges) {\n                editor.apply({\n                    type: \"set_node\",\n                    path,\n                    properties,\n                    newProperties\n                });\n            }\n        }\n    });\n};\n/**\n * Convert a range into a point by deleting it's content.\n */ var deleteRange = (editor, range)=>{\n    if (Range.isCollapsed(range)) {\n        return range.anchor;\n    } else {\n        var [, end] = Range.edges(range);\n        var pointRef = Editor.pointRef(editor, end);\n        Transforms.delete(editor, {\n            at: range\n        });\n        return pointRef.unref();\n    }\n};\nvar splitNodes = function splitNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { mode = \"lowest\", voids = false } = options;\n        var { match, at = editor.selection, height = 0, always = false } = options;\n        if (match == null) {\n            match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        if (Range.isRange(at)) {\n            at = deleteRange(editor, at);\n        }\n        // If the target is a path, the default height-skipping and position\n        // counters need to account for us potentially splitting at a non-leaf.\n        if (Path.isPath(at)) {\n            var path = at;\n            var point = Editor.point(editor, path);\n            var [parent] = Editor.parent(editor, path);\n            match = (n)=>n === parent;\n            height = point.path.length - path.length + 1;\n            at = point;\n            always = true;\n        }\n        if (!at) {\n            return;\n        }\n        var beforeRef = Editor.pointRef(editor, at, {\n            affinity: \"backward\"\n        });\n        var afterRef;\n        try {\n            var [highest] = Editor.nodes(editor, {\n                at,\n                match,\n                mode,\n                voids\n            });\n            if (!highest) {\n                return;\n            }\n            var voidMatch = Editor.void(editor, {\n                at,\n                mode: \"highest\"\n            });\n            var nudge = 0;\n            if (!voids && voidMatch) {\n                var [voidNode, voidPath] = voidMatch;\n                if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n                    var after = Editor.after(editor, voidPath);\n                    if (!after) {\n                        var text = {\n                            text: \"\"\n                        };\n                        var afterPath = Path.next(voidPath);\n                        Transforms.insertNodes(editor, text, {\n                            at: afterPath,\n                            voids\n                        });\n                        after = Editor.point(editor, afterPath);\n                    }\n                    at = after;\n                    always = true;\n                }\n                var siblingHeight = at.path.length - voidPath.length;\n                height = siblingHeight + 1;\n                always = true;\n            }\n            afterRef = Editor.pointRef(editor, at);\n            var depth = at.path.length - height;\n            var [, highestPath] = highest;\n            var lowestPath = at.path.slice(0, depth);\n            var position = height === 0 ? at.offset : at.path[depth] + nudge;\n            for (var [node, _path] of Editor.levels(editor, {\n                at: lowestPath,\n                reverse: true,\n                voids\n            })){\n                var split = false;\n                if (_path.length < highestPath.length || _path.length === 0 || !voids && Element.isElement(node) && Editor.isVoid(editor, node)) {\n                    break;\n                }\n                var _point = beforeRef.current;\n                var isEnd = Editor.isEnd(editor, _point, _path);\n                if (always || !beforeRef || !Editor.isEdge(editor, _point, _path)) {\n                    split = true;\n                    var properties = Node.extractProps(node);\n                    editor.apply({\n                        type: \"split_node\",\n                        path: _path,\n                        position,\n                        properties\n                    });\n                }\n                position = _path[_path.length - 1] + (split || isEnd ? 1 : 0);\n            }\n            if (options.at == null) {\n                var _point2 = afterRef.current || Editor.end(editor, []);\n                Transforms.select(editor, _point2);\n            }\n        } finally{\n            var _afterRef;\n            beforeRef.unref();\n            (_afterRef = afterRef) === null || _afterRef === void 0 || _afterRef.unref();\n        }\n    });\n};\nvar unsetNodes = function unsetNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!Array.isArray(props)) {\n        props = [\n            props\n        ];\n    }\n    var obj = {};\n    for (var key of props){\n        obj[key] = null;\n    }\n    Transforms.setNodes(editor, obj, options);\n};\nvar unwrapNodes = function unwrapNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { mode = \"lowest\", split = false, voids = false } = options;\n        var { at = editor.selection, match } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            match = Path.isPath(at) ? matchPath(editor, at) : (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n        if (Path.isPath(at)) {\n            at = Editor.range(editor, at);\n        }\n        var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n        var matches = Editor.nodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n        });\n        var pathRefs = Array.from(matches, (_ref)=>{\n            var [, p] = _ref;\n            return Editor.pathRef(editor, p);\n        }).reverse();\n        var _loop = function _loop() {\n            var path = pathRef.unref();\n            var [node] = Editor.node(editor, path);\n            var range = Editor.range(editor, path);\n            if (split && rangeRef) {\n                range = Range.intersection(rangeRef.current, range);\n            }\n            Transforms.liftNodes(editor, {\n                at: range,\n                match: (n)=>Element.isAncestor(node) && node.children.includes(n),\n                voids\n            });\n        };\n        for (var pathRef of pathRefs){\n            _loop();\n        }\n        if (rangeRef) {\n            rangeRef.unref();\n        }\n    });\n};\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r) {\n            return Object.getOwnPropertyDescriptor(e, r).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {\n            _defineProperty(e, r, t[r]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {\n            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n        });\n    }\n    return e;\n}\nvar wrapNodes = function wrapNodes(editor, element) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, ()=>{\n        var { mode = \"lowest\", split = false, voids = false } = options;\n        var { match, at = editor.selection } = options;\n        if (!at) {\n            return;\n        }\n        if (match == null) {\n            if (Path.isPath(at)) {\n                match = matchPath(editor, at);\n            } else if (editor.isInline(element)) {\n                match = (n)=>Element.isElement(n) && Editor.isInline(editor, n) || Text.isText(n);\n            } else {\n                match = (n)=>Element.isElement(n) && Editor.isBlock(editor, n);\n            }\n        }\n        if (split && Range.isRange(at)) {\n            var [start, end] = Range.edges(at);\n            var rangeRef = Editor.rangeRef(editor, at, {\n                affinity: \"inward\"\n            });\n            Transforms.splitNodes(editor, {\n                at: end,\n                match,\n                voids\n            });\n            Transforms.splitNodes(editor, {\n                at: start,\n                match,\n                voids\n            });\n            at = rangeRef.unref();\n            if (options.at == null) {\n                Transforms.select(editor, at);\n            }\n        }\n        var roots = Array.from(Editor.nodes(editor, {\n            at,\n            match: editor.isInline(element) ? (n)=>Element.isElement(n) && Editor.isBlock(editor, n) : (n)=>Editor.isEditor(n),\n            mode: \"lowest\",\n            voids\n        }));\n        var _loop = function _loop() {\n            var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n            if (!a) {\n                return 0; // continue\n            }\n            var matches = Array.from(Editor.nodes(editor, {\n                at: a,\n                match,\n                mode,\n                voids\n            }));\n            if (matches.length > 0) {\n                var [first] = matches;\n                var last = matches[matches.length - 1];\n                var [, firstPath] = first;\n                var [, lastPath] = last;\n                if (firstPath.length === 0 && lastPath.length === 0) {\n                    // if there's no matching parent - usually means the node is an editor - don't do anything\n                    return 0; // continue\n                }\n                var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n                var range = Editor.range(editor, firstPath, lastPath);\n                var commonNodeEntry = Editor.node(editor, commonPath);\n                var [commonNode] = commonNodeEntry;\n                var depth = commonPath.length + 1;\n                var wrapperPath = Path.next(lastPath.slice(0, depth));\n                var wrapper = _objectSpread(_objectSpread({}, element), {}, {\n                    children: []\n                });\n                Transforms.insertNodes(editor, wrapper, {\n                    at: wrapperPath,\n                    voids\n                });\n                Transforms.moveNodes(editor, {\n                    at: range,\n                    match: (n)=>Element.isAncestor(commonNode) && commonNode.children.includes(n),\n                    to: wrapperPath.concat(0),\n                    voids\n                });\n            }\n        }, _ret;\n        for (var [, rootPath] of roots){\n            _ret = _loop();\n            if (_ret === 0) continue;\n        }\n    });\n};\n/**\n * Create a new Slate `Editor` object.\n */ var createEditor = ()=>{\n    var editor = {\n        children: [],\n        operations: [],\n        selection: null,\n        marks: null,\n        isElementReadOnly: ()=>false,\n        isInline: ()=>false,\n        isSelectable: ()=>true,\n        isVoid: ()=>false,\n        markableVoid: ()=>false,\n        onChange: ()=>{},\n        // Core\n        apply: function apply$1() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            return apply(editor, ...args);\n        },\n        // Editor\n        addMark: function addMark$1() {\n            for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n                args[_key2] = arguments[_key2];\n            }\n            return addMark(editor, ...args);\n        },\n        deleteBackward: function deleteBackward$1() {\n            for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n                args[_key3] = arguments[_key3];\n            }\n            return deleteBackward(editor, ...args);\n        },\n        deleteForward: function deleteForward$1() {\n            for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){\n                args[_key4] = arguments[_key4];\n            }\n            return deleteForward(editor, ...args);\n        },\n        deleteFragment: function deleteFragment$1() {\n            for(var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++){\n                args[_key5] = arguments[_key5];\n            }\n            return deleteFragment(editor, ...args);\n        },\n        getFragment: function getFragment$1() {\n            for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){\n                args[_key6] = arguments[_key6];\n            }\n            return getFragment(editor, ...args);\n        },\n        insertBreak: function insertBreak$1() {\n            for(var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++){\n                args[_key7] = arguments[_key7];\n            }\n            return insertBreak(editor, ...args);\n        },\n        insertSoftBreak: function insertSoftBreak$1() {\n            for(var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++){\n                args[_key8] = arguments[_key8];\n            }\n            return insertSoftBreak(editor, ...args);\n        },\n        insertFragment: function insertFragment$1() {\n            for(var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++){\n                args[_key9] = arguments[_key9];\n            }\n            return insertFragment(editor, ...args);\n        },\n        insertNode: function insertNode$1() {\n            for(var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++){\n                args[_key10] = arguments[_key10];\n            }\n            return insertNode(editor, ...args);\n        },\n        insertText: function insertText$1() {\n            for(var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++){\n                args[_key11] = arguments[_key11];\n            }\n            return insertText(editor, ...args);\n        },\n        normalizeNode: function normalizeNode$1() {\n            for(var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++){\n                args[_key12] = arguments[_key12];\n            }\n            return normalizeNode(editor, ...args);\n        },\n        removeMark: function removeMark$1() {\n            for(var _len13 = arguments.length, args = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++){\n                args[_key13] = arguments[_key13];\n            }\n            return removeMark(editor, ...args);\n        },\n        getDirtyPaths: function getDirtyPaths$1() {\n            for(var _len14 = arguments.length, args = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++){\n                args[_key14] = arguments[_key14];\n            }\n            return getDirtyPaths(editor, ...args);\n        },\n        shouldNormalize: function shouldNormalize$1() {\n            for(var _len15 = arguments.length, args = new Array(_len15), _key15 = 0; _key15 < _len15; _key15++){\n                args[_key15] = arguments[_key15];\n            }\n            return shouldNormalize(editor, ...args);\n        },\n        // Editor interface\n        above: function above$1() {\n            for(var _len16 = arguments.length, args = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++){\n                args[_key16] = arguments[_key16];\n            }\n            return above(editor, ...args);\n        },\n        after: function after$1() {\n            for(var _len17 = arguments.length, args = new Array(_len17), _key17 = 0; _key17 < _len17; _key17++){\n                args[_key17] = arguments[_key17];\n            }\n            return after(editor, ...args);\n        },\n        before: function before$1() {\n            for(var _len18 = arguments.length, args = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++){\n                args[_key18] = arguments[_key18];\n            }\n            return before(editor, ...args);\n        },\n        collapse: function collapse$1() {\n            for(var _len19 = arguments.length, args = new Array(_len19), _key19 = 0; _key19 < _len19; _key19++){\n                args[_key19] = arguments[_key19];\n            }\n            return collapse(editor, ...args);\n        },\n        delete: function _delete() {\n            for(var _len20 = arguments.length, args = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++){\n                args[_key20] = arguments[_key20];\n            }\n            return deleteText(editor, ...args);\n        },\n        deselect: function deselect$1() {\n            for(var _len21 = arguments.length, args = new Array(_len21), _key21 = 0; _key21 < _len21; _key21++){\n                args[_key21] = arguments[_key21];\n            }\n            return deselect(editor, ...args);\n        },\n        edges: function edges$1() {\n            for(var _len22 = arguments.length, args = new Array(_len22), _key22 = 0; _key22 < _len22; _key22++){\n                args[_key22] = arguments[_key22];\n            }\n            return edges(editor, ...args);\n        },\n        elementReadOnly: function elementReadOnly$1() {\n            for(var _len23 = arguments.length, args = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++){\n                args[_key23] = arguments[_key23];\n            }\n            return elementReadOnly(editor, ...args);\n        },\n        end: function end$1() {\n            for(var _len24 = arguments.length, args = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++){\n                args[_key24] = arguments[_key24];\n            }\n            return end(editor, ...args);\n        },\n        first: function first$1() {\n            for(var _len25 = arguments.length, args = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++){\n                args[_key25] = arguments[_key25];\n            }\n            return first(editor, ...args);\n        },\n        fragment: function fragment$1() {\n            for(var _len26 = arguments.length, args = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++){\n                args[_key26] = arguments[_key26];\n            }\n            return fragment(editor, ...args);\n        },\n        getMarks: function getMarks() {\n            for(var _len27 = arguments.length, args = new Array(_len27), _key27 = 0; _key27 < _len27; _key27++){\n                args[_key27] = arguments[_key27];\n            }\n            return marks(editor, ...args);\n        },\n        hasBlocks: function hasBlocks$1() {\n            for(var _len28 = arguments.length, args = new Array(_len28), _key28 = 0; _key28 < _len28; _key28++){\n                args[_key28] = arguments[_key28];\n            }\n            return hasBlocks(editor, ...args);\n        },\n        hasInlines: function hasInlines$1() {\n            for(var _len29 = arguments.length, args = new Array(_len29), _key29 = 0; _key29 < _len29; _key29++){\n                args[_key29] = arguments[_key29];\n            }\n            return hasInlines(editor, ...args);\n        },\n        hasPath: function hasPath$1() {\n            for(var _len30 = arguments.length, args = new Array(_len30), _key30 = 0; _key30 < _len30; _key30++){\n                args[_key30] = arguments[_key30];\n            }\n            return hasPath(editor, ...args);\n        },\n        hasTexts: function hasTexts$1() {\n            for(var _len31 = arguments.length, args = new Array(_len31), _key31 = 0; _key31 < _len31; _key31++){\n                args[_key31] = arguments[_key31];\n            }\n            return hasTexts(editor, ...args);\n        },\n        insertNodes: function insertNodes$1() {\n            for(var _len32 = arguments.length, args = new Array(_len32), _key32 = 0; _key32 < _len32; _key32++){\n                args[_key32] = arguments[_key32];\n            }\n            return insertNodes(editor, ...args);\n        },\n        isBlock: function isBlock$1() {\n            for(var _len33 = arguments.length, args = new Array(_len33), _key33 = 0; _key33 < _len33; _key33++){\n                args[_key33] = arguments[_key33];\n            }\n            return isBlock(editor, ...args);\n        },\n        isEdge: function isEdge$1() {\n            for(var _len34 = arguments.length, args = new Array(_len34), _key34 = 0; _key34 < _len34; _key34++){\n                args[_key34] = arguments[_key34];\n            }\n            return isEdge(editor, ...args);\n        },\n        isEmpty: function isEmpty$1() {\n            for(var _len35 = arguments.length, args = new Array(_len35), _key35 = 0; _key35 < _len35; _key35++){\n                args[_key35] = arguments[_key35];\n            }\n            return isEmpty(editor, ...args);\n        },\n        isEnd: function isEnd$1() {\n            for(var _len36 = arguments.length, args = new Array(_len36), _key36 = 0; _key36 < _len36; _key36++){\n                args[_key36] = arguments[_key36];\n            }\n            return isEnd(editor, ...args);\n        },\n        isNormalizing: function isNormalizing$1() {\n            for(var _len37 = arguments.length, args = new Array(_len37), _key37 = 0; _key37 < _len37; _key37++){\n                args[_key37] = arguments[_key37];\n            }\n            return isNormalizing(editor, ...args);\n        },\n        isStart: function isStart$1() {\n            for(var _len38 = arguments.length, args = new Array(_len38), _key38 = 0; _key38 < _len38; _key38++){\n                args[_key38] = arguments[_key38];\n            }\n            return isStart(editor, ...args);\n        },\n        last: function last$1() {\n            for(var _len39 = arguments.length, args = new Array(_len39), _key39 = 0; _key39 < _len39; _key39++){\n                args[_key39] = arguments[_key39];\n            }\n            return last(editor, ...args);\n        },\n        leaf: function leaf$1() {\n            for(var _len40 = arguments.length, args = new Array(_len40), _key40 = 0; _key40 < _len40; _key40++){\n                args[_key40] = arguments[_key40];\n            }\n            return leaf(editor, ...args);\n        },\n        levels: function levels$1() {\n            for(var _len41 = arguments.length, args = new Array(_len41), _key41 = 0; _key41 < _len41; _key41++){\n                args[_key41] = arguments[_key41];\n            }\n            return levels(editor, ...args);\n        },\n        liftNodes: function liftNodes$1() {\n            for(var _len42 = arguments.length, args = new Array(_len42), _key42 = 0; _key42 < _len42; _key42++){\n                args[_key42] = arguments[_key42];\n            }\n            return liftNodes(editor, ...args);\n        },\n        mergeNodes: function mergeNodes$1() {\n            for(var _len43 = arguments.length, args = new Array(_len43), _key43 = 0; _key43 < _len43; _key43++){\n                args[_key43] = arguments[_key43];\n            }\n            return mergeNodes(editor, ...args);\n        },\n        move: function move$1() {\n            for(var _len44 = arguments.length, args = new Array(_len44), _key44 = 0; _key44 < _len44; _key44++){\n                args[_key44] = arguments[_key44];\n            }\n            return move(editor, ...args);\n        },\n        moveNodes: function moveNodes$1() {\n            for(var _len45 = arguments.length, args = new Array(_len45), _key45 = 0; _key45 < _len45; _key45++){\n                args[_key45] = arguments[_key45];\n            }\n            return moveNodes(editor, ...args);\n        },\n        next: function next$1() {\n            for(var _len46 = arguments.length, args = new Array(_len46), _key46 = 0; _key46 < _len46; _key46++){\n                args[_key46] = arguments[_key46];\n            }\n            return next(editor, ...args);\n        },\n        node: function node$1() {\n            for(var _len47 = arguments.length, args = new Array(_len47), _key47 = 0; _key47 < _len47; _key47++){\n                args[_key47] = arguments[_key47];\n            }\n            return node(editor, ...args);\n        },\n        nodes: function nodes$1() {\n            for(var _len48 = arguments.length, args = new Array(_len48), _key48 = 0; _key48 < _len48; _key48++){\n                args[_key48] = arguments[_key48];\n            }\n            return nodes(editor, ...args);\n        },\n        normalize: function normalize$1() {\n            for(var _len49 = arguments.length, args = new Array(_len49), _key49 = 0; _key49 < _len49; _key49++){\n                args[_key49] = arguments[_key49];\n            }\n            return normalize(editor, ...args);\n        },\n        parent: function parent$1() {\n            for(var _len50 = arguments.length, args = new Array(_len50), _key50 = 0; _key50 < _len50; _key50++){\n                args[_key50] = arguments[_key50];\n            }\n            return parent(editor, ...args);\n        },\n        path: function path$1() {\n            for(var _len51 = arguments.length, args = new Array(_len51), _key51 = 0; _key51 < _len51; _key51++){\n                args[_key51] = arguments[_key51];\n            }\n            return path(editor, ...args);\n        },\n        pathRef: function pathRef$1() {\n            for(var _len52 = arguments.length, args = new Array(_len52), _key52 = 0; _key52 < _len52; _key52++){\n                args[_key52] = arguments[_key52];\n            }\n            return pathRef(editor, ...args);\n        },\n        pathRefs: function pathRefs$1() {\n            for(var _len53 = arguments.length, args = new Array(_len53), _key53 = 0; _key53 < _len53; _key53++){\n                args[_key53] = arguments[_key53];\n            }\n            return pathRefs(editor, ...args);\n        },\n        point: function point$1() {\n            for(var _len54 = arguments.length, args = new Array(_len54), _key54 = 0; _key54 < _len54; _key54++){\n                args[_key54] = arguments[_key54];\n            }\n            return point(editor, ...args);\n        },\n        pointRef: function pointRef$1() {\n            for(var _len55 = arguments.length, args = new Array(_len55), _key55 = 0; _key55 < _len55; _key55++){\n                args[_key55] = arguments[_key55];\n            }\n            return pointRef(editor, ...args);\n        },\n        pointRefs: function pointRefs$1() {\n            for(var _len56 = arguments.length, args = new Array(_len56), _key56 = 0; _key56 < _len56; _key56++){\n                args[_key56] = arguments[_key56];\n            }\n            return pointRefs(editor, ...args);\n        },\n        positions: function positions$1() {\n            for(var _len57 = arguments.length, args = new Array(_len57), _key57 = 0; _key57 < _len57; _key57++){\n                args[_key57] = arguments[_key57];\n            }\n            return positions(editor, ...args);\n        },\n        previous: function previous$1() {\n            for(var _len58 = arguments.length, args = new Array(_len58), _key58 = 0; _key58 < _len58; _key58++){\n                args[_key58] = arguments[_key58];\n            }\n            return previous(editor, ...args);\n        },\n        range: function range$1() {\n            for(var _len59 = arguments.length, args = new Array(_len59), _key59 = 0; _key59 < _len59; _key59++){\n                args[_key59] = arguments[_key59];\n            }\n            return range(editor, ...args);\n        },\n        rangeRef: function rangeRef$1() {\n            for(var _len60 = arguments.length, args = new Array(_len60), _key60 = 0; _key60 < _len60; _key60++){\n                args[_key60] = arguments[_key60];\n            }\n            return rangeRef(editor, ...args);\n        },\n        rangeRefs: function rangeRefs$1() {\n            for(var _len61 = arguments.length, args = new Array(_len61), _key61 = 0; _key61 < _len61; _key61++){\n                args[_key61] = arguments[_key61];\n            }\n            return rangeRefs(editor, ...args);\n        },\n        removeNodes: function removeNodes$1() {\n            for(var _len62 = arguments.length, args = new Array(_len62), _key62 = 0; _key62 < _len62; _key62++){\n                args[_key62] = arguments[_key62];\n            }\n            return removeNodes(editor, ...args);\n        },\n        select: function select$1() {\n            for(var _len63 = arguments.length, args = new Array(_len63), _key63 = 0; _key63 < _len63; _key63++){\n                args[_key63] = arguments[_key63];\n            }\n            return select(editor, ...args);\n        },\n        setNodes: function setNodes$1() {\n            for(var _len64 = arguments.length, args = new Array(_len64), _key64 = 0; _key64 < _len64; _key64++){\n                args[_key64] = arguments[_key64];\n            }\n            return setNodes(editor, ...args);\n        },\n        setNormalizing: function setNormalizing$1() {\n            for(var _len65 = arguments.length, args = new Array(_len65), _key65 = 0; _key65 < _len65; _key65++){\n                args[_key65] = arguments[_key65];\n            }\n            return setNormalizing(editor, ...args);\n        },\n        setPoint: function setPoint$1() {\n            for(var _len66 = arguments.length, args = new Array(_len66), _key66 = 0; _key66 < _len66; _key66++){\n                args[_key66] = arguments[_key66];\n            }\n            return setPoint(editor, ...args);\n        },\n        setSelection: function setSelection$1() {\n            for(var _len67 = arguments.length, args = new Array(_len67), _key67 = 0; _key67 < _len67; _key67++){\n                args[_key67] = arguments[_key67];\n            }\n            return setSelection(editor, ...args);\n        },\n        splitNodes: function splitNodes$1() {\n            for(var _len68 = arguments.length, args = new Array(_len68), _key68 = 0; _key68 < _len68; _key68++){\n                args[_key68] = arguments[_key68];\n            }\n            return splitNodes(editor, ...args);\n        },\n        start: function start$1() {\n            for(var _len69 = arguments.length, args = new Array(_len69), _key69 = 0; _key69 < _len69; _key69++){\n                args[_key69] = arguments[_key69];\n            }\n            return start(editor, ...args);\n        },\n        string: function string$1() {\n            for(var _len70 = arguments.length, args = new Array(_len70), _key70 = 0; _key70 < _len70; _key70++){\n                args[_key70] = arguments[_key70];\n            }\n            return string(editor, ...args);\n        },\n        unhangRange: function unhangRange$1() {\n            for(var _len71 = arguments.length, args = new Array(_len71), _key71 = 0; _key71 < _len71; _key71++){\n                args[_key71] = arguments[_key71];\n            }\n            return unhangRange(editor, ...args);\n        },\n        unsetNodes: function unsetNodes$1() {\n            for(var _len72 = arguments.length, args = new Array(_len72), _key72 = 0; _key72 < _len72; _key72++){\n                args[_key72] = arguments[_key72];\n            }\n            return unsetNodes(editor, ...args);\n        },\n        unwrapNodes: function unwrapNodes$1() {\n            for(var _len73 = arguments.length, args = new Array(_len73), _key73 = 0; _key73 < _len73; _key73++){\n                args[_key73] = arguments[_key73];\n            }\n            return unwrapNodes(editor, ...args);\n        },\n        void: function _void() {\n            for(var _len74 = arguments.length, args = new Array(_len74), _key74 = 0; _key74 < _len74; _key74++){\n                args[_key74] = arguments[_key74];\n            }\n            return getVoid(editor, ...args);\n        },\n        withoutNormalizing: function withoutNormalizing$1() {\n            for(var _len75 = arguments.length, args = new Array(_len75), _key75 = 0; _key75 < _len75; _key75++){\n                args[_key75] = arguments[_key75];\n            }\n            return withoutNormalizing(editor, ...args);\n        },\n        wrapNodes: function wrapNodes$1() {\n            for(var _len76 = arguments.length, args = new Array(_len76), _key76 = 0; _key76 < _len76; _key76++){\n                args[_key76] = arguments[_key76];\n            }\n            return wrapNodes(editor, ...args);\n        }\n    };\n    return editor;\n};\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2xhdGUvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnRDtBQUNtQjtBQUVuRSx3Q0FBd0M7QUFDeEMsSUFBSUssVUFBVTtJQUNaQyxXQUFVQyxHQUFHLEVBQUVDLEVBQUU7UUFDZixJQUFJLEVBQ0ZDLE9BQU8sRUFDUEMsUUFBUSxFQUNULEdBQUdIO1FBQ0osSUFBSUUsV0FBVyxNQUFNO1lBQ25CO1FBQ0Y7UUFDQSxJQUFJRSxPQUFPQyxLQUFLTixTQUFTLENBQUNHLFNBQVNELElBQUk7WUFDckNFO1FBQ0Y7UUFDQUgsSUFBSUUsT0FBTyxHQUFHRTtRQUNkLElBQUlBLFFBQVEsTUFBTTtZQUNoQkosSUFBSU0sS0FBSztRQUNYO0lBQ0Y7QUFDRjtBQUVBLHdDQUF3QztBQUN4QyxJQUFJQyxXQUFXO0lBQ2JSLFdBQVVDLEdBQUcsRUFBRUMsRUFBRTtRQUNmLElBQUksRUFDRkMsT0FBTyxFQUNQQyxRQUFRLEVBQ1QsR0FBR0g7UUFDSixJQUFJRSxXQUFXLE1BQU07WUFDbkI7UUFDRjtRQUNBLElBQUlNLFFBQVFDLE1BQU1WLFNBQVMsQ0FBQ0csU0FBU0QsSUFBSTtZQUN2Q0U7UUFDRjtRQUNBSCxJQUFJRSxPQUFPLEdBQUdNO1FBQ2QsSUFBSUEsU0FBUyxNQUFNO1lBQ2pCUixJQUFJTSxLQUFLO1FBQ1g7SUFDRjtBQUNGO0FBRUEsd0NBQXdDO0FBQ3hDLElBQUlJLFdBQVc7SUFDYlgsV0FBVUMsR0FBRyxFQUFFQyxFQUFFO1FBQ2YsSUFBSSxFQUNGQyxPQUFPLEVBQ1BDLFFBQVEsRUFDVCxHQUFHSDtRQUNKLElBQUlFLFdBQVcsTUFBTTtZQUNuQjtRQUNGO1FBQ0EsSUFBSUUsT0FBT08sTUFBTVosU0FBUyxDQUFDRyxTQUFTRCxJQUFJO1lB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QyxTQUFTLEdBQUdBLFNBQVNELFFBQVFDLFNBQVU7Z0JBQ25Hck4sSUFBSSxDQUFDcU4sT0FBTyxHQUFHOTFCLFNBQVMsQ0FBQzgxQixPQUFPO1lBQ2xDO1lBQ0EsT0FBT2pnQixtQkFBbUJ4UCxXQUFXb2lCO1FBQ3ZDO1FBQ0F4YyxXQUFXLFNBQVM4cEI7WUFDbEIsSUFBSyxJQUFJQyxTQUFTaDJCLFVBQVVDLE1BQU0sRUFBRXdvQixPQUFPLElBQUl2bUIsTUFBTTh6QixTQUFTQyxTQUFTLEdBQUdBLFNBQVNELFFBQVFDLFNBQVU7Z0JBQ25HeE4sSUFBSSxDQUFDd04sT0FBTyxHQUFHajJCLFNBQVMsQ0FBQ2kyQixPQUFPO1lBQ2xDO1lBQ0EsT0FBT2hxQixVQUFVNUYsV0FBV29pQjtRQUM5QjtJQUNGO0lBQ0EsT0FBT3BpQjtBQUNUO0FBRWk4QixDQUNqOEIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFyeS5pbmZvLy4vbm9kZV9tb2R1bGVzL3NsYXRlL2Rpc3QvaW5kZXguZXMuanM/N2Y0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnaXMtcGxhaW4tb2JqZWN0JztcbmltcG9ydCB7IGNyZWF0ZURyYWZ0LCBmaW5pc2hEcmFmdCwgaXNEcmFmdCwgcHJvZHVjZSB9IGZyb20gJ2ltbWVyJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFBhdGhSZWYgPSB7XG4gIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBhZmZpbml0eVxuICAgIH0gPSByZWY7XG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGF0aCA9IFBhdGgudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcGF0aDtcbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBQb2ludFJlZiA9IHtcbiAgdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGFmZmluaXR5XG4gICAgfSA9IHJlZjtcbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwb2ludCA9IFBvaW50LnRyYW5zZm9ybShjdXJyZW50LCBvcCwge1xuICAgICAgYWZmaW5pdHlcbiAgICB9KTtcbiAgICByZWYuY3VycmVudCA9IHBvaW50O1xuICAgIGlmIChwb2ludCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBSYW5nZVJlZiA9IHtcbiAgdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGFmZmluaXR5XG4gICAgfSA9IHJlZjtcbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYXRoID0gUmFuZ2UudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcGF0aDtcbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBESVJUWV9QQVRIUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRElSVFlfUEFUSF9LRVlTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBGTFVTSElORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9STUFMSVpJTkcgPSBuZXcgV2Vha01hcCgpO1xudmFyIFBBVEhfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUE9JTlRfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUkFOR0VfUkVGUyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBQYXRoID0ge1xuICBhbmNlc3RvcnMocGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgcmV2ZXJzZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHBhdGhzID0gUGF0aC5sZXZlbHMocGF0aCwgb3B0aW9ucyk7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aHM7XG4gIH0sXG4gIGNvbW1vbihwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGNvbW1vbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggJiYgaSA8IGFub3RoZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBhdiA9IHBhdGhbaV07XG4gICAgICB2YXIgYnYgPSBhbm90aGVyW2ldO1xuICAgICAgaWYgKGF2ICE9PSBidikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbW1vbi5wdXNoKGF2KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1vbjtcbiAgfSxcbiAgY29tcGFyZShwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKHBhdGgubGVuZ3RoLCBhbm90aGVyLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0gPCBhbm90aGVyW2ldKSByZXR1cm4gLTE7XG4gICAgICBpZiAocGF0aFtpXSA+IGFub3RoZXJbaV0pIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgZW5kc0FmdGVyKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGF2ID0gcGF0aFtpXTtcbiAgICB2YXIgYnYgPSBhbm90aGVyW2ldO1xuICAgIHJldHVybiBQYXRoLmVxdWFscyhhcywgYnMpICYmIGF2ID4gYnY7XG4gIH0sXG4gIGVuZHNBdChwYXRoLCBhbm90aGVyKSB7XG4gICAgdmFyIGkgPSBwYXRoLmxlbmd0aDtcbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIGkpO1xuICAgIHZhciBicyA9IGFub3RoZXIuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicyk7XG4gIH0sXG4gIGVuZHNCZWZvcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPCBidjtcbiAgfSxcbiAgZXF1YWxzKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPT09IGFub3RoZXIubGVuZ3RoICYmIHBhdGguZXZlcnkoKG4sIGkpID0+IG4gPT09IGFub3RoZXJbaV0pO1xuICB9LFxuICBoYXNQcmV2aW91cyhwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA+IDA7XG4gIH0sXG4gIGlzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDE7XG4gIH0sXG4gIGlzQW5jZXN0b3IocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcbiAgaXNCZWZvcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IC0xO1xuICB9LFxuICBpc0NoaWxkKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPT09IGFub3RoZXIubGVuZ3RoICsgMSAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG4gIGlzQ29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPD0gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuICBpc0Rlc2NlbmRhbnQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcbiAgaXNQYXJlbnQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCArIDEgPT09IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcbiAgaXNQYXRoKHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmICh2YWx1ZS5sZW5ndGggPT09IDAgfHwgdHlwZW9mIHZhbHVlWzBdID09PSAnbnVtYmVyJyk7XG4gIH0sXG4gIGlzU2libGluZyhwYXRoLCBhbm90aGVyKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgYXMgPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICB2YXIgYnMgPSBhbm90aGVyLnNsaWNlKDAsIC0xKTtcbiAgICB2YXIgYWwgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgdmFyIGJsID0gYW5vdGhlclthbm90aGVyLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBhbCAhPT0gYmwgJiYgUGF0aC5lcXVhbHMoYXMsIGJzKTtcbiAgfSxcbiAgbGV2ZWxzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBsaXN0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdC5wdXNoKHBhdGguc2xpY2UoMCwgaSkpO1xuICAgIH1cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgbGlzdC5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9LFxuICBuZXh0KHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIG5leHQgcGF0aCBvZiBhIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSwgYmVjYXVzZSBpdCBoYXMgbm8gbmV4dCBpbmRleC5cIikpO1xuICAgIH1cbiAgICB2YXIgbGFzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSkuY29uY2F0KGxhc3QgKyAxKTtcbiAgfSxcbiAgb3BlcmF0aW9uQ2FuVHJhbnNmb3JtUGF0aChvcGVyYXRpb24pIHtcbiAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuICBwYXJlbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IHBhdGggb2YgdGhlIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXS5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSk7XG4gIH0sXG4gIHByZXZpb3VzKHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIHBhdGggb2YgYSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0sIGJlY2F1c2UgaXQgaGFzIG5vIHByZXZpb3VzIGluZGV4LlwiKSk7XG4gICAgfVxuICAgIHZhciBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsYXN0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIHBhdGggb2YgYSBmaXJzdCBjaGlsZCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgd291bGQgcmVzdWx0IGluIGEgbmVnYXRpdmUgaW5kZXguXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpLmNvbmNhdChsYXN0IC0gMSk7XG4gIH0sXG4gIHJlbGF0aXZlKHBhdGgsIGFuY2VzdG9yKSB7XG4gICAgaWYgKCFQYXRoLmlzQW5jZXN0b3IoYW5jZXN0b3IsIHBhdGgpICYmICFQYXRoLmVxdWFscyhwYXRoLCBhbmNlc3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHJlbGF0aXZlIHBhdGggb2YgW1wiLmNvbmNhdChwYXRoLCBcIl0gaW5zaWRlIGFuY2VzdG9yIFtcIikuY29uY2F0KGFuY2VzdG9yLCBcIl0sIGJlY2F1c2UgaXQgaXMgbm90IGFib3ZlIG9yIGVxdWFsIHRvIHRoZSBwYXRoLlwiKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnNsaWNlKGFuY2VzdG9yLmxlbmd0aCk7XG4gIH0sXG4gIHRyYW5zZm9ybShwYXRoLCBvcGVyYXRpb24pIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgaWYgKCFwYXRoKSByZXR1cm4gbnVsbDtcbiAgICAvLyBQRVJGOiB1c2UgZGVzdHJ1Y3RpbmcgaW5zdGVhZCBvZiBpbW1lclxuICAgIHZhciBwID0gWy4uLnBhdGhdO1xuICAgIHZhciB7XG4gICAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIC8vIFBFUkY6IEV4aXQgZWFybHkgaWYgdGhlIG9wZXJhdGlvbiBpcyBndWFyYW50ZWVkIG5vdCB0byBoYXZlIGFuIGVmZmVjdC5cbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogb3BcbiAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcCwgcCkgfHwgUGF0aC5lbmRzQmVmb3JlKG9wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3Iob3AsIHApKSB7XG4gICAgICAgICAgICBwW29wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX29wXG4gICAgICAgICAgfSA9IG9wZXJhdGlvbjtcbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3IoX29wLCBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9vcDIsXG4gICAgICAgICAgICBwb3NpdGlvblxuICAgICAgICAgIH0gPSBvcGVyYXRpb247XG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDIsIHApIHx8IFBhdGguZW5kc0JlZm9yZShfb3AyLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMiwgcCkpIHtcbiAgICAgICAgICAgIHBbX29wMi5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aF0gKz0gcG9zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfb3AzLFxuICAgICAgICAgICAgcG9zaXRpb246IF9wb3NpdGlvblxuICAgICAgICAgIH0gPSBvcGVyYXRpb247XG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDMsIHApKSB7XG4gICAgICAgICAgICBpZiAoYWZmaW5pdHkgPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgICBwW3AubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdiYWNrd2FyZCcpIDsgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDMsIHApKSB7XG4gICAgICAgICAgICBwW19vcDMubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNBbmNlc3Rvcihfb3AzLCBwKSAmJiBwYXRoW19vcDMubGVuZ3RoXSA+PSBfcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgcFtfb3AzLmxlbmd0aF0gLT0gX3Bvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfb3A0LFxuICAgICAgICAgICAgbmV3UGF0aDogb25wXG4gICAgICAgICAgfSA9IG9wZXJhdGlvbjtcbiAgICAgICAgICAvLyBJZiB0aGUgb2xkIGFuZCBuZXcgcGF0aCBhcmUgdGhlIHNhbWUsIGl0J3MgYSBuby1vcC5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wNCwgb25wKSkge1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wNCwgcCkgfHwgUGF0aC5lcXVhbHMoX29wNCwgcCkpIHtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gb25wLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIG9ucCkgJiYgX29wNC5sZW5ndGggPCBvbnAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvcHlbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvcHkuY29uY2F0KHAuc2xpY2UoX29wNC5sZW5ndGgpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNTaWJsaW5nKF9vcDQsIG9ucCkgJiYgKFBhdGguaXNBbmNlc3RvcihvbnAsIHApIHx8IFBhdGguZXF1YWxzKG9ucCwgcCkpKSB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIHApKSB7XG4gICAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUob25wLCBwKSB8fCBQYXRoLmVxdWFscyhvbnAsIHApIHx8IFBhdGguaXNBbmNlc3RvcihvbnAsIHApKSB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDQsIHApKSB7XG4gICAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcFtvbnAubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9ucCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtvbnAubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfVxufTtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cblxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gIGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG93bktleXMkZShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGUoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRlKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRlKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgYXBwbHlUb0RyYWZ0ID0gKGVkaXRvciwgc2VsZWN0aW9uLCBvcCkgPT4ge1xuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBub2RlXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgdmFyIHBhcmVudCA9IE5vZGUucGFyZW50KGVkaXRvciwgcGF0aCk7XG4gICAgICAgIHZhciBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGluZGV4ID4gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhbiBcXFwiaW5zZXJ0X25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgdGhlIGRlc3RpbmF0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiB0aGUgbm9kZS5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIG5vZGUpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW3BvaW50LCBrZXldIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25ba2V5XSA9IFBvaW50LnRyYW5zZm9ybShwb2ludCwgb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIHRleHRcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT09IDApIGJyZWFrO1xuICAgICAgICB2YXIgX25vZGUgPSBOb2RlLmxlYWYoZWRpdG9yLCBfcGF0aCk7XG4gICAgICAgIHZhciBiZWZvcmUgPSBfbm9kZS50ZXh0LnNsaWNlKDAsIG9mZnNldCk7XG4gICAgICAgIHZhciBhZnRlciA9IF9ub2RlLnRleHQuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgX25vZGUudGV4dCA9IGJlZm9yZSArIHRleHQgKyBhZnRlcjtcbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQsIF9rZXldIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25bX2tleV0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50LCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoMlxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHZhciBfbm9kZTIgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoMik7XG4gICAgICAgIHZhciBwcmV2UGF0aCA9IFBhdGgucHJldmlvdXMoX3BhdGgyKTtcbiAgICAgICAgdmFyIHByZXYgPSBOb2RlLmdldChlZGl0b3IsIHByZXZQYXRoKTtcbiAgICAgICAgdmFyIF9wYXJlbnQgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoMik7XG4gICAgICAgIHZhciBfaW5kZXggPSBfcGF0aDJbX3BhdGgyLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoVGV4dC5pc1RleHQoX25vZGUyKSAmJiBUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgIHByZXYudGV4dCArPSBfbm9kZTIudGV4dDtcbiAgICAgICAgfSBlbHNlIGlmICghVGV4dC5pc1RleHQoX25vZGUyKSAmJiAhVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICBwcmV2LmNoaWxkcmVuLnB1c2goLi4uX25vZGUyLmNoaWxkcmVuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYSBcXFwibWVyZ2Vfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChfcGF0aDIsIFwiXSB0byBub2RlcyBvZiBkaWZmZXJlbnQgaW50ZXJmYWNlczogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkoX25vZGUyKSwgXCIgXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocHJldikpKTtcbiAgICAgICAgfVxuICAgICAgICBfcGFyZW50LmNoaWxkcmVuLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludDIsIF9rZXkyXSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW19rZXkyXSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQyLCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgzLFxuICAgICAgICAgIG5ld1BhdGhcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKF9wYXRoMywgbmV3UGF0aCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbW92ZSBhIHBhdGggW1wiLmNvbmNhdChfcGF0aDMsIFwiXSB0byBuZXcgcGF0aCBbXCIpLmNvbmNhdChuZXdQYXRoLCBcIl0gYmVjYXVzZSB0aGUgZGVzdGluYXRpb24gaXMgaW5zaWRlIGl0c2VsZi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfbm9kZTMgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoMyk7XG4gICAgICAgIHZhciBfcGFyZW50MiA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGgzKTtcbiAgICAgICAgdmFyIF9pbmRleDIgPSBfcGF0aDNbX3BhdGgzLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBUaGlzIGlzIHRyaWNreSwgYnV0IHNpbmNlIHRoZSBgcGF0aGAgYW5kIGBuZXdQYXRoYCBib3RoIHJlZmVyIHRvXG4gICAgICAgIC8vIHRoZSBzYW1lIHNuYXBzaG90IGluIHRpbWUsIHRoZXJlJ3MgYSBtaXNtYXRjaC4gQWZ0ZXIgZWl0aGVyXG4gICAgICAgIC8vIHJlbW92aW5nIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiwgdGhlIHNlY29uZCBzdGVwJ3MgcGF0aCBjYW4gYmUgb3V0XG4gICAgICAgIC8vIG9mIGRhdGUuIFNvIGluc3RlYWQgb2YgdXNpbmcgdGhlIGBvcC5uZXdQYXRoYCBkaXJlY3RseSwgd2VcbiAgICAgICAgLy8gdHJhbnNmb3JtIGBvcC5wYXRoYCB0byBhc2NlcnRhaW4gd2hhdCB0aGUgYG5ld1BhdGhgIHdvdWxkIGJlIGFmdGVyXG4gICAgICAgIC8vIHRoZSBvcGVyYXRpb24gd2FzIGFwcGxpZWQuXG4gICAgICAgIF9wYXJlbnQyLmNoaWxkcmVuLnNwbGljZShfaW5kZXgyLCAxKTtcbiAgICAgICAgdmFyIHRydWVQYXRoID0gUGF0aC50cmFuc2Zvcm0oX3BhdGgzLCBvcCk7XG4gICAgICAgIHZhciBuZXdQYXJlbnQgPSBOb2RlLmdldChlZGl0b3IsIFBhdGgucGFyZW50KHRydWVQYXRoKSk7XG4gICAgICAgIHZhciBuZXdJbmRleCA9IHRydWVQYXRoW3RydWVQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBuZXdQYXJlbnQuY2hpbGRyZW4uc3BsaWNlKG5ld0luZGV4LCAwLCBfbm9kZTMpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludDMsIF9rZXkzXSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW19rZXkzXSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQzLCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDRcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICB2YXIgX2luZGV4MyA9IF9wYXRoNFtfcGF0aDQubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBfcGFyZW50MyA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGg0KTtcbiAgICAgICAgX3BhcmVudDMuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDMsIDEpO1xuICAgICAgICAvLyBUcmFuc2Zvcm0gYWxsIHRoZSBwb2ludHMgaW4gdGhlIHZhbHVlLCBidXQgaWYgdGhlIHBvaW50IHdhcyBpbiB0aGVcbiAgICAgICAgLy8gbm9kZSB0aGF0IHdhcyByZW1vdmVkIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSByYW5nZSBvciByZW1vdmUgaXQuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbX3BvaW50NCwgX2tleTRdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDQsIG9wKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gIT0gbnVsbCAmJiByZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bX2tleTRdID0gcmVzdWx0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9wcmV2ID0gdm9pZCAwO1xuICAgICAgICAgICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgW24sIHBdIG9mIE5vZGUudGV4dHMoZWRpdG9yKSkge1xuICAgICAgICAgICAgICAgIGlmIChQYXRoLmNvbXBhcmUocCwgX3BhdGg0KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIF9wcmV2ID0gW24sIHBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBuZXh0ID0gW24sIHBdO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBwcmVmZXJOZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChfcHJldiAmJiBuZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG5leHRbMV0sIF9wYXRoNCkpIHtcbiAgICAgICAgICAgICAgICAgIHByZWZlck5leHQgPSAhUGF0aC5oYXNQcmV2aW91cyhuZXh0WzFdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcHJlZmVyTmV4dCA9IFBhdGguY29tbW9uKF9wcmV2WzFdLCBfcGF0aDQpLmxlbmd0aCA8IFBhdGguY29tbW9uKG5leHRbMV0sIF9wYXRoNCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoX3ByZXYgJiYgIXByZWZlck5leHQpIHtcbiAgICAgICAgICAgICAgICBfcG9pbnQ0LnBhdGggPSBfcHJldlsxXTtcbiAgICAgICAgICAgICAgICBfcG9pbnQ0Lm9mZnNldCA9IF9wcmV2WzBdLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICBfcG9pbnQ0LnBhdGggPSBuZXh0WzFdO1xuICAgICAgICAgICAgICAgIF9wb2ludDQub2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDUsXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0LFxuICAgICAgICAgIHRleHQ6IF90ZXh0XG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgaWYgKF90ZXh0Lmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgICAgIHZhciBfbm9kZTQgPSBOb2RlLmxlYWYoZWRpdG9yLCBfcGF0aDUpO1xuICAgICAgICB2YXIgX2JlZm9yZSA9IF9ub2RlNC50ZXh0LnNsaWNlKDAsIF9vZmZzZXQpO1xuICAgICAgICB2YXIgX2FmdGVyID0gX25vZGU0LnRleHQuc2xpY2UoX29mZnNldCArIF90ZXh0Lmxlbmd0aCk7XG4gICAgICAgIF9ub2RlNC50ZXh0ID0gX2JlZm9yZSArIF9hZnRlcjtcbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQ1LCBfa2V5NV0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5NV0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50NSwgb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg2LFxuICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgbmV3UHJvcGVydGllc1xuICAgICAgICB9ID0gb3A7XG4gICAgICAgIGlmIChfcGF0aDYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSByb290IG5vZGUhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfbm9kZTUgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoNik7XG4gICAgICAgIGZvciAodmFyIF9rZXk2IGluIG5ld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAoX2tleTYgPT09ICdjaGlsZHJlbicgfHwgX2tleTYgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCB0aGUgXFxcIlwiLmNvbmNhdChfa2V5NiwgXCJcXFwiIHByb3BlcnR5IG9mIG5vZGVzIVwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2YWx1ZSA9IG5ld1Byb3BlcnRpZXNbX2tleTZdO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgX25vZGU1W19rZXk2XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX25vZGU1W19rZXk2XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBwcmV2aW91c2x5IGRlZmluZWQsIGJ1dCBhcmUgbm93IG1pc3NpbmcsIG11c3QgYmUgZGVsZXRlZFxuICAgICAgICBmb3IgKHZhciBfa2V5NyBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKCFuZXdQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KF9rZXk3KSkge1xuICAgICAgICAgICAgZGVsZXRlIF9ub2RlNVtfa2V5N107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgaWYgKF9uZXdQcm9wZXJ0aWVzID09IG51bGwpIHtcbiAgICAgICAgICBzZWxlY3Rpb24gPSBfbmV3UHJvcGVydGllcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghUmFuZ2UuaXNSYW5nZShfbmV3UHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGFuIGluY29tcGxldGUgXFxcInNldF9zZWxlY3Rpb25cXFwiIG9wZXJhdGlvbiBwcm9wZXJ0aWVzIFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkoX25ld1Byb3BlcnRpZXMpLCBcIiB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQgc2VsZWN0aW9uLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBfb2JqZWN0U3ByZWFkJGUoe30sIF9uZXdQcm9wZXJ0aWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgX2tleTggaW4gX25ld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciBfdmFsdWUgPSBfbmV3UHJvcGVydGllc1tfa2V5OF07XG4gICAgICAgICAgICBpZiAoX3ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKF9rZXk4ID09PSAnYW5jaG9yJyB8fCBfa2V5OCA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZW1vdmUgdGhlIFxcXCJcIi5jb25jYXQoX2tleTgsIFwiXFxcIiBzZWxlY3Rpb24gcHJvcGVydHlcIikpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlbGV0ZSBzZWxlY3Rpb25bX2tleThdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk4XSA9IF92YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg3LFxuICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgIHByb3BlcnRpZXM6IF9wcm9wZXJ0aWVzXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgaWYgKF9wYXRoNy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYSBcXFwic3BsaXRfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChfcGF0aDcsIFwiXSBiZWNhdXNlIHRoZSByb290IG5vZGUgY2Fubm90IGJlIHNwbGl0LlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9ub2RlNiA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGg3KTtcbiAgICAgICAgdmFyIF9wYXJlbnQ0ID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDcpO1xuICAgICAgICB2YXIgX2luZGV4NCA9IF9wYXRoN1tfcGF0aDcubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBuZXdOb2RlO1xuICAgICAgICBpZiAoVGV4dC5pc1RleHQoX25vZGU2KSkge1xuICAgICAgICAgIHZhciBfYmVmb3JlMiA9IF9ub2RlNi50ZXh0LnNsaWNlKDAsIHBvc2l0aW9uKTtcbiAgICAgICAgICB2YXIgX2FmdGVyMiA9IF9ub2RlNi50ZXh0LnNsaWNlKHBvc2l0aW9uKTtcbiAgICAgICAgICBfbm9kZTYudGV4dCA9IF9iZWZvcmUyO1xuICAgICAgICAgIG5ld05vZGUgPSBfb2JqZWN0U3ByZWFkJGUoX29iamVjdFNwcmVhZCRlKHt9LCBfcHJvcGVydGllcyksIHt9LCB7XG4gICAgICAgICAgICB0ZXh0OiBfYWZ0ZXIyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9iZWZvcmUzID0gX25vZGU2LmNoaWxkcmVuLnNsaWNlKDAsIHBvc2l0aW9uKTtcbiAgICAgICAgICB2YXIgX2FmdGVyMyA9IF9ub2RlNi5jaGlsZHJlbi5zbGljZShwb3NpdGlvbik7XG4gICAgICAgICAgX25vZGU2LmNoaWxkcmVuID0gX2JlZm9yZTM7XG4gICAgICAgICAgbmV3Tm9kZSA9IF9vYmplY3RTcHJlYWQkZShfb2JqZWN0U3ByZWFkJGUoe30sIF9wcm9wZXJ0aWVzKSwge30sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBfYWZ0ZXIzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX3BhcmVudDQuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDQgKyAxLCAwLCBuZXdOb2RlKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQ2LCBfa2V5OV0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5OV0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50Niwgb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gc2VsZWN0aW9uO1xufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBHZW5lcmFsVHJhbnNmb3JtcyA9IHtcbiAgdHJhbnNmb3JtKGVkaXRvciwgb3ApIHtcbiAgICBlZGl0b3IuY2hpbGRyZW4gPSBjcmVhdGVEcmFmdChlZGl0b3IuY2hpbGRyZW4pO1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uICYmIGNyZWF0ZURyYWZ0KGVkaXRvci5zZWxlY3Rpb24pO1xuICAgIHRyeSB7XG4gICAgICBzZWxlY3Rpb24gPSBhcHBseVRvRHJhZnQoZWRpdG9yLCBzZWxlY3Rpb24sIG9wKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZWRpdG9yLmNoaWxkcmVuID0gZmluaXNoRHJhZnQoZWRpdG9yLmNoaWxkcmVuKTtcbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IGlzRHJhZnQoc2VsZWN0aW9uKSA/IGZpbmlzaERyYWZ0KHNlbGVjdGlvbikgOiBzZWxlY3Rpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBOb2RlVHJhbnNmb3JtcyA9IHtcbiAgaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2Rlcywgb3B0aW9ucykge1xuICAgIGVkaXRvci5pbnNlcnROb2Rlcyhub2Rlcywgb3B0aW9ucyk7XG4gIH0sXG4gIGxpZnROb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IubGlmdE5vZGVzKG9wdGlvbnMpO1xuICB9LFxuICBtZXJnZU5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5tZXJnZU5vZGVzKG9wdGlvbnMpO1xuICB9LFxuICBtb3ZlTm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLm1vdmVOb2RlcyhvcHRpb25zKTtcbiAgfSxcbiAgcmVtb3ZlTm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnJlbW92ZU5vZGVzKG9wdGlvbnMpO1xuICB9LFxuICBzZXROb2RlcyhlZGl0b3IsIHByb3BzLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnNldE5vZGVzKHByb3BzLCBvcHRpb25zKTtcbiAgfSxcbiAgc3BsaXROb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3Iuc3BsaXROb2RlcyhvcHRpb25zKTtcbiAgfSxcbiAgdW5zZXROb2RlcyhlZGl0b3IsIHByb3BzLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnVuc2V0Tm9kZXMocHJvcHMsIG9wdGlvbnMpO1xuICB9LFxuICB1bndyYXBOb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IudW53cmFwTm9kZXMob3B0aW9ucyk7XG4gIH0sXG4gIHdyYXBOb2RlcyhlZGl0b3IsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3Iud3JhcE5vZGVzKGVsZW1lbnQsIG9wdGlvbnMpO1xuICB9XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgU2VsZWN0aW9uVHJhbnNmb3JtcyA9IHtcbiAgY29sbGFwc2UoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmNvbGxhcHNlKG9wdGlvbnMpO1xuICB9LFxuICBkZXNlbGVjdChlZGl0b3IpIHtcbiAgICBlZGl0b3IuZGVzZWxlY3QoKTtcbiAgfSxcbiAgbW92ZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IubW92ZShvcHRpb25zKTtcbiAgfSxcbiAgc2VsZWN0KGVkaXRvciwgdGFyZ2V0KSB7XG4gICAgZWRpdG9yLnNlbGVjdCh0YXJnZXQpO1xuICB9LFxuICBzZXRQb2ludChlZGl0b3IsIHByb3BzLCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLnNldFBvaW50KHByb3BzLCBvcHRpb25zKTtcbiAgfSxcbiAgc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpIHtcbiAgICBlZGl0b3Iuc2V0U2VsZWN0aW9uKHByb3BzKTtcbiAgfVxufTtcblxuLypcbiAgQ3VzdG9tIGRlZXAgZXF1YWwgY29tcGFyaXNvbiBmb3IgU2xhdGUgbm9kZXMuXG5cbiAgV2UgZG9uJ3QgbmVlZCBnZW5lcmFsIHB1cnBvc2UgZGVlcCBlcXVhbGl0eTtcbiAgU2xhdGUgb25seSBzdXBwb3J0cyBwbGFpbiB2YWx1ZXMsIEFycmF5cywgYW5kIG5lc3RlZCBvYmplY3RzLlxuICBDb21wbGV4IHZhbHVlcyBuZXN0ZWQgaW5zaWRlIEFycmF5cyBhcmUgbm90IHN1cHBvcnRlZC5cblxuICBTbGF0ZSBvYmplY3RzIGFyZSBkZXNpZ25lZCB0byBiZSBzZXJpYWxpc2VkLCBzb1xuICBtaXNzaW5nIGtleXMgYXJlIGRlbGliZXJhdGVseSBub3JtYWxpc2VkIHRvIHVuZGVmaW5lZC5cbiAqL1xudmFyIGlzRGVlcEVxdWFsID0gKG5vZGUsIGFub3RoZXIpID0+IHtcbiAgZm9yICh2YXIga2V5IGluIG5vZGUpIHtcbiAgICB2YXIgYSA9IG5vZGVba2V5XTtcbiAgICB2YXIgYiA9IGFub3RoZXJba2V5XTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChhKSAmJiBpc1BsYWluT2JqZWN0KGIpKSB7XG4gICAgICBpZiAoIWlzRGVlcEVxdWFsKGEsIGIpKSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYSAhPT0gYikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKlxuICAgIERlZXAgb2JqZWN0IGVxdWFsaXR5IGlzIG9ubHkgbmVjZXNzYXJ5IGluIG9uZSBkaXJlY3Rpb247IGluIHRoZSByZXZlcnNlIGRpcmVjdGlvblxuICAgIHdlIGFyZSBvbmx5IGxvb2tpbmcgZm9yIGtleXMgdGhhdCBhcmUgbWlzc2luZy5cbiAgICBBcyBhYm92ZSwgdW5kZWZpbmVkIGtleXMgYXJlIG5vcm1hbGlzZWQgdG8gbWlzc2luZy5cbiAgKi9cbiAgZm9yICh2YXIgX2tleSBpbiBhbm90aGVyKSB7XG4gICAgaWYgKG5vZGVbX2tleV0gPT09IHVuZGVmaW5lZCAmJiBhbm90aGVyW19rZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgX2V4Y2x1ZGVkJDQgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXTtcbmZ1bmN0aW9uIG93bktleXMkZChlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRkKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRkKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgUmFuZ2UgPSB7XG4gIGVkZ2VzKHJhbmdlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gcmFuZ2U7XG4gICAgcmV0dXJuIFJhbmdlLmlzQmFja3dhcmQocmFuZ2UpID09PSByZXZlcnNlID8gW2FuY2hvciwgZm9jdXNdIDogW2ZvY3VzLCBhbmNob3JdO1xuICB9LFxuICBlbmQocmFuZ2UpIHtcbiAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICByZXR1cm4gZW5kO1xuICB9LFxuICBlcXVhbHMocmFuZ2UsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUG9pbnQuZXF1YWxzKHJhbmdlLmFuY2hvciwgYW5vdGhlci5hbmNob3IpICYmIFBvaW50LmVxdWFscyhyYW5nZS5mb2N1cywgYW5vdGhlci5mb2N1cyk7XG4gIH0sXG4gIGluY2x1ZGVzKHJhbmdlLCB0YXJnZXQpIHtcbiAgICBpZiAoUmFuZ2UuaXNSYW5nZSh0YXJnZXQpKSB7XG4gICAgICBpZiAoUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHRhcmdldC5hbmNob3IpIHx8IFJhbmdlLmluY2x1ZGVzKHJhbmdlLCB0YXJnZXQuZm9jdXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIFtycywgcmVdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgICAgdmFyIFt0cywgdGVdID0gUmFuZ2UuZWRnZXModGFyZ2V0KTtcbiAgICAgIHJldHVybiBQb2ludC5pc0JlZm9yZShycywgdHMpICYmIFBvaW50LmlzQWZ0ZXIocmUsIHRlKTtcbiAgICB9XG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICB2YXIgaXNBZnRlclN0YXJ0ID0gZmFsc2U7XG4gICAgdmFyIGlzQmVmb3JlRW5kID0gZmFsc2U7XG4gICAgaWYgKFBvaW50LmlzUG9pbnQodGFyZ2V0KSkge1xuICAgICAgaXNBZnRlclN0YXJ0ID0gUG9pbnQuY29tcGFyZSh0YXJnZXQsIHN0YXJ0KSA+PSAwO1xuICAgICAgaXNCZWZvcmVFbmQgPSBQb2ludC5jb21wYXJlKHRhcmdldCwgZW5kKSA8PSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0FmdGVyU3RhcnQgPSBQYXRoLmNvbXBhcmUodGFyZ2V0LCBzdGFydC5wYXRoKSA+PSAwO1xuICAgICAgaXNCZWZvcmVFbmQgPSBQYXRoLmNvbXBhcmUodGFyZ2V0LCBlbmQucGF0aCkgPD0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGlzQWZ0ZXJTdGFydCAmJiBpc0JlZm9yZUVuZDtcbiAgfSxcbiAgaW50ZXJzZWN0aW9uKHJhbmdlLCBhbm90aGVyKSB7XG4gICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmFuZ2UsIF9leGNsdWRlZCQ0KTtcbiAgICB2YXIgW3MxLCBlMV0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIFtzMiwgZTJdID0gUmFuZ2UuZWRnZXMoYW5vdGhlcik7XG4gICAgdmFyIHN0YXJ0ID0gUG9pbnQuaXNCZWZvcmUoczEsIHMyKSA/IHMyIDogczE7XG4gICAgdmFyIGVuZCA9IFBvaW50LmlzQmVmb3JlKGUxLCBlMikgPyBlMSA6IGUyO1xuICAgIGlmIChQb2ludC5pc0JlZm9yZShlbmQsIHN0YXJ0KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGQoe1xuICAgICAgICBhbmNob3I6IHN0YXJ0LFxuICAgICAgICBmb2N1czogZW5kXG4gICAgICB9LCByZXN0KTtcbiAgICB9XG4gIH0sXG4gIGlzQmFja3dhcmQocmFuZ2UpIHtcbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gcmFuZ2U7XG4gICAgcmV0dXJuIFBvaW50LmlzQWZ0ZXIoYW5jaG9yLCBmb2N1cyk7XG4gIH0sXG4gIGlzQ29sbGFwc2VkKHJhbmdlKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMoYW5jaG9yLCBmb2N1cyk7XG4gIH0sXG4gIGlzRXhwYW5kZWQocmFuZ2UpIHtcbiAgICByZXR1cm4gIVJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKTtcbiAgfSxcbiAgaXNGb3J3YXJkKHJhbmdlKSB7XG4gICAgcmV0dXJuICFSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKTtcbiAgfSxcbiAgaXNSYW5nZSh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBQb2ludC5pc1BvaW50KHZhbHVlLmFuY2hvcikgJiYgUG9pbnQuaXNQb2ludCh2YWx1ZS5mb2N1cyk7XG4gIH0sXG4gICpwb2ludHMocmFuZ2UpIHtcbiAgICB5aWVsZCBbcmFuZ2UuYW5jaG9yLCAnYW5jaG9yJ107XG4gICAgeWllbGQgW3JhbmdlLmZvY3VzLCAnZm9jdXMnXTtcbiAgfSxcbiAgc3RhcnQocmFuZ2UpIHtcbiAgICB2YXIgW3N0YXJ0XSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICByZXR1cm4gc3RhcnQ7XG4gIH0sXG4gIHRyYW5zZm9ybShyYW5nZSwgb3ApIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIHByb2R1Y2UocmFuZ2UsIHIgPT4ge1xuICAgICAgaWYgKHIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIge1xuICAgICAgICBhZmZpbml0eSA9ICdpbndhcmQnXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciBhZmZpbml0eUFuY2hvcjtcbiAgICAgIHZhciBhZmZpbml0eUZvY3VzO1xuICAgICAgaWYgKGFmZmluaXR5ID09PSAnaW53YXJkJykge1xuICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLCBtYWtlIHN1cmUgdG8gdXNlIHRoZSBzYW1lIGFmZmluaXR5IHRvXG4gICAgICAgIC8vIGF2b2lkIHRoZSB0d28gcG9pbnRzIHBhc3NpbmcgZWFjaCBvdGhlciBhbmQgZXhwYW5kaW5nIGluIHRoZSBvcHBvc2l0ZVxuICAgICAgICAvLyBkaXJlY3Rpb25cbiAgICAgICAgdmFyIGlzQ29sbGFwc2VkID0gUmFuZ2UuaXNDb2xsYXBzZWQocik7XG4gICAgICAgIGlmIChSYW5nZS5pc0ZvcndhcmQocikpIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdmb3J3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gaXNDb2xsYXBzZWQgPyBhZmZpbml0eUFuY2hvciA6ICdiYWNrd2FyZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnYmFja3dhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFmZmluaXR5QW5jaG9yIDogJ2ZvcndhcmQnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFmZmluaXR5ID09PSAnb3V0d2FyZCcpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzRm9yd2FyZChyKSkge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2JhY2t3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gJ2ZvcndhcmQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2ZvcndhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSAnYmFja3dhcmQnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZmZpbml0eUFuY2hvciA9IGFmZmluaXR5O1xuICAgICAgICBhZmZpbml0eUZvY3VzID0gYWZmaW5pdHk7XG4gICAgICB9XG4gICAgICB2YXIgYW5jaG9yID0gUG9pbnQudHJhbnNmb3JtKHIuYW5jaG9yLCBvcCwge1xuICAgICAgICBhZmZpbml0eTogYWZmaW5pdHlBbmNob3JcbiAgICAgIH0pO1xuICAgICAgdmFyIGZvY3VzID0gUG9pbnQudHJhbnNmb3JtKHIuZm9jdXMsIG9wLCB7XG4gICAgICAgIGFmZmluaXR5OiBhZmZpbml0eUZvY3VzXG4gICAgICB9KTtcbiAgICAgIGlmICghYW5jaG9yIHx8ICFmb2N1cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHIuYW5jaG9yID0gYW5jaG9yO1xuICAgICAgci5mb2N1cyA9IGZvY3VzO1xuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIFNoYXJlZCB0aGUgZnVuY3Rpb24gd2l0aCBpc0VsZW1lbnRUeXBlIHV0aWxpdHlcbiAqL1xudmFyIGlzRWxlbWVudCA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbikgJiYgIUVkaXRvci5pc0VkaXRvcih2YWx1ZSk7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIEVsZW1lbnQgPSB7XG4gIGlzQW5jZXN0b3IodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKTtcbiAgfSxcbiAgaXNFbGVtZW50LFxuICBpc0VsZW1lbnRMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBFbGVtZW50LmlzRWxlbWVudCh2YWwpKTtcbiAgfSxcbiAgaXNFbGVtZW50UHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4gIT09IHVuZGVmaW5lZDtcbiAgfSxcbiAgaXNFbGVtZW50VHlwZTogZnVuY3Rpb24gaXNFbGVtZW50VHlwZSh2YWx1ZSwgZWxlbWVudFZhbCkge1xuICAgIHZhciBlbGVtZW50S2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAndHlwZSc7XG4gICAgcmV0dXJuIGlzRWxlbWVudCh2YWx1ZSkgJiYgdmFsdWVbZWxlbWVudEtleV0gPT09IGVsZW1lbnRWYWw7XG4gIH0sXG4gIG1hdGNoZXMoZWxlbWVudCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdjaGlsZHJlbicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudFtrZXldICE9PSBwcm9wc1trZXldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbnZhciBfZXhjbHVkZWQkMyA9IFtcImNoaWxkcmVuXCJdLFxuICBfZXhjbHVkZWQyJDMgPSBbXCJ0ZXh0XCJdO1xudmFyIElTX05PREVfTElTVF9DQUNIRSA9IG5ldyBXZWFrTWFwKCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgTm9kZSA9IHtcbiAgYW5jZXN0b3Iocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQocm9vdCwgcGF0aCk7XG4gICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBhbmNlc3RvciBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCByZWZlcnMgdG8gYSB0ZXh0IG5vZGUgaW5zdGVhZDogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIGFuY2VzdG9ycyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yICh2YXIgcCBvZiBQYXRoLmFuY2VzdG9ycyhwYXRoLCBvcHRpb25zKSkge1xuICAgICAgICB2YXIgbiA9IE5vZGUuYW5jZXN0b3Iocm9vdCwgcCk7XG4gICAgICAgIHZhciBlbnRyeSA9IFtuLCBwXTtcbiAgICAgICAgeWllbGQgZW50cnk7XG4gICAgICB9XG4gICAgfSgpO1xuICB9LFxuICBjaGlsZChyb290LCBpbmRleCkge1xuICAgIGlmIChUZXh0LmlzVGV4dChyb290KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgY2hpbGQgb2YgYSB0ZXh0IG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG4gICAgdmFyIGMgPSByb290LmNoaWxkcmVuW2luZGV4XTtcbiAgICBpZiAoYyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGNoaWxkIGF0IGluZGV4IGBcIi5jb25jYXQoaW5kZXgsIFwiYCBpbiBub2RlOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShyb290KSkpO1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfSxcbiAgY2hpbGRyZW4ocm9vdCwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBOb2RlLmFuY2VzdG9yKHJvb3QsIHBhdGgpO1xuICAgICAgdmFyIHtcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgIH0gPSBhbmNlc3RvcjtcbiAgICAgIHZhciBpbmRleCA9IHJldmVyc2UgPyBjaGlsZHJlbi5sZW5ndGggLSAxIDogMDtcbiAgICAgIHdoaWxlIChyZXZlcnNlID8gaW5kZXggPj0gMCA6IGluZGV4IDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IE5vZGUuY2hpbGQoYW5jZXN0b3IsIGluZGV4KTtcbiAgICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGguY29uY2F0KGluZGV4KTtcbiAgICAgICAgeWllbGQgW2NoaWxkLCBjaGlsZFBhdGhdO1xuICAgICAgICBpbmRleCA9IHJldmVyc2UgPyBpbmRleCAtIDEgOiBpbmRleCArIDE7XG4gICAgICB9XG4gICAgfSgpO1xuICB9LFxuICBjb21tb24ocm9vdCwgcGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBwID0gUGF0aC5jb21tb24ocGF0aCwgYW5vdGhlcik7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuICBkZXNjZW5kYW50KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuICAgIGlmIChFZGl0b3IuaXNFZGl0b3Iobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGRlc2NlbmRhbnQgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIHRoZSByb290IGVkaXRvciBub2RlIGluc3RlYWQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBkZXNjZW5kYW50cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgLy8gTk9URTogd2UgaGF2ZSB0byBjb2VyY2UgaGVyZSBiZWNhdXNlIGNoZWNraW5nIHRoZSBwYXRoJ3MgbGVuZ3RoIGRvZXNcbiAgICAgICAgICAvLyBndWFyYW50ZWUgdGhhdCBgbm9kZWAgaXMgbm90IGEgYEVkaXRvcmAsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdy5cbiAgICAgICAgICB5aWVsZCBbbm9kZSwgcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KCk7XG4gIH0sXG4gIGVsZW1lbnRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICB5aWVsZCBbbm9kZSwgcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KCk7XG4gIH0sXG4gIGV4dHJhY3RQcm9wcyhub2RlKSB7XG4gICAgaWYgKEVsZW1lbnQuaXNBbmNlc3Rvcihub2RlKSkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkJDMpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZDIkMyk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9XG4gIH0sXG4gIGZpcnN0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgcCA9IHBhdGguc2xpY2UoKTtcbiAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobikgfHwgbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gbi5jaGlsZHJlblswXTtcbiAgICAgICAgcC5wdXNoKDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuICBmcmFnbWVudChyb290LCByYW5nZSkge1xuICAgIGlmIChUZXh0LmlzVGV4dChyb290KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBhIGZyYWdtZW50IHN0YXJ0aW5nIGZyb20gYSByb290IHRleHQgbm9kZTogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShyb290KSkpO1xuICAgIH1cbiAgICB2YXIgbmV3Um9vdCA9IHByb2R1Y2Uoe1xuICAgICAgY2hpbGRyZW46IHJvb3QuY2hpbGRyZW5cbiAgICB9LCByID0+IHtcbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgICB2YXIgbm9kZUVudHJpZXMgPSBOb2RlLm5vZGVzKHIsIHtcbiAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgcGFzczogX3JlZiA9PiB7XG4gICAgICAgICAgdmFyIFssIHBhdGhdID0gX3JlZjtcbiAgICAgICAgICByZXR1cm4gIVJhbmdlLmluY2x1ZGVzKHJhbmdlLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBbLCBwYXRoXSBvZiBub2RlRW50cmllcykge1xuICAgICAgICBpZiAoIVJhbmdlLmluY2x1ZGVzKHJhbmdlLCBwYXRoKSkge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChyLCBwYXRoKTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICAgIHZhciBsZWFmID0gTm9kZS5sZWFmKHIsIHBhdGgpO1xuICAgICAgICAgIGxlYWYudGV4dCA9IGxlYWYudGV4dC5zbGljZSgwLCBlbmQub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgc3RhcnQucGF0aCkpIHtcbiAgICAgICAgICB2YXIgX2xlYWYgPSBOb2RlLmxlYWYociwgcGF0aCk7XG4gICAgICAgICAgX2xlYWYudGV4dCA9IF9sZWFmLnRleHQuc2xpY2Uoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKEVkaXRvci5pc0VkaXRvcihyKSkge1xuICAgICAgICByLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld1Jvb3QuY2hpbGRyZW47XG4gIH0sXG4gIGdldChyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSByb290O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwYXRoW2ldO1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpIHx8ICFub2RlLmNoaWxkcmVuW3BdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGVzY2VuZGFudCBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGluIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5jaGlsZHJlbltwXTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIGhhcyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSByb290O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwYXRoW2ldO1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpIHx8ICFub2RlLmNoaWxkcmVuW3BdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgaXNOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIFRleHQuaXNUZXh0KHZhbHVlKSB8fCBFbGVtZW50LmlzRWxlbWVudCh2YWx1ZSkgfHwgRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbiAgfSxcbiAgaXNOb2RlTGlzdCh2YWx1ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNhY2hlZFJlc3VsdCA9IElTX05PREVfTElTVF9DQUNIRS5nZXQodmFsdWUpO1xuICAgIGlmIChjYWNoZWRSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgICB9XG4gICAgdmFyIGlzTm9kZUxpc3QgPSB2YWx1ZS5ldmVyeSh2YWwgPT4gTm9kZS5pc05vZGUodmFsKSk7XG4gICAgSVNfTk9ERV9MSVNUX0NBQ0hFLnNldCh2YWx1ZSwgaXNOb2RlTGlzdCk7XG4gICAgcmV0dXJuIGlzTm9kZUxpc3Q7XG4gIH0sXG4gIGxhc3Qocm9vdCwgcGF0aCkge1xuICAgIHZhciBwID0gcGF0aC5zbGljZSgpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChUZXh0LmlzVGV4dChuKSB8fCBuLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gbi5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICBuID0gbi5jaGlsZHJlbltpXTtcbiAgICAgICAgcC5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW24sIHBdO1xuICB9LFxuICBsZWFmKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIGxlYWYgbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgbm9uLWxlYWYgbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIGxldmVscyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yICh2YXIgcCBvZiBQYXRoLmxldmVscyhwYXRoLCBvcHRpb25zKSkge1xuICAgICAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICB5aWVsZCBbbiwgcF07XG4gICAgICB9XG4gICAgfSgpO1xuICB9LFxuICBtYXRjaGVzKG5vZGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVsZW1lbnQuaXNFbGVtZW50UHJvcHMocHJvcHMpICYmIEVsZW1lbnQubWF0Y2hlcyhub2RlLCBwcm9wcykgfHwgVGV4dC5pc1RleHQobm9kZSkgJiYgVGV4dC5pc1RleHRQcm9wcyhwcm9wcykgJiYgVGV4dC5tYXRjaGVzKG5vZGUsIHByb3BzKTtcbiAgfSxcbiAgbm9kZXMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciB7XG4gICAgICAgIHBhc3MsXG4gICAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBmcm9tID0gW10sXG4gICAgICAgIHRvXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgICAgdmFyIHAgPSBbXTtcbiAgICAgIHZhciBuID0gcm9vdDtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmICh0byAmJiAocmV2ZXJzZSA/IFBhdGguaXNCZWZvcmUocCwgdG8pIDogUGF0aC5pc0FmdGVyKHAsIHRvKSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKG4pKSB7XG4gICAgICAgICAgeWllbGQgW24sIHBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3JlIGFsbG93ZWQgdG8gZ28gZG93bndhcmQgYW5kIHdlIGhhdmVuJ3QgZGVzY2VuZGVkIHlldCwgZG8uXG4gICAgICAgIGlmICghdmlzaXRlZC5oYXMobikgJiYgIVRleHQuaXNUZXh0KG4pICYmIG4uY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIChwYXNzID09IG51bGwgfHwgcGFzcyhbbiwgcF0pID09PSBmYWxzZSkpIHtcbiAgICAgICAgICB2aXNpdGVkLmFkZChuKTtcbiAgICAgICAgICB2YXIgbmV4dEluZGV4ID0gcmV2ZXJzZSA/IG4uY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgICAgaWYgKFBhdGguaXNBbmNlc3RvcihwLCBmcm9tKSkge1xuICAgICAgICAgICAgbmV4dEluZGV4ID0gZnJvbVtwLmxlbmd0aF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHAgPSBwLmNvbmNhdChuZXh0SW5kZXgpO1xuICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSBhdCB0aGUgcm9vdCBhbmQgd2UgY2FuJ3QgZ28gZG93biwgd2UncmUgZG9uZS5cbiAgICAgICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UncmUgZ29pbmcgZm9yd2FyZC4uLlxuICAgICAgICBpZiAoIXJldmVyc2UpIHtcbiAgICAgICAgICB2YXIgbmV3UGF0aCA9IFBhdGgubmV4dChwKTtcbiAgICAgICAgICBpZiAoTm9kZS5oYXMocm9vdCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHAgPSBuZXdQYXRoO1xuICAgICAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3JlIGdvaW5nIGJhY2t3YXJkLi4uXG4gICAgICAgIGlmIChyZXZlcnNlICYmIHBbcC5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgICAgIHZhciBfbmV3UGF0aCA9IFBhdGgucHJldmlvdXMocCk7XG4gICAgICAgICAgcCA9IF9uZXdQYXRoO1xuICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2Ugd2UncmUgZ29pbmcgdXB3YXJkLi4uXG4gICAgICAgIHAgPSBQYXRoLnBhcmVudChwKTtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICB2aXNpdGVkLmFkZChuKTtcbiAgICAgIH1cbiAgICB9KCk7XG4gIH0sXG4gIHBhcmVudChyb290LCBwYXRoKSB7XG4gICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgICB2YXIgcCA9IE5vZGUuZ2V0KHJvb3QsIHBhcmVudFBhdGgpO1xuICAgIGlmIChUZXh0LmlzVGV4dChwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IG9mIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgcm9vdC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSxcbiAgc3RyaW5nKG5vZGUpIHtcbiAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlLnRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLm1hcChOb2RlLnN0cmluZykuam9pbignJyk7XG4gICAgfVxuICB9LFxuICB0ZXh0cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpIHtcbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJGMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCRjKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkYyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkYyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIE9wZXJhdGlvbiA9IHtcbiAgaXNOb2RlT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX25vZGUnKTtcbiAgfSxcbiAgaXNPcGVyYXRpb24odmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgTm9kZS5pc05vZGUodmFsdWUubm9kZSk7XG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5wb3NpdGlvbiA9PT0gJ251bWJlcicgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKTtcbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5uZXdQYXRoKTtcbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLm9mZnNldCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5wcm9wZXJ0aWVzKSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlLm5ld1Byb3BlcnRpZXMpO1xuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHJldHVybiB2YWx1ZS5wcm9wZXJ0aWVzID09PSBudWxsICYmIFJhbmdlLmlzUmFuZ2UodmFsdWUubmV3UHJvcGVydGllcykgfHwgdmFsdWUubmV3UHJvcGVydGllcyA9PT0gbnVsbCAmJiBSYW5nZS5pc1JhbmdlKHZhbHVlLnByb3BlcnRpZXMpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgdHlwZW9mIHZhbHVlLnBvc2l0aW9uID09PSAnbnVtYmVyJyAmJiBpc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgaXNPcGVyYXRpb25MaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsKSk7XG4gIH0sXG4gIGlzU2VsZWN0aW9uT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9wZXJhdGlvbi5pc09wZXJhdGlvbih2YWx1ZSkgJiYgdmFsdWUudHlwZS5lbmRzV2l0aCgnX3NlbGVjdGlvbicpO1xuICB9LFxuICBpc1RleHRPcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfdGV4dCcpO1xuICB9LFxuICBpbnZlcnNlKG9wKSB7XG4gICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV9ub2RlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnc3BsaXRfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLnByZXZpb3VzKG9wLnBhdGgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgbmV3UGF0aCxcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICB9ID0gb3A7XG4gICAgICAgICAgLy8gUEVSRjogaW4gdGhpcyBjYXNlIHRoZSBtb3ZlIG9wZXJhdGlvbiBpcyBhIG5vLW9wIGFueXdheXMuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG5ld1BhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElmIHRoZSBtb3ZlIGhhcHBlbnMgY29tcGxldGVseSB3aXRoaW4gYSBzaW5nbGUgcGFyZW50IHRoZSBwYXRoIGFuZFxuICAgICAgICAgIC8vIG5ld1BhdGggYXJlIHN0YWJsZSB3aXRoIHJlc3BlY3QgdG8gZWFjaCBvdGhlci5cbiAgICAgICAgICBpZiAoUGF0aC5pc1NpYmxpbmcocGF0aCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgICAgICAgIG5ld1BhdGg6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiB0aGUgbW92ZSBkb2VzIG5vdCBoYXBwZW4gd2l0aGluIGEgc2luZ2xlIHBhcmVudCBpdCBpcyBwb3NzaWJsZVxuICAgICAgICAgIC8vIGZvciB0aGUgbW92ZSB0byBpbXBhY3QgdGhlIHRydWUgcGF0aCB0byB0aGUgbG9jYXRpb24gd2hlcmUgdGhlIG5vZGVcbiAgICAgICAgICAvLyB3YXMgcmVtb3ZlZCBmcm9tIGFuZCB3aGVyZSBpdCB3YXMgaW5zZXJ0ZWQuIFdlIGhhdmUgdG8gYWRqdXN0IGZvciB0aGlzXG4gICAgICAgICAgLy8gYW5kIGZpbmQgdGhlIG9yaWdpbmFsIHBhdGguIFdlIGNhbiBhY2NvbXBsaXNoIHRoaXMgKG9ubHkgaW4gbm9uLXNpYmxpbmcpXG4gICAgICAgICAgLy8gbW92ZXMgYnkgbG9va2luZyBhdCB0aGUgaW1wYWN0IG9mIHRoZSBtb3ZlIG9wZXJhdGlvbiBvbiB0aGUgbm9kZVxuICAgICAgICAgIC8vIGFmdGVyIHRoZSBvcmlnaW5hbCBtb3ZlIHBhdGguXG4gICAgICAgICAgdmFyIGludmVyc2VQYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApO1xuICAgICAgICAgIHZhciBpbnZlcnNlTmV3UGF0aCA9IFBhdGgudHJhbnNmb3JtKFBhdGgubmV4dChwYXRoKSwgb3ApO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICBwYXRoOiBpbnZlcnNlUGF0aCxcbiAgICAgICAgICAgIG5ld1BhdGg6IGludmVyc2VOZXdQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X25vZGUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJGMoX29iamVjdFNwcmVhZCRjKHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllc1xuICAgICAgICAgIH0gPSBvcDtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgcHJvcGVydGllczogbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IHByb3BlcnRpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcHJvcGVydGllczogX3Byb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllc1xuICAgICAgICAgIH0gPSBvcDtcbiAgICAgICAgICBpZiAoX3Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogX25ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkYyhfb2JqZWN0U3ByZWFkJGMoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCRjKF9vYmplY3RTcHJlYWQkYyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ21lcmdlX25vZGUnLFxuICAgICAgICAgICAgcGF0aDogUGF0aC5uZXh0KG9wLnBhdGgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBJU19FRElUT1JfQ0FDSEUgPSBuZXcgV2Vha01hcCgpO1xudmFyIGlzRWRpdG9yID0gdmFsdWUgPT4ge1xuICB2YXIgY2FjaGVkSXNFZGl0b3IgPSBJU19FRElUT1JfQ0FDSEUuZ2V0KHZhbHVlKTtcbiAgaWYgKGNhY2hlZElzRWRpdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkSXNFZGl0b3I7XG4gIH1cbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaXNFZGl0b3IgPSB0eXBlb2YgdmFsdWUuYWRkTWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuYXBwbHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmRlbGV0ZUZyYWdtZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRCcmVhayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0U29mdEJyZWFrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pbnNlcnRGcmFnbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0Tm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0VGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaXNFbGVtZW50UmVhZE9ubHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzSW5saW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc1NlbGVjdGFibGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzVm9pZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUubm9ybWFsaXplTm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUub25DaGFuZ2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLnJlbW92ZU1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmdldERpcnR5UGF0aHMgPT09ICdmdW5jdGlvbicgJiYgKHZhbHVlLm1hcmtzID09PSBudWxsIHx8IGlzUGxhaW5PYmplY3QodmFsdWUubWFya3MpKSAmJiAodmFsdWUuc2VsZWN0aW9uID09PSBudWxsIHx8IFJhbmdlLmlzUmFuZ2UodmFsdWUuc2VsZWN0aW9uKSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKSAmJiBPcGVyYXRpb24uaXNPcGVyYXRpb25MaXN0KHZhbHVlLm9wZXJhdGlvbnMpO1xuICBJU19FRElUT1JfQ0FDSEUuc2V0KHZhbHVlLCBpc0VkaXRvcik7XG4gIHJldHVybiBpc0VkaXRvcjtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBFZGl0b3IgPSB7XG4gIGFib3ZlKGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IuYWJvdmUob3B0aW9ucyk7XG4gIH0sXG4gIGFkZE1hcmsoZWRpdG9yLCBrZXksIHZhbHVlKSB7XG4gICAgZWRpdG9yLmFkZE1hcmsoa2V5LCB2YWx1ZSk7XG4gIH0sXG4gIGFmdGVyKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmFmdGVyKGF0LCBvcHRpb25zKTtcbiAgfSxcbiAgYmVmb3JlKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmJlZm9yZShhdCwgb3B0aW9ucyk7XG4gIH0sXG4gIGRlbGV0ZUJhY2t3YXJkKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgdW5pdCA9ICdjaGFyYWN0ZXInXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgZWRpdG9yLmRlbGV0ZUJhY2t3YXJkKHVuaXQpO1xuICB9LFxuICBkZWxldGVGb3J3YXJkKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgdW5pdCA9ICdjaGFyYWN0ZXInXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgZWRpdG9yLmRlbGV0ZUZvcndhcmQodW5pdCk7XG4gIH0sXG4gIGRlbGV0ZUZyYWdtZW50KGVkaXRvciwgb3B0aW9ucykge1xuICAgIGVkaXRvci5kZWxldGVGcmFnbWVudChvcHRpb25zKTtcbiAgfSxcbiAgZWRnZXMoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuZWRnZXMoYXQpO1xuICB9LFxuICBlbGVtZW50UmVhZE9ubHkoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHJldHVybiBlZGl0b3IuZWxlbWVudFJlYWRPbmx5KG9wdGlvbnMpO1xuICB9LFxuICBlbmQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuZW5kKGF0KTtcbiAgfSxcbiAgZmlyc3QoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuZmlyc3QoYXQpO1xuICB9LFxuICBmcmFnbWVudChlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5mcmFnbWVudChhdCk7XG4gIH0sXG4gIGhhc0Jsb2NrcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmhhc0Jsb2NrcyhlbGVtZW50KTtcbiAgfSxcbiAgaGFzSW5saW5lcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmhhc0lubGluZXMoZWxlbWVudCk7XG4gIH0sXG4gIGhhc1BhdGgoZWRpdG9yLCBwYXRoKSB7XG4gICAgcmV0dXJuIGVkaXRvci5oYXNQYXRoKHBhdGgpO1xuICB9LFxuICBoYXNUZXh0cyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmhhc1RleHRzKGVsZW1lbnQpO1xuICB9LFxuICBpbnNlcnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0QnJlYWsoKTtcbiAgfSxcbiAgaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCwgb3B0aW9ucykge1xuICAgIGVkaXRvci5pbnNlcnRGcmFnbWVudChmcmFnbWVudCwgb3B0aW9ucyk7XG4gIH0sXG4gIGluc2VydE5vZGUoZWRpdG9yLCBub2RlKSB7XG4gICAgZWRpdG9yLmluc2VydE5vZGUobm9kZSk7XG4gIH0sXG4gIGluc2VydFNvZnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0U29mdEJyZWFrKCk7XG4gIH0sXG4gIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgZWRpdG9yLmluc2VydFRleHQodGV4dCk7XG4gIH0sXG4gIGlzQmxvY2soZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBlZGl0b3IuaXNCbG9jayh2YWx1ZSk7XG4gIH0sXG4gIGlzRWRnZShlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHJldHVybiBlZGl0b3IuaXNFZGdlKHBvaW50LCBhdCk7XG4gIH0sXG4gIGlzRWRpdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzRWRpdG9yKHZhbHVlKTtcbiAgfSxcbiAgaXNFbGVtZW50UmVhZE9ubHkoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0VsZW1lbnRSZWFkT25seShlbGVtZW50KTtcbiAgfSxcbiAgaXNFbXB0eShlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmlzRW1wdHkoZWxlbWVudCk7XG4gIH0sXG4gIGlzRW5kKGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0VuZChwb2ludCwgYXQpO1xuICB9LFxuICBpc0lubGluZShlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc0lubGluZSh2YWx1ZSk7XG4gIH0sXG4gIGlzTm9ybWFsaXppbmcoZWRpdG9yKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc05vcm1hbGl6aW5nKCk7XG4gIH0sXG4gIGlzU2VsZWN0YWJsZShlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1NlbGVjdGFibGUodmFsdWUpO1xuICB9LFxuICBpc1N0YXJ0KGVkaXRvciwgcG9pbnQsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1N0YXJ0KHBvaW50LCBhdCk7XG4gIH0sXG4gIGlzVm9pZChlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pc1ZvaWQodmFsdWUpO1xuICB9LFxuICBsYXN0KGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gZWRpdG9yLmxhc3QoYXQpO1xuICB9LFxuICBsZWFmKGVkaXRvciwgYXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLmxlYWYoYXQsIG9wdGlvbnMpO1xuICB9LFxuICBsZXZlbHMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5sZXZlbHMob3B0aW9ucyk7XG4gIH0sXG4gIG1hcmtzKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IuZ2V0TWFya3MoKTtcbiAgfSxcbiAgbmV4dChlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLm5leHQob3B0aW9ucyk7XG4gIH0sXG4gIG5vZGUoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3Iubm9kZShhdCwgb3B0aW9ucyk7XG4gIH0sXG4gIG5vZGVzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3Iubm9kZXMob3B0aW9ucyk7XG4gIH0sXG4gIG5vcm1hbGl6ZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3Iubm9ybWFsaXplKG9wdGlvbnMpO1xuICB9LFxuICBwYXJlbnQoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucGFyZW50KGF0LCBvcHRpb25zKTtcbiAgfSxcbiAgcGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wYXRoKGF0LCBvcHRpb25zKTtcbiAgfSxcbiAgcGF0aFJlZihlZGl0b3IsIHBhdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBhdGhSZWYocGF0aCwgb3B0aW9ucyk7XG4gIH0sXG4gIHBhdGhSZWZzKGVkaXRvcikge1xuICAgIHJldHVybiBlZGl0b3IucGF0aFJlZnMoKTtcbiAgfSxcbiAgcG9pbnQoZWRpdG9yLCBhdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucG9pbnQoYXQsIG9wdGlvbnMpO1xuICB9LFxuICBwb2ludFJlZihlZGl0b3IsIHBvaW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wb2ludFJlZihwb2ludCwgb3B0aW9ucyk7XG4gIH0sXG4gIHBvaW50UmVmcyhlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLnBvaW50UmVmcygpO1xuICB9LFxuICBwb3NpdGlvbnMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5wb3NpdGlvbnMob3B0aW9ucyk7XG4gIH0sXG4gIHByZXZpb3VzKGVkaXRvciwgb3B0aW9ucykge1xuICAgIHJldHVybiBlZGl0b3IucHJldmlvdXMob3B0aW9ucyk7XG4gIH0sXG4gIHJhbmdlKGVkaXRvciwgYXQsIHRvKSB7XG4gICAgcmV0dXJuIGVkaXRvci5yYW5nZShhdCwgdG8pO1xuICB9LFxuICByYW5nZVJlZihlZGl0b3IsIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5yYW5nZVJlZihyYW5nZSwgb3B0aW9ucyk7XG4gIH0sXG4gIHJhbmdlUmVmcyhlZGl0b3IpIHtcbiAgICByZXR1cm4gZWRpdG9yLnJhbmdlUmVmcygpO1xuICB9LFxuICByZW1vdmVNYXJrKGVkaXRvciwga2V5KSB7XG4gICAgZWRpdG9yLnJlbW92ZU1hcmsoa2V5KTtcbiAgfSxcbiAgc2V0Tm9ybWFsaXppbmcoZWRpdG9yLCBpc05vcm1hbGl6aW5nKSB7XG4gICAgZWRpdG9yLnNldE5vcm1hbGl6aW5nKGlzTm9ybWFsaXppbmcpO1xuICB9LFxuICBzdGFydChlZGl0b3IsIGF0KSB7XG4gICAgcmV0dXJuIGVkaXRvci5zdGFydChhdCk7XG4gIH0sXG4gIHN0cmluZyhlZGl0b3IsIGF0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci5zdHJpbmcoYXQsIG9wdGlvbnMpO1xuICB9LFxuICB1bmhhbmdSYW5nZShlZGl0b3IsIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci51bmhhbmdSYW5nZShyYW5nZSwgb3B0aW9ucyk7XG4gIH0sXG4gIHZvaWQoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGVkaXRvci52b2lkKG9wdGlvbnMpO1xuICB9LFxuICB3aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmbikge1xuICAgIGVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZm4pO1xuICB9XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgTG9jYXRpb24gPSB7XG4gIGlzTG9jYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUpIHx8IFBvaW50LmlzUG9pbnQodmFsdWUpIHx8IFJhbmdlLmlzUmFuZ2UodmFsdWUpO1xuICB9XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFNwYW4gPSB7XG4gIGlzU3Bhbih2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIgJiYgdmFsdWUuZXZlcnkoUGF0aC5pc1BhdGgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJGIoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCRiKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkYihPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkYihPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFBvaW50ID0ge1xuICBjb21wYXJlKHBvaW50LCBhbm90aGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFBhdGguY29tcGFyZShwb2ludC5wYXRoLCBhbm90aGVyLnBhdGgpO1xuICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPCBhbm90aGVyLm9mZnNldCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA+IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gMTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBpc0FmdGVyKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAxO1xuICB9LFxuICBpc0JlZm9yZShwb2ludCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQb2ludC5jb21wYXJlKHBvaW50LCBhbm90aGVyKSA9PT0gLTE7XG4gIH0sXG4gIGVxdWFscyhwb2ludCwgYW5vdGhlcikge1xuICAgIC8vIFBFUkY6IGVuc3VyZSB0aGUgb2Zmc2V0cyBhcmUgZXF1YWwgZmlyc3Qgc2luY2UgdGhleSBhcmUgY2hlYXBlciB0byBjaGVjay5cbiAgICByZXR1cm4gcG9pbnQub2Zmc2V0ID09PSBhbm90aGVyLm9mZnNldCAmJiBQYXRoLmVxdWFscyhwb2ludC5wYXRoLCBhbm90aGVyLnBhdGgpO1xuICB9LFxuICBpc1BvaW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIHR5cGVvZiB2YWx1ZS5vZmZzZXQgPT09ICdudW1iZXInICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuICB9LFxuICB0cmFuc2Zvcm0ocG9pbnQsIG9wKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBwcm9kdWNlKHBvaW50LCBwID0+IHtcbiAgICAgIGlmIChwID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHtcbiAgICAgICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gcDtcbiAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpICYmIChvcC5vZmZzZXQgPCBvZmZzZXQgfHwgb3Aub2Zmc2V0ID09PSBvZmZzZXQgJiYgYWZmaW5pdHkgPT09ICdmb3J3YXJkJykpIHtcbiAgICAgICAgICAgICAgcC5vZmZzZXQgKz0gb3AudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICBwLm9mZnNldCArPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSAmJiBvcC5vZmZzZXQgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0IC09IE1hdGgubWluKG9mZnNldCAtIG9wLm9mZnNldCwgb3AudGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IFBhdGguaXNBbmNlc3RvcihvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIGlmIChvcC5wb3NpdGlvbiA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcC5wb3NpdGlvbiA8IG9mZnNldCB8fCBvcC5wb3NpdGlvbiA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgICAgICAgICBwLm9mZnNldCAtPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgX29iamVjdFNwcmVhZCRiKF9vYmplY3RTcHJlYWQkYih7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgICAgICBhZmZpbml0eTogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBfc2NydWJiZXIgPSB1bmRlZmluZWQ7XG4vKipcbiAqIFRoaXMgaW50ZXJmYWNlIGltcGxlbWVudHMgYSBzdHJpbmdpZnkoKSBmdW5jdGlvbiwgd2hpY2ggaXMgdXNlZCBieSBTbGF0ZVxuICogaW50ZXJuYWxseSB3aGVuIGdlbmVyYXRpbmcgZXhjZXB0aW9ucyBjb250YWluaW5nIGVuZCB1c2VyIGRhdGEuIERldmVsb3BlcnNcbiAqIHVzaW5nIFNsYXRlIG1heSBjYWxsIFNjcnViYmVyLnNldFNjcnViYmVyKCkgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHRoaXNcbiAqIHN0cmluZ2lmeSgpIGZ1bmN0aW9uLlxuICpcbiAqIEZvciBleGFtcGxlLCB0byBwcmV2ZW50IHRoZSBjbGVhcnRleHQgbG9nZ2luZyBvZiAndGV4dCcgZmllbGRzIHdpdGhpbiBOb2RlczpcbiAqXG4gKiAgICBpbXBvcnQgeyBTY3J1YmJlciB9IGZyb20gJ3NsYXRlJztcbiAqICAgIFNjcnViYmVyLnNldFNjcnViYmVyKChrZXksIHZhbCkgPT4ge1xuICogICAgICBpZiAoa2V5ID09PSAndGV4dCcpIHJldHVybiAnLi4uc2NydWJiZWQuLi4nXG4gKiAgICAgIHJldHVybiB2YWxcbiAqICAgIH0pO1xuICpcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxudmFyIFNjcnViYmVyID0ge1xuICBzZXRTY3J1YmJlcihzY3J1YmJlcikge1xuICAgIF9zY3J1YmJlciA9IHNjcnViYmVyO1xuICB9LFxuICBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIF9zY3J1YmJlcik7XG4gIH1cbn07XG5cbnZhciBfZXhjbHVkZWQkMiA9IFtcInRleHRcIl0sXG4gIF9leGNsdWRlZDIkMiA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xuZnVuY3Rpb24gb3duS2V5cyRhKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkYShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGEoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGEoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBUZXh0ID0ge1xuICBlcXVhbHModGV4dCwgYW5vdGhlcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgbG9vc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGZ1bmN0aW9uIG9taXRUZXh0KG9iaikge1xuICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBfZXhjbHVkZWQkMik7XG4gICAgICByZXR1cm4gcmVzdDtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVlcEVxdWFsKGxvb3NlID8gb21pdFRleHQodGV4dCkgOiB0ZXh0LCBsb29zZSA/IG9taXRUZXh0KGFub3RoZXIpIDogYW5vdGhlcik7XG4gIH0sXG4gIGlzVGV4dCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzVGV4dExpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkodmFsID0+IFRleHQuaXNUZXh0KHZhbCkpO1xuICB9LFxuICBpc1RleHRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50ZXh0ICE9PSB1bmRlZmluZWQ7XG4gIH0sXG4gIG1hdGNoZXModGV4dCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICd0ZXh0Jykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8IHRleHRba2V5XSAhPT0gcHJvcHNba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkZWNvcmF0aW9ucyhub2RlLCBkZWNvcmF0aW9ucykge1xuICAgIHZhciBsZWF2ZXMgPSBbX29iamVjdFNwcmVhZCRhKHt9LCBub2RlKV07XG4gICAgZm9yICh2YXIgZGVjIG9mIGRlY29yYXRpb25zKSB7XG4gICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhkZWMsIF9leGNsdWRlZDIkMik7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoZGVjKTtcbiAgICAgIHZhciBuZXh0ID0gW107XG4gICAgICB2YXIgbGVhZkVuZCA9IDA7XG4gICAgICB2YXIgZGVjb3JhdGlvblN0YXJ0ID0gc3RhcnQub2Zmc2V0O1xuICAgICAgdmFyIGRlY29yYXRpb25FbmQgPSBlbmQub2Zmc2V0O1xuICAgICAgZm9yICh2YXIgbGVhZiBvZiBsZWF2ZXMpIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBsZW5ndGhcbiAgICAgICAgfSA9IGxlYWYudGV4dDtcbiAgICAgICAgdmFyIGxlYWZTdGFydCA9IGxlYWZFbmQ7XG4gICAgICAgIGxlYWZFbmQgKz0gbGVuZ3RoO1xuICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgZW5jb21wYXNzZXMgdGhlIGVudGlyZSBsZWFmLCBhZGQgdGhlIHJhbmdlLlxuICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0IDw9IGxlYWZTdGFydCAmJiBsZWFmRW5kIDw9IGRlY29yYXRpb25FbmQpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGxlYWYsIHJlc3QpO1xuICAgICAgICAgIG5leHQucHVzaChsZWFmKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgZXhwYW5kZWQgYW5kIG1hdGNoIHRoZSBsZWFmLCBvciBzdGFydHMgYWZ0ZXIsIG9yIGVuZHMgYmVmb3JlIGl0LCBjb250aW51ZS5cbiAgICAgICAgaWYgKGRlY29yYXRpb25TdGFydCAhPT0gZGVjb3JhdGlvbkVuZCAmJiAoZGVjb3JhdGlvblN0YXJ0ID09PSBsZWFmRW5kIHx8IGRlY29yYXRpb25FbmQgPT09IGxlYWZTdGFydCkgfHwgZGVjb3JhdGlvblN0YXJ0ID4gbGVhZkVuZCB8fCBkZWNvcmF0aW9uRW5kIDwgbGVhZlN0YXJ0IHx8IGRlY29yYXRpb25FbmQgPT09IGxlYWZTdGFydCAmJiBsZWFmU3RhcnQgIT09IDApIHtcbiAgICAgICAgICBuZXh0LnB1c2gobGVhZik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gc3BsaXQgdGhlIGxlYWYsIGF0IHRoZSBzdGFydCwgZW5kLCBvciBib3RoLFxuICAgICAgICAvLyBhbmQgYWRkIHRoZSByYW5nZSB0byB0aGUgbWlkZGxlIGludGVyc2VjdGluZyBzZWN0aW9uLiBEbyB0aGUgZW5kXG4gICAgICAgIC8vIHNwbGl0IGZpcnN0IHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIHRoZSBvZmZzZXQgdGhhdCB3YXkuXG4gICAgICAgIHZhciBtaWRkbGUgPSBsZWFmO1xuICAgICAgICB2YXIgYmVmb3JlID0gdm9pZCAwO1xuICAgICAgICB2YXIgYWZ0ZXIgPSB2b2lkIDA7XG4gICAgICAgIGlmIChkZWNvcmF0aW9uRW5kIDwgbGVhZkVuZCkge1xuICAgICAgICAgIHZhciBvZmYgPSBkZWNvcmF0aW9uRW5kIC0gbGVhZlN0YXJ0O1xuICAgICAgICAgIGFmdGVyID0gX29iamVjdFNwcmVhZCRhKF9vYmplY3RTcHJlYWQkYSh7fSwgbWlkZGxlKSwge30sIHtcbiAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKG9mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtaWRkbGUgPSBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoMCwgb2ZmKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWNvcmF0aW9uU3RhcnQgPiBsZWFmU3RhcnQpIHtcbiAgICAgICAgICB2YXIgX29mZiA9IGRlY29yYXRpb25TdGFydCAtIGxlYWZTdGFydDtcbiAgICAgICAgICBiZWZvcmUgPSBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoMCwgX29mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtaWRkbGUgPSBfb2JqZWN0U3ByZWFkJGEoX29iamVjdFNwcmVhZCRhKHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoX29mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKG1pZGRsZSwgcmVzdCk7XG4gICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICBuZXh0LnB1c2goYmVmb3JlKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0LnB1c2gobWlkZGxlKTtcbiAgICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGVhdmVzID0gbmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGxlYXZlcztcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgbG9jYXRpb24gdG8gaW5zZXJ0IGNvbnRlbnQgaW50byB0aGUgZWRpdG9yLlxuICogQnkgZGVmYXVsdCwgdXNlIHRoZSBzZWxlY3Rpb24gYXMgdGhlIHRhcmdldCBsb2NhdGlvbi4gQnV0IGlmIHRoZXJlIGlzXG4gKiBubyBzZWxlY3Rpb24sIGluc2VydCBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudCBzaW5jZSB0aGF0IGlzIHN1Y2ggYVxuICogY29tbW9uIHVzZSBjYXNlIHdoZW4gaW5zZXJ0aW5nIGZyb20gYSBub24tc2VsZWN0ZWQgc3RhdGUuXG4gKi9cbnZhciBnZXREZWZhdWx0SW5zZXJ0TG9jYXRpb24gPSBlZGl0b3IgPT4ge1xuICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgIHJldHVybiBlZGl0b3Iuc2VsZWN0aW9uO1xuICB9IGVsc2UgaWYgKGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFswXTtcbiAgfVxufTtcblxudmFyIG1hdGNoUGF0aCA9IChlZGl0b3IsIHBhdGgpID0+IHtcbiAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gIHJldHVybiBuID0+IG4gPT09IG5vZGU7XG59O1xuXG4vLyBDaGFyYWN0ZXIgKGdyYXBoZW1lIGNsdXN0ZXIpIGJvdW5kYXJpZXMgYXJlIGRldGVybWluZWQgYWNjb3JkaW5nIHRvXG4vLyB0aGUgZGVmYXVsdCBncmFwaGVtZSBjbHVzdGVyIGJvdW5kYXJ5IHNwZWNpZmljYXRpb24sIGV4dGVuZGVkIGdyYXBoZW1lIGNsdXN0ZXJzIHZhcmlhbnRbMV0uXG4vL1xuLy8gUmVmZXJlbmNlczpcbi8vXG4vLyBbMV0gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjI5LyNEZWZhdWx0X0dyYXBoZW1lX0NsdXN0ZXJfVGFibGVcbi8vIFsyXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtQcm9wZXJ0eS50eHRcbi8vIFszXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtUZXN0Lmh0bWxcbi8vIFs0XSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtUZXN0LnR4dFxuLyoqXG4gKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBhIHN0cmluZyBvZiB0ZXh0LlxuICovXG52YXIgZ2V0Q2hhcmFjdGVyRGlzdGFuY2UgPSBmdW5jdGlvbiBnZXRDaGFyYWN0ZXJEaXN0YW5jZShzdHIpIHtcbiAgdmFyIGlzUlRMID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIGlzTFRSID0gIWlzUlRMO1xuICB2YXIgY29kZXBvaW50cyA9IGlzUlRMID8gY29kZXBvaW50c0l0ZXJhdG9yUlRMKHN0cikgOiBzdHI7XG4gIHZhciBsZWZ0ID0gQ29kZXBvaW50VHlwZS5Ob25lO1xuICB2YXIgcmlnaHQgPSBDb2RlcG9pbnRUeXBlLk5vbmU7XG4gIHZhciBkaXN0YW5jZSA9IDA7XG4gIC8vIEV2YWx1YXRpb24gb2YgdGhlc2UgY29uZGl0aW9ucyBhcmUgZGVmZXJyZWQuXG4gIHZhciBnYjExID0gbnVsbDsgLy8gSXMgR0IxMSBhcHBsaWNhYmxlP1xuICB2YXIgZ2IxMk9yMTMgPSBudWxsOyAvLyBJcyBHQjEyIG9yIEdCMTMgYXBwbGljYWJsZT9cbiAgZm9yICh2YXIgY2hhciBvZiBjb2RlcG9pbnRzKSB7XG4gICAgdmFyIGNvZGUgPSBjaGFyLmNvZGVQb2ludEF0KDApO1xuICAgIGlmICghY29kZSkgYnJlYWs7XG4gICAgdmFyIHR5cGUgPSBnZXRDb2RlcG9pbnRUeXBlKGNoYXIsIGNvZGUpO1xuICAgIFtsZWZ0LCByaWdodF0gPSBpc0xUUiA/IFtyaWdodCwgdHlwZV0gOiBbdHlwZSwgbGVmdF07XG4gICAgaWYgKGludGVyc2VjdHMobGVmdCwgQ29kZXBvaW50VHlwZS5aV0opICYmIGludGVyc2VjdHMocmlnaHQsIENvZGVwb2ludFR5cGUuRXh0UGljdCkpIHtcbiAgICAgIGlmIChpc0xUUikge1xuICAgICAgICBnYjExID0gZW5kc1dpdGhFbW9qaVpXSihzdHIuc3Vic3RyaW5nKDAsIGRpc3RhbmNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnYjExID0gZW5kc1dpdGhFbW9qaVpXSihzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgICAgfVxuICAgICAgaWYgKCFnYjExKSBicmVhaztcbiAgICB9XG4gICAgaWYgKGludGVyc2VjdHMobGVmdCwgQ29kZXBvaW50VHlwZS5SSSkgJiYgaW50ZXJzZWN0cyhyaWdodCwgQ29kZXBvaW50VHlwZS5SSSkpIHtcbiAgICAgIGlmIChnYjEyT3IxMyAhPT0gbnVsbCkge1xuICAgICAgICBnYjEyT3IxMyA9ICFnYjEyT3IxMztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0xUUikge1xuICAgICAgICAgIGdiMTJPcjEzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnYjEyT3IxMyA9IGVuZHNXaXRoT2RkTnVtYmVyT2ZSSXMoc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gZGlzdGFuY2UpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFnYjEyT3IxMykgYnJlYWs7XG4gICAgfVxuICAgIGlmIChsZWZ0ICE9PSBDb2RlcG9pbnRUeXBlLk5vbmUgJiYgcmlnaHQgIT09IENvZGVwb2ludFR5cGUuTm9uZSAmJiBpc0JvdW5kYXJ5UGFpcihsZWZ0LCByaWdodCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkaXN0YW5jZSArPSBjaGFyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gZGlzdGFuY2UgfHwgMTtcbn07XG52YXIgU1BBQ0UgPSAvXFxzLztcbnZhciBQVU5DVFVBVElPTiA9IC9bXFx1MDAyMS1cXHUwMDIzXFx1MDAyNS1cXHUwMDJBXFx1MDAyQy1cXHUwMDJGXFx1MDAzQVxcdTAwM0JcXHUwMDNGXFx1MDA0MFxcdTAwNUItXFx1MDA1RFxcdTAwNUZcXHUwMDdCXFx1MDA3RFxcdTAwQTFcXHUwMEE3XFx1MDBBQlxcdTAwQjZcXHUwMEI3XFx1MDBCQlxcdTAwQkZcXHUwMzdFXFx1MDM4N1xcdTA1NUEtXFx1MDU1RlxcdTA1ODlcXHUwNThBXFx1MDVCRVxcdTA1QzBcXHUwNUMzXFx1MDVDNlxcdTA1RjNcXHUwNUY0XFx1MDYwOVxcdTA2MEFcXHUwNjBDXFx1MDYwRFxcdTA2MUJcXHUwNjFFXFx1MDYxRlxcdTA2NkEtXFx1MDY2RFxcdTA2RDRcXHUwNzAwLVxcdTA3MERcXHUwN0Y3LVxcdTA3RjlcXHUwODMwLVxcdTA4M0VcXHUwODVFXFx1MDk2NFxcdTA5NjVcXHUwOTcwXFx1MEFGMFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYzQS1cXHUwRjNEXFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE0MDBcXHUxNjZEXFx1MTY2RVxcdTE2OUJcXHUxNjlDXFx1MTZFQi1cXHUxNkVEXFx1MTczNVxcdTE3MzZcXHUxN0Q0LVxcdTE3RDZcXHUxN0Q4LVxcdTE3REFcXHUxODAwLVxcdTE4MEFcXHUxOTQ0XFx1MTk0NVxcdTFBMUVcXHUxQTFGXFx1MUFBMC1cXHUxQUE2XFx1MUFBOC1cXHUxQUFEXFx1MUI1QS1cXHUxQjYwXFx1MUJGQy1cXHUxQkZGXFx1MUMzQi1cXHUxQzNGXFx1MUM3RVxcdTFDN0ZcXHUxQ0MwLVxcdTFDQzdcXHUxQ0QzXFx1MjAxMC1cXHUyMDI3XFx1MjAzMC1cXHUyMDQzXFx1MjA0NS1cXHUyMDUxXFx1MjA1My1cXHUyMDVFXFx1MjA3RFxcdTIwN0VcXHUyMDhEXFx1MjA4RVxcdTIzMjlcXHUyMzJBXFx1Mjc2OC1cXHUyNzc1XFx1MjdDNVxcdTI3QzZcXHUyN0U2LVxcdTI3RUZcXHUyOTgzLVxcdTI5OThcXHUyOUQ4LVxcdTI5REJcXHUyOUZDXFx1MjlGRFxcdTJDRjktXFx1MkNGQ1xcdTJDRkVcXHUyQ0ZGXFx1MkQ3MFxcdTJFMDAtXFx1MkUyRVxcdTJFMzAtXFx1MkUzQlxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV0vO1xudmFyIENIQU1FTEVPTiA9IC9bJ1xcdTIwMThcXHUyMDE5XS87XG4vKipcbiAqIEdldCB0aGUgZGlzdGFuY2UgdG8gdGhlIGVuZCBvZiB0aGUgZmlyc3Qgd29yZCBpbiBhIHN0cmluZyBvZiB0ZXh0LlxuICovXG52YXIgZ2V0V29yZERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0V29yZERpc3RhbmNlKHRleHQpIHtcbiAgdmFyIGlzUlRMID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIGRpc3QgPSAwO1xuICB2YXIgc3RhcnRlZCA9IGZhbHNlO1xuICB3aGlsZSAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGNoYXJEaXN0ID0gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgaXNSVEwpO1xuICAgIHZhciBbY2hhciwgcmVtYWluaW5nXSA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCBjaGFyRGlzdCwgaXNSVEwpO1xuICAgIGlmIChpc1dvcmRDaGFyYWN0ZXIoY2hhciwgcmVtYWluaW5nLCBpc1JUTCkpIHtcbiAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgZGlzdCArPSBjaGFyRGlzdDtcbiAgICB9IGVsc2UgaWYgKCFzdGFydGVkKSB7XG4gICAgICBkaXN0ICs9IGNoYXJEaXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGV4dCA9IHJlbWFpbmluZztcbiAgfVxuICByZXR1cm4gZGlzdDtcbn07XG4vKipcbiAqIFNwbGl0IGEgc3RyaW5nIGluIHR3byBwYXJ0cyBhdCBhIGdpdmVuIGRpc3RhbmNlIHN0YXJ0aW5nIGZyb20gdGhlIGVuZCB3aGVuXG4gKiBgaXNSVExgIGlzIHNldCB0byBgdHJ1ZWAuXG4gKi9cbnZhciBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UgPSAoc3RyLCBkaXN0LCBpc1JUTCkgPT4ge1xuICBpZiAoaXNSVEwpIHtcbiAgICB2YXIgYXQgPSBzdHIubGVuZ3RoIC0gZGlzdDtcbiAgICByZXR1cm4gW3N0ci5zbGljZShhdCwgc3RyLmxlbmd0aCksIHN0ci5zbGljZSgwLCBhdCldO1xuICB9XG4gIHJldHVybiBbc3RyLnNsaWNlKDAsIGRpc3QpLCBzdHIuc2xpY2UoZGlzdCldO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgYSBjaGFyYWN0ZXIgaXMgYSB3b3JkIGNoYXJhY3Rlci4gVGhlIGByZW1haW5pbmdgIGFyZ3VtZW50IGlzIHVzZWRcbiAqIGJlY2F1c2Ugc29tZXRpbWVzIHlvdSBtdXN0IHJlYWQgc3Vic2VxdWVudCBjaGFyYWN0ZXJzIHRvIHRydWx5IGRldGVybWluZSBpdC5cbiAqL1xudmFyIGlzV29yZENoYXJhY3RlciA9IGZ1bmN0aW9uIGlzV29yZENoYXJhY3RlcihjaGFyLCByZW1haW5pbmcpIHtcbiAgdmFyIGlzUlRMID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgaWYgKFNQQUNFLnRlc3QoY2hhcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQ2hhbWVsZW9ucyBjb3VudCBhcyB3b3JkIGNoYXJhY3RlcnMgYXMgbG9uZyBhcyB0aGV5J3JlIGluIGEgd29yZCwgc29cbiAgLy8gcmVjdXJzZSB0byBzZWUgaWYgdGhlIG5leHQgb25lIGlzIGEgd29yZCBjaGFyYWN0ZXIgb3Igbm90LlxuICBpZiAoQ0hBTUVMRU9OLnRlc3QoY2hhcikpIHtcbiAgICB2YXIgY2hhckRpc3QgPSBnZXRDaGFyYWN0ZXJEaXN0YW5jZShyZW1haW5pbmcsIGlzUlRMKTtcbiAgICB2YXIgW25leHRDaGFyLCBuZXh0UmVtYWluaW5nXSA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZShyZW1haW5pbmcsIGNoYXJEaXN0LCBpc1JUTCk7XG4gICAgaWYgKGlzV29yZENoYXJhY3RlcihuZXh0Q2hhciwgbmV4dFJlbWFpbmluZywgaXNSVEwpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKFBVTkNUVUFUSU9OLnRlc3QoY2hhcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBJdGVyYXRlIG9uIGNvZGVwb2ludHMgZnJvbSByaWdodCB0byBsZWZ0LlxuICovXG52YXIgY29kZXBvaW50c0l0ZXJhdG9yUlRMID0gZnVuY3Rpb24qIGNvZGVwb2ludHNJdGVyYXRvclJUTChzdHIpIHtcbiAgdmFyIGVuZCA9IHN0ci5sZW5ndGggLSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGFyMSA9IHN0ci5jaGFyQXQoZW5kIC0gaSk7XG4gICAgaWYgKGlzTG93U3Vycm9nYXRlKGNoYXIxLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICB2YXIgY2hhcjIgPSBzdHIuY2hhckF0KGVuZCAtIGkgLSAxKTtcbiAgICAgIGlmIChpc0hpZ2hTdXJyb2dhdGUoY2hhcjIuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgeWllbGQgY2hhcjIgKyBjaGFyMTtcbiAgICAgICAgaSsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgeWllbGQgY2hhcjE7XG4gIH1cbn07XG4vKipcbiAqIElzIGBjaGFyQ29kZWAgYSBoaWdoIHN1cnJvZ2F0ZS5cbiAqXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbml2ZXJzYWxfQ2hhcmFjdGVyX1NldF9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcbiAqL1xudmFyIGlzSGlnaFN1cnJvZ2F0ZSA9IGNoYXJDb2RlID0+IHtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDB4ZDgwMCAmJiBjaGFyQ29kZSA8PSAweGRiZmY7XG59O1xuLyoqXG4gKiBJcyBgY2hhckNvZGVgIGEgbG93IHN1cnJvZ2F0ZS5cbiAqXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbml2ZXJzYWxfQ2hhcmFjdGVyX1NldF9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcbiAqL1xudmFyIGlzTG93U3Vycm9nYXRlID0gY2hhckNvZGUgPT4ge1xuICByZXR1cm4gY2hhckNvZGUgPj0gMHhkYzAwICYmIGNoYXJDb2RlIDw9IDB4ZGZmZjtcbn07XG52YXIgQ29kZXBvaW50VHlwZTtcbihmdW5jdGlvbiAoQ29kZXBvaW50VHlwZSkge1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiRXh0ZW5kXCJdID0gMV0gPSBcIkV4dGVuZFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJaV0pcIl0gPSAyXSA9IFwiWldKXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlJJXCJdID0gNF0gPSBcIlJJXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlByZXBlbmRcIl0gPSA4XSA9IFwiUHJlcGVuZFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJTcGFjaW5nTWFya1wiXSA9IDE2XSA9IFwiU3BhY2luZ01hcmtcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFwiXSA9IDMyXSA9IFwiTFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJWXCJdID0gNjRdID0gXCJWXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlRcIl0gPSAxMjhdID0gXCJUXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxWXCJdID0gMjU2XSA9IFwiTFZcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFZUXCJdID0gNTEyXSA9IFwiTFZUXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkV4dFBpY3RcIl0gPSAxMDI0XSA9IFwiRXh0UGljdFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJBbnlcIl0gPSAyMDQ4XSA9IFwiQW55XCI7XG59KShDb2RlcG9pbnRUeXBlIHx8IChDb2RlcG9pbnRUeXBlID0ge30pKTtcbnZhciByZUV4dGVuZCA9IC9eKD86W1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA2MTAtXFx1MDYxQVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRFxcdTA3MTFcXHUwNzMwLVxcdTA3NEFcXHUwN0E2LVxcdTA3QjBcXHUwN0VCLVxcdTA3RjNcXHUwN0ZEXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJEXFx1MDg1OS1cXHUwODVCXFx1MDg5OC1cXHUwODlGXFx1MDhDQS1cXHUwOEUxXFx1MDhFMy1cXHUwOTAyXFx1MDkzQVxcdTA5M0NcXHUwOTQxLVxcdTA5NDhcXHUwOTREXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDlCQ1xcdTA5QkVcXHUwOUMxLVxcdTA5QzRcXHUwOUNEXFx1MDlEN1xcdTA5RTJcXHUwOUUzXFx1MDlGRVxcdTBBMDFcXHUwQTAyXFx1MEEzQ1xcdTBBNDFcXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE3MFxcdTBBNzFcXHUwQTc1XFx1MEE4MVxcdTBBODJcXHUwQUJDXFx1MEFDMS1cXHUwQUM1XFx1MEFDN1xcdTBBQzhcXHUwQUNEXFx1MEFFMlxcdTBBRTNcXHUwQUZBLVxcdTBBRkZcXHUwQjAxXFx1MEIzQ1xcdTBCM0VcXHUwQjNGXFx1MEI0MS1cXHUwQjQ0XFx1MEI0RFxcdTBCNTUtXFx1MEI1N1xcdTBCNjJcXHUwQjYzXFx1MEI4MlxcdTBCQkVcXHUwQkMwXFx1MEJDRFxcdTBCRDdcXHUwQzAwXFx1MEMwNFxcdTBDM0NcXHUwQzNFLVxcdTBDNDBcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MVxcdTBDQkNcXHUwQ0JGXFx1MENDMlxcdTBDQzZcXHUwQ0NDXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENFMlxcdTBDRTNcXHUwRDAwXFx1MEQwMVxcdTBEM0JcXHUwRDNDXFx1MEQzRVxcdTBENDEtXFx1MEQ0NFxcdTBENERcXHUwRDU3XFx1MEQ2MlxcdTBENjNcXHUwRDgxXFx1MERDQVxcdTBEQ0ZcXHUwREQyLVxcdTBERDRcXHUwREQ2XFx1MERERlxcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUJDXFx1MEVDOC1cXHUwRUNFXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjcxLVxcdTBGN0VcXHUwRjgwLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJELVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzQVxcdTEwM0RcXHUxMDNFXFx1MTA1OFxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhEXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzJcXHUxNzMzXFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3QjRcXHUxN0I1XFx1MTdCNy1cXHUxN0JEXFx1MTdDNlxcdTE3QzktXFx1MTdEM1xcdTE3RERcXHUxODBCLVxcdTE4MERcXHUxODBGXFx1MTg4NVxcdTE4ODZcXHUxOEE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNCXFx1MUExN1xcdTFBMThcXHUxQTFCXFx1MUE1NlxcdTFBNTgtXFx1MUE1RVxcdTFBNjBcXHUxQTYyXFx1MUE2NS1cXHUxQTZDXFx1MUE3My1cXHUxQTdDXFx1MUE3RlxcdTFBQjAtXFx1MUFDRVxcdTFCMDAtXFx1MUIwM1xcdTFCMzQtXFx1MUIzQVxcdTFCM0NcXHUxQjQyXFx1MUI2Qi1cXHUxQjczXFx1MUI4MFxcdTFCODFcXHUxQkEyLVxcdTFCQTVcXHUxQkE4XFx1MUJBOVxcdTFCQUItXFx1MUJBRFxcdTFCRTZcXHUxQkU4XFx1MUJFOVxcdTFCRURcXHUxQkVGLVxcdTFCRjFcXHUxQzJDLVxcdTFDMzNcXHUxQzM2XFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFMFxcdTFDRTItXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERkZcXHUyMDBDXFx1MjBEMC1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRlxcdTMwOTlcXHUzMDlBXFx1QTY2Ri1cXHVBNjcyXFx1QTY3NC1cXHVBNjdEXFx1QTY5RVxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjVcXHVBODI2XFx1QTgyQ1xcdUE4QzRcXHVBOEM1XFx1QThFMC1cXHVBOEYxXFx1QThGRlxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1MVxcdUE5ODAtXFx1QTk4MlxcdUE5QjNcXHVBOUI2LVxcdUE5QjlcXHVBOUJDXFx1QTlCRFxcdUE5RTVcXHVBQTI5LVxcdUFBMkVcXHVBQTMxXFx1QUEzMlxcdUFBMzVcXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTdDXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQ1xcdUFBRURcXHVBQUY2XFx1QUJFNVxcdUFCRThcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZGOUVcXHVGRjlGXXxcXHVEODAwW1xcdURERkRcXHVERUUwXFx1REY3Ni1cXHVERjdBXXxcXHVEODAyW1xcdURFMDEtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTBGXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFRTVcXHVERUU2XXxcXHVEODAzW1xcdUREMjQtXFx1REQyN1xcdURFQUJcXHVERUFDXFx1REVGRC1cXHVERUZGXFx1REY0Ni1cXHVERjUwXFx1REY4Mi1cXHVERjg1XXxcXHVEODA0W1xcdURDMDFcXHVEQzM4LVxcdURDNDZcXHVEQzcwXFx1REM3M1xcdURDNzRcXHVEQzdGLVxcdURDODFcXHVEQ0IzLVxcdURDQjZcXHVEQ0I5XFx1RENCQVxcdURDQzJcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMkJcXHVERDJELVxcdUREMzRcXHVERDczXFx1REQ4MFxcdUREODFcXHVEREI2LVxcdUREQkVcXHVEREM5LVxcdUREQ0NcXHVERENGXFx1REUyRi1cXHVERTMxXFx1REUzNFxcdURFMzZcXHVERTM3XFx1REUzRVxcdURFNDFcXHVERURGXFx1REVFMy1cXHVERUVBXFx1REYwMFxcdURGMDFcXHVERjNCXFx1REYzQ1xcdURGM0VcXHVERjQwXFx1REY1N1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzM4LVxcdURDM0ZcXHVEQzQyLVxcdURDNDRcXHVEQzQ2XFx1REM1RVxcdURDQjBcXHVEQ0IzLVxcdURDQjhcXHVEQ0JBXFx1RENCRFxcdURDQkZcXHVEQ0MwXFx1RENDMlxcdURDQzNcXHVEREFGXFx1RERCMi1cXHVEREI1XFx1RERCQ1xcdUREQkRcXHVEREJGXFx1RERDMFxcdURERENcXHVEREREXFx1REUzMy1cXHVERTNBXFx1REUzRFxcdURFM0ZcXHVERTQwXFx1REVBQlxcdURFQURcXHVERUIwLVxcdURFQjVcXHVERUI3XFx1REYxRC1cXHVERjFGXFx1REYyMi1cXHVERjI1XFx1REYyNy1cXHVERjJCXXxcXHVEODA2W1xcdURDMkYtXFx1REMzN1xcdURDMzlcXHVEQzNBXFx1REQzMFxcdUREM0JcXHVERDNDXFx1REQzRVxcdURENDNcXHVEREQ0LVxcdURERDdcXHVERERBXFx1REREQlxcdURERTBcXHVERTAxLVxcdURFMEFcXHVERTMzLVxcdURFMzhcXHVERTNCLVxcdURFM0VcXHVERTQ3XFx1REU1MS1cXHVERTU2XFx1REU1OS1cXHVERTVCXFx1REU4QS1cXHVERTk2XFx1REU5OFxcdURFOTldfFxcdUQ4MDdbXFx1REMzMC1cXHVEQzM2XFx1REMzOC1cXHVEQzNEXFx1REMzRlxcdURDOTItXFx1RENBN1xcdURDQUEtXFx1RENCMFxcdURDQjJcXHVEQ0IzXFx1RENCNVxcdURDQjZcXHVERDMxLVxcdUREMzZcXHVERDNBXFx1REQzQ1xcdUREM0RcXHVERDNGLVxcdURENDVcXHVERDQ3XFx1REQ5MFxcdUREOTFcXHVERDk1XFx1REQ5N1xcdURFRjNcXHVERUY0XFx1REYwMFxcdURGMDFcXHVERjM2LVxcdURGM0FcXHVERjQwXFx1REY0Ml18XFx1RDgwRFtcXHVEQzQwXFx1REM0Ny1cXHVEQzU1XXxcXHVEODFBW1xcdURFRjAtXFx1REVGNFxcdURGMzAtXFx1REYzNl18XFx1RDgxQltcXHVERjRGXFx1REY4Ri1cXHVERjkyXFx1REZFNF18XFx1RDgyRltcXHVEQzlEXFx1REM5RV18XFx1RDgzM1tcXHVERjAwLVxcdURGMkRcXHVERjMwLVxcdURGNDZdfFxcdUQ4MzRbXFx1REQ2NVxcdURENjctXFx1REQ2OVxcdURENkUtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzOFtcXHVEQzAwLVxcdURDMDZcXHVEQzA4LVxcdURDMThcXHVEQzFCLVxcdURDMjFcXHVEQzIzXFx1REMyNFxcdURDMjYtXFx1REMyQVxcdURDOEZcXHVERDMwLVxcdUREMzZcXHVERUFFXFx1REVFQy1cXHVERUVGXXxcXHVEODM5W1xcdURDRUMtXFx1RENFRl18XFx1RDgzQVtcXHVEQ0QwLVxcdURDRDZcXHVERDQ0LVxcdURENEFdfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEQjQwW1xcdURDMjAtXFx1REM3RlxcdUREMDAtXFx1RERFRl0pJC87XG52YXIgcmVQcmVwZW5kID0gL14oPzpbXFx1MDYwMC1cXHUwNjA1XFx1MDZERFxcdTA3MEZcXHUwODkwXFx1MDg5MVxcdTA4RTJcXHUwRDRFXXxcXHVEODA0W1xcdURDQkRcXHVEQ0NEXFx1RERDMlxcdUREQzNdfFxcdUQ4MDZbXFx1REQzRlxcdURENDFcXHVERTNBXFx1REU4NC1cXHVERTg5XXxcXHVEODA3XFx1REQ0NikkLztcbnZhciByZVNwYWNpbmdNYXJrID0gL14oPzpbXFx1MDkwM1xcdTA5M0JcXHUwOTNFLVxcdTA5NDBcXHUwOTQ5LVxcdTA5NENcXHUwOTRFXFx1MDk0RlxcdTA5ODJcXHUwOTgzXFx1MDlCRlxcdTA5QzBcXHUwOUM3XFx1MDlDOFxcdTA5Q0JcXHUwOUNDXFx1MEEwM1xcdTBBM0UtXFx1MEE0MFxcdTBBODNcXHUwQUJFLVxcdTBBQzBcXHUwQUM5XFx1MEFDQlxcdTBBQ0NcXHUwQjAyXFx1MEIwM1xcdTBCNDBcXHUwQjQ3XFx1MEI0OFxcdTBCNEJcXHUwQjRDXFx1MEJCRlxcdTBCQzFcXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNDXFx1MEMwMS1cXHUwQzAzXFx1MEM0MS1cXHUwQzQ0XFx1MEM4MlxcdTBDODNcXHUwQ0JFXFx1MENDMFxcdTBDQzFcXHUwQ0MzXFx1MENDNFxcdTBDQzdcXHUwQ0M4XFx1MENDQVxcdTBDQ0JcXHUwRDAyXFx1MEQwM1xcdTBEM0ZcXHUwRDQwXFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRDXFx1MEQ4MlxcdTBEODNcXHUwREQwXFx1MEREMVxcdTBERDgtXFx1MERERVxcdTBERjJcXHUwREYzXFx1MEUzM1xcdTBFQjNcXHUwRjNFXFx1MEYzRlxcdTBGN0ZcXHUxMDMxXFx1MTAzQlxcdTEwM0NcXHUxMDU2XFx1MTA1N1xcdTEwODRcXHUxNzE1XFx1MTczNFxcdTE3QjZcXHUxN0JFLVxcdTE3QzVcXHUxN0M3XFx1MTdDOFxcdTE5MjMtXFx1MTkyNlxcdTE5MjktXFx1MTkyQlxcdTE5MzBcXHUxOTMxXFx1MTkzMy1cXHUxOTM4XFx1MUExOVxcdTFBMUFcXHUxQTU1XFx1MUE1N1xcdTFBNkQtXFx1MUE3MlxcdTFCMDRcXHUxQjNCXFx1MUIzRC1cXHUxQjQxXFx1MUI0M1xcdTFCNDRcXHUxQjgyXFx1MUJBMVxcdTFCQTZcXHUxQkE3XFx1MUJBQVxcdTFCRTdcXHUxQkVBLVxcdTFCRUNcXHUxQkVFXFx1MUJGMlxcdTFCRjNcXHUxQzI0LVxcdTFDMkJcXHUxQzM0XFx1MUMzNVxcdTFDRTFcXHUxQ0Y3XFx1QTgyM1xcdUE4MjRcXHVBODI3XFx1QTg4MFxcdUE4ODFcXHVBOEI0LVxcdUE4QzNcXHVBOTUyXFx1QTk1M1xcdUE5ODNcXHVBOUI0XFx1QTlCNVxcdUE5QkFcXHVBOUJCXFx1QTlCRS1cXHVBOUMwXFx1QUEyRlxcdUFBMzBcXHVBQTMzXFx1QUEzNFxcdUFBNERcXHVBQUVCXFx1QUFFRVxcdUFBRUZcXHVBQUY1XFx1QUJFM1xcdUFCRTRcXHVBQkU2XFx1QUJFN1xcdUFCRTlcXHVBQkVBXFx1QUJFQ118XFx1RDgwNFtcXHVEQzAwXFx1REMwMlxcdURDODJcXHVEQ0IwLVxcdURDQjJcXHVEQ0I3XFx1RENCOFxcdUREMkNcXHVERDQ1XFx1REQ0NlxcdUREODJcXHVEREIzLVxcdUREQjVcXHVEREJGXFx1RERDMFxcdUREQ0VcXHVERTJDLVxcdURFMkVcXHVERTMyXFx1REUzM1xcdURFMzVcXHVERUUwLVxcdURFRTJcXHVERjAyXFx1REYwM1xcdURGM0ZcXHVERjQxLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNjJcXHVERjYzXXxcXHVEODA1W1xcdURDMzUtXFx1REMzN1xcdURDNDBcXHVEQzQxXFx1REM0NVxcdURDQjFcXHVEQ0IyXFx1RENCOVxcdURDQkJcXHVEQ0JDXFx1RENCRVxcdURDQzFcXHVEREIwXFx1RERCMVxcdUREQjgtXFx1RERCQlxcdUREQkVcXHVERTMwLVxcdURFMzJcXHVERTNCXFx1REUzQ1xcdURFM0VcXHVERUFDXFx1REVBRVxcdURFQUZcXHVERUI2XFx1REYyNl18XFx1RDgwNltcXHVEQzJDLVxcdURDMkVcXHVEQzM4XFx1REQzMS1cXHVERDM1XFx1REQzN1xcdUREMzhcXHVERDNEXFx1REQ0MFxcdURENDJcXHVEREQxLVxcdURERDNcXHVERERDLVxcdUREREZcXHVEREU0XFx1REUzOVxcdURFNTdcXHVERTU4XFx1REU5N118XFx1RDgwN1tcXHVEQzJGXFx1REMzRVxcdURDQTlcXHVEQ0IxXFx1RENCNFxcdUREOEEtXFx1REQ4RVxcdUREOTNcXHVERDk0XFx1REQ5NlxcdURFRjVcXHVERUY2XXxcXHVEODFCW1xcdURGNTEtXFx1REY4N1xcdURGRjBcXHVERkYxXXxcXHVEODM0W1xcdURENjZcXHVERDZEXSkkLztcbnZhciByZUwgPSAvXltcXHUxMTAwLVxcdTExNUZcXHVBOTYwLVxcdUE5N0NdJC87XG52YXIgcmVWID0gL15bXFx1MTE2MC1cXHUxMUE3XFx1RDdCMC1cXHVEN0M2XSQvO1xudmFyIHJlVCA9IC9eW1xcdTExQTgtXFx1MTFGRlxcdUQ3Q0ItXFx1RDdGQl0kLztcbnZhciByZUxWID0gL15bXFx1QUMwMFxcdUFDMUNcXHVBQzM4XFx1QUM1NFxcdUFDNzBcXHVBQzhDXFx1QUNBOFxcdUFDQzRcXHVBQ0UwXFx1QUNGQ1xcdUFEMThcXHVBRDM0XFx1QUQ1MFxcdUFENkNcXHVBRDg4XFx1QURBNFxcdUFEQzBcXHVBRERDXFx1QURGOFxcdUFFMTRcXHVBRTMwXFx1QUU0Q1xcdUFFNjhcXHVBRTg0XFx1QUVBMFxcdUFFQkNcXHVBRUQ4XFx1QUVGNFxcdUFGMTBcXHVBRjJDXFx1QUY0OFxcdUFGNjRcXHVBRjgwXFx1QUY5Q1xcdUFGQjhcXHVBRkQ0XFx1QUZGMFxcdUIwMENcXHVCMDI4XFx1QjA0NFxcdUIwNjBcXHVCMDdDXFx1QjA5OFxcdUIwQjRcXHVCMEQwXFx1QjBFQ1xcdUIxMDhcXHVCMTI0XFx1QjE0MFxcdUIxNUNcXHVCMTc4XFx1QjE5NFxcdUIxQjBcXHVCMUNDXFx1QjFFOFxcdUIyMDRcXHVCMjIwXFx1QjIzQ1xcdUIyNThcXHVCMjc0XFx1QjI5MFxcdUIyQUNcXHVCMkM4XFx1QjJFNFxcdUIzMDBcXHVCMzFDXFx1QjMzOFxcdUIzNTRcXHVCMzcwXFx1QjM4Q1xcdUIzQThcXHVCM0M0XFx1QjNFMFxcdUIzRkNcXHVCNDE4XFx1QjQzNFxcdUI0NTBcXHVCNDZDXFx1QjQ4OFxcdUI0QTRcXHVCNEMwXFx1QjREQ1xcdUI0RjhcXHVCNTE0XFx1QjUzMFxcdUI1NENcXHVCNTY4XFx1QjU4NFxcdUI1QTBcXHVCNUJDXFx1QjVEOFxcdUI1RjRcXHVCNjEwXFx1QjYyQ1xcdUI2NDhcXHVCNjY0XFx1QjY4MFxcdUI2OUNcXHVCNkI4XFx1QjZENFxcdUI2RjBcXHVCNzBDXFx1QjcyOFxcdUI3NDRcXHVCNzYwXFx1Qjc3Q1xcdUI3OThcXHVCN0I0XFx1QjdEMFxcdUI3RUNcXHVCODA4XFx1QjgyNFxcdUI4NDBcXHVCODVDXFx1Qjg3OFxcdUI4OTRcXHVCOEIwXFx1QjhDQ1xcdUI4RThcXHVCOTA0XFx1QjkyMFxcdUI5M0NcXHVCOTU4XFx1Qjk3NFxcdUI5OTBcXHVCOUFDXFx1QjlDOFxcdUI5RTRcXHVCQTAwXFx1QkExQ1xcdUJBMzhcXHVCQTU0XFx1QkE3MFxcdUJBOENcXHVCQUE4XFx1QkFDNFxcdUJBRTBcXHVCQUZDXFx1QkIxOFxcdUJCMzRcXHVCQjUwXFx1QkI2Q1xcdUJCODhcXHVCQkE0XFx1QkJDMFxcdUJCRENcXHVCQkY4XFx1QkMxNFxcdUJDMzBcXHVCQzRDXFx1QkM2OFxcdUJDODRcXHVCQ0EwXFx1QkNCQ1xcdUJDRDhcXHVCQ0Y0XFx1QkQxMFxcdUJEMkNcXHVCRDQ4XFx1QkQ2NFxcdUJEODBcXHVCRDlDXFx1QkRCOFxcdUJERDRcXHVCREYwXFx1QkUwQ1xcdUJFMjhcXHVCRTQ0XFx1QkU2MFxcdUJFN0NcXHVCRTk4XFx1QkVCNFxcdUJFRDBcXHVCRUVDXFx1QkYwOFxcdUJGMjRcXHVCRjQwXFx1QkY1Q1xcdUJGNzhcXHVCRjk0XFx1QkZCMFxcdUJGQ0NcXHVCRkU4XFx1QzAwNFxcdUMwMjBcXHVDMDNDXFx1QzA1OFxcdUMwNzRcXHVDMDkwXFx1QzBBQ1xcdUMwQzhcXHVDMEU0XFx1QzEwMFxcdUMxMUNcXHVDMTM4XFx1QzE1NFxcdUMxNzBcXHVDMThDXFx1QzFBOFxcdUMxQzRcXHVDMUUwXFx1QzFGQ1xcdUMyMThcXHVDMjM0XFx1QzI1MFxcdUMyNkNcXHVDMjg4XFx1QzJBNFxcdUMyQzBcXHVDMkRDXFx1QzJGOFxcdUMzMTRcXHVDMzMwXFx1QzM0Q1xcdUMzNjhcXHVDMzg0XFx1QzNBMFxcdUMzQkNcXHVDM0Q4XFx1QzNGNFxcdUM0MTBcXHVDNDJDXFx1QzQ0OFxcdUM0NjRcXHVDNDgwXFx1QzQ5Q1xcdUM0QjhcXHVDNEQ0XFx1QzRGMFxcdUM1MENcXHVDNTI4XFx1QzU0NFxcdUM1NjBcXHVDNTdDXFx1QzU5OFxcdUM1QjRcXHVDNUQwXFx1QzVFQ1xcdUM2MDhcXHVDNjI0XFx1QzY0MFxcdUM2NUNcXHVDNjc4XFx1QzY5NFxcdUM2QjBcXHVDNkNDXFx1QzZFOFxcdUM3MDRcXHVDNzIwXFx1QzczQ1xcdUM3NThcXHVDNzc0XFx1Qzc5MFxcdUM3QUNcXHVDN0M4XFx1QzdFNFxcdUM4MDBcXHVDODFDXFx1QzgzOFxcdUM4NTRcXHVDODcwXFx1Qzg4Q1xcdUM4QThcXHVDOEM0XFx1QzhFMFxcdUM4RkNcXHVDOTE4XFx1QzkzNFxcdUM5NTBcXHVDOTZDXFx1Qzk4OFxcdUM5QTRcXHVDOUMwXFx1QzlEQ1xcdUM5RjhcXHVDQTE0XFx1Q0EzMFxcdUNBNENcXHVDQTY4XFx1Q0E4NFxcdUNBQTBcXHVDQUJDXFx1Q0FEOFxcdUNBRjRcXHVDQjEwXFx1Q0IyQ1xcdUNCNDhcXHVDQjY0XFx1Q0I4MFxcdUNCOUNcXHVDQkI4XFx1Q0JENFxcdUNCRjBcXHVDQzBDXFx1Q0MyOFxcdUNDNDRcXHVDQzYwXFx1Q0M3Q1xcdUNDOThcXHVDQ0I0XFx1Q0NEMFxcdUNDRUNcXHVDRDA4XFx1Q0QyNFxcdUNENDBcXHVDRDVDXFx1Q0Q3OFxcdUNEOTRcXHVDREIwXFx1Q0RDQ1xcdUNERThcXHVDRTA0XFx1Q0UyMFxcdUNFM0NcXHVDRTU4XFx1Q0U3NFxcdUNFOTBcXHVDRUFDXFx1Q0VDOFxcdUNFRTRcXHVDRjAwXFx1Q0YxQ1xcdUNGMzhcXHVDRjU0XFx1Q0Y3MFxcdUNGOENcXHVDRkE4XFx1Q0ZDNFxcdUNGRTBcXHVDRkZDXFx1RDAxOFxcdUQwMzRcXHVEMDUwXFx1RDA2Q1xcdUQwODhcXHVEMEE0XFx1RDBDMFxcdUQwRENcXHVEMEY4XFx1RDExNFxcdUQxMzBcXHVEMTRDXFx1RDE2OFxcdUQxODRcXHVEMUEwXFx1RDFCQ1xcdUQxRDhcXHVEMUY0XFx1RDIxMFxcdUQyMkNcXHVEMjQ4XFx1RDI2NFxcdUQyODBcXHVEMjlDXFx1RDJCOFxcdUQyRDRcXHVEMkYwXFx1RDMwQ1xcdUQzMjhcXHVEMzQ0XFx1RDM2MFxcdUQzN0NcXHVEMzk4XFx1RDNCNFxcdUQzRDBcXHVEM0VDXFx1RDQwOFxcdUQ0MjRcXHVENDQwXFx1RDQ1Q1xcdUQ0NzhcXHVENDk0XFx1RDRCMFxcdUQ0Q0NcXHVENEU4XFx1RDUwNFxcdUQ1MjBcXHVENTNDXFx1RDU1OFxcdUQ1NzRcXHVENTkwXFx1RDVBQ1xcdUQ1QzhcXHVENUU0XFx1RDYwMFxcdUQ2MUNcXHVENjM4XFx1RDY1NFxcdUQ2NzBcXHVENjhDXFx1RDZBOFxcdUQ2QzRcXHVENkUwXFx1RDZGQ1xcdUQ3MThcXHVENzM0XFx1RDc1MFxcdUQ3NkNcXHVENzg4XSQvO1xudmFyIHJlTFZUID0gL15bXFx1QUMwMS1cXHVBQzFCXFx1QUMxRC1cXHVBQzM3XFx1QUMzOS1cXHVBQzUzXFx1QUM1NS1cXHVBQzZGXFx1QUM3MS1cXHVBQzhCXFx1QUM4RC1cXHVBQ0E3XFx1QUNBOS1cXHVBQ0MzXFx1QUNDNS1cXHVBQ0RGXFx1QUNFMS1cXHVBQ0ZCXFx1QUNGRC1cXHVBRDE3XFx1QUQxOS1cXHVBRDMzXFx1QUQzNS1cXHVBRDRGXFx1QUQ1MS1cXHVBRDZCXFx1QUQ2RC1cXHVBRDg3XFx1QUQ4OS1cXHVBREEzXFx1QURBNS1cXHVBREJGXFx1QURDMS1cXHVBRERCXFx1QURERC1cXHVBREY3XFx1QURGOS1cXHVBRTEzXFx1QUUxNS1cXHVBRTJGXFx1QUUzMS1cXHVBRTRCXFx1QUU0RC1cXHVBRTY3XFx1QUU2OS1cXHVBRTgzXFx1QUU4NS1cXHVBRTlGXFx1QUVBMS1cXHVBRUJCXFx1QUVCRC1cXHVBRUQ3XFx1QUVEOS1cXHVBRUYzXFx1QUVGNS1cXHVBRjBGXFx1QUYxMS1cXHVBRjJCXFx1QUYyRC1cXHVBRjQ3XFx1QUY0OS1cXHVBRjYzXFx1QUY2NS1cXHVBRjdGXFx1QUY4MS1cXHVBRjlCXFx1QUY5RC1cXHVBRkI3XFx1QUZCOS1cXHVBRkQzXFx1QUZENS1cXHVBRkVGXFx1QUZGMS1cXHVCMDBCXFx1QjAwRC1cXHVCMDI3XFx1QjAyOS1cXHVCMDQzXFx1QjA0NS1cXHVCMDVGXFx1QjA2MS1cXHVCMDdCXFx1QjA3RC1cXHVCMDk3XFx1QjA5OS1cXHVCMEIzXFx1QjBCNS1cXHVCMENGXFx1QjBEMS1cXHVCMEVCXFx1QjBFRC1cXHVCMTA3XFx1QjEwOS1cXHVCMTIzXFx1QjEyNS1cXHVCMTNGXFx1QjE0MS1cXHVCMTVCXFx1QjE1RC1cXHVCMTc3XFx1QjE3OS1cXHVCMTkzXFx1QjE5NS1cXHVCMUFGXFx1QjFCMS1cXHVCMUNCXFx1QjFDRC1cXHVCMUU3XFx1QjFFOS1cXHVCMjAzXFx1QjIwNS1cXHVCMjFGXFx1QjIyMS1cXHVCMjNCXFx1QjIzRC1cXHVCMjU3XFx1QjI1OS1cXHVCMjczXFx1QjI3NS1cXHVCMjhGXFx1QjI5MS1cXHVCMkFCXFx1QjJBRC1cXHVCMkM3XFx1QjJDOS1cXHVCMkUzXFx1QjJFNS1cXHVCMkZGXFx1QjMwMS1cXHVCMzFCXFx1QjMxRC1cXHVCMzM3XFx1QjMzOS1cXHVCMzUzXFx1QjM1NS1cXHVCMzZGXFx1QjM3MS1cXHVCMzhCXFx1QjM4RC1cXHVCM0E3XFx1QjNBOS1cXHVCM0MzXFx1QjNDNS1cXHVCM0RGXFx1QjNFMS1cXHVCM0ZCXFx1QjNGRC1cXHVCNDE3XFx1QjQxOS1cXHVCNDMzXFx1QjQzNS1cXHVCNDRGXFx1QjQ1MS1cXHVCNDZCXFx1QjQ2RC1cXHVCNDg3XFx1QjQ4OS1cXHVCNEEzXFx1QjRBNS1cXHVCNEJGXFx1QjRDMS1cXHVCNERCXFx1QjRERC1cXHVCNEY3XFx1QjRGOS1cXHVCNTEzXFx1QjUxNS1cXHVCNTJGXFx1QjUzMS1cXHVCNTRCXFx1QjU0RC1cXHVCNTY3XFx1QjU2OS1cXHVCNTgzXFx1QjU4NS1cXHVCNTlGXFx1QjVBMS1cXHVCNUJCXFx1QjVCRC1cXHVCNUQ3XFx1QjVEOS1cXHVCNUYzXFx1QjVGNS1cXHVCNjBGXFx1QjYxMS1cXHVCNjJCXFx1QjYyRC1cXHVCNjQ3XFx1QjY0OS1cXHVCNjYzXFx1QjY2NS1cXHVCNjdGXFx1QjY4MS1cXHVCNjlCXFx1QjY5RC1cXHVCNkI3XFx1QjZCOS1cXHVCNkQzXFx1QjZENS1cXHVCNkVGXFx1QjZGMS1cXHVCNzBCXFx1QjcwRC1cXHVCNzI3XFx1QjcyOS1cXHVCNzQzXFx1Qjc0NS1cXHVCNzVGXFx1Qjc2MS1cXHVCNzdCXFx1Qjc3RC1cXHVCNzk3XFx1Qjc5OS1cXHVCN0IzXFx1QjdCNS1cXHVCN0NGXFx1QjdEMS1cXHVCN0VCXFx1QjdFRC1cXHVCODA3XFx1QjgwOS1cXHVCODIzXFx1QjgyNS1cXHVCODNGXFx1Qjg0MS1cXHVCODVCXFx1Qjg1RC1cXHVCODc3XFx1Qjg3OS1cXHVCODkzXFx1Qjg5NS1cXHVCOEFGXFx1QjhCMS1cXHVCOENCXFx1QjhDRC1cXHVCOEU3XFx1QjhFOS1cXHVCOTAzXFx1QjkwNS1cXHVCOTFGXFx1QjkyMS1cXHVCOTNCXFx1QjkzRC1cXHVCOTU3XFx1Qjk1OS1cXHVCOTczXFx1Qjk3NS1cXHVCOThGXFx1Qjk5MS1cXHVCOUFCXFx1QjlBRC1cXHVCOUM3XFx1QjlDOS1cXHVCOUUzXFx1QjlFNS1cXHVCOUZGXFx1QkEwMS1cXHVCQTFCXFx1QkExRC1cXHVCQTM3XFx1QkEzOS1cXHVCQTUzXFx1QkE1NS1cXHVCQTZGXFx1QkE3MS1cXHVCQThCXFx1QkE4RC1cXHVCQUE3XFx1QkFBOS1cXHVCQUMzXFx1QkFDNS1cXHVCQURGXFx1QkFFMS1cXHVCQUZCXFx1QkFGRC1cXHVCQjE3XFx1QkIxOS1cXHVCQjMzXFx1QkIzNS1cXHVCQjRGXFx1QkI1MS1cXHVCQjZCXFx1QkI2RC1cXHVCQjg3XFx1QkI4OS1cXHVCQkEzXFx1QkJBNS1cXHVCQkJGXFx1QkJDMS1cXHVCQkRCXFx1QkJERC1cXHVCQkY3XFx1QkJGOS1cXHVCQzEzXFx1QkMxNS1cXHVCQzJGXFx1QkMzMS1cXHVCQzRCXFx1QkM0RC1cXHVCQzY3XFx1QkM2OS1cXHVCQzgzXFx1QkM4NS1cXHVCQzlGXFx1QkNBMS1cXHVCQ0JCXFx1QkNCRC1cXHVCQ0Q3XFx1QkNEOS1cXHVCQ0YzXFx1QkNGNS1cXHVCRDBGXFx1QkQxMS1cXHVCRDJCXFx1QkQyRC1cXHVCRDQ3XFx1QkQ0OS1cXHVCRDYzXFx1QkQ2NS1cXHVCRDdGXFx1QkQ4MS1cXHVCRDlCXFx1QkQ5RC1cXHVCREI3XFx1QkRCOS1cXHVCREQzXFx1QkRENS1cXHVCREVGXFx1QkRGMS1cXHVCRTBCXFx1QkUwRC1cXHVCRTI3XFx1QkUyOS1cXHVCRTQzXFx1QkU0NS1cXHVCRTVGXFx1QkU2MS1cXHVCRTdCXFx1QkU3RC1cXHVCRTk3XFx1QkU5OS1cXHVCRUIzXFx1QkVCNS1cXHVCRUNGXFx1QkVEMS1cXHVCRUVCXFx1QkVFRC1cXHVCRjA3XFx1QkYwOS1cXHVCRjIzXFx1QkYyNS1cXHVCRjNGXFx1QkY0MS1cXHVCRjVCXFx1QkY1RC1cXHVCRjc3XFx1QkY3OS1cXHVCRjkzXFx1QkY5NS1cXHVCRkFGXFx1QkZCMS1cXHVCRkNCXFx1QkZDRC1cXHVCRkU3XFx1QkZFOS1cXHVDMDAzXFx1QzAwNS1cXHVDMDFGXFx1QzAyMS1cXHVDMDNCXFx1QzAzRC1cXHVDMDU3XFx1QzA1OS1cXHVDMDczXFx1QzA3NS1cXHVDMDhGXFx1QzA5MS1cXHVDMEFCXFx1QzBBRC1cXHVDMEM3XFx1QzBDOS1cXHVDMEUzXFx1QzBFNS1cXHVDMEZGXFx1QzEwMS1cXHVDMTFCXFx1QzExRC1cXHVDMTM3XFx1QzEzOS1cXHVDMTUzXFx1QzE1NS1cXHVDMTZGXFx1QzE3MS1cXHVDMThCXFx1QzE4RC1cXHVDMUE3XFx1QzFBOS1cXHVDMUMzXFx1QzFDNS1cXHVDMURGXFx1QzFFMS1cXHVDMUZCXFx1QzFGRC1cXHVDMjE3XFx1QzIxOS1cXHVDMjMzXFx1QzIzNS1cXHVDMjRGXFx1QzI1MS1cXHVDMjZCXFx1QzI2RC1cXHVDMjg3XFx1QzI4OS1cXHVDMkEzXFx1QzJBNS1cXHVDMkJGXFx1QzJDMS1cXHVDMkRCXFx1QzJERC1cXHVDMkY3XFx1QzJGOS1cXHVDMzEzXFx1QzMxNS1cXHVDMzJGXFx1QzMzMS1cXHVDMzRCXFx1QzM0RC1cXHVDMzY3XFx1QzM2OS1cXHVDMzgzXFx1QzM4NS1cXHVDMzlGXFx1QzNBMS1cXHVDM0JCXFx1QzNCRC1cXHVDM0Q3XFx1QzNEOS1cXHVDM0YzXFx1QzNGNS1cXHVDNDBGXFx1QzQxMS1cXHVDNDJCXFx1QzQyRC1cXHVDNDQ3XFx1QzQ0OS1cXHVDNDYzXFx1QzQ2NS1cXHVDNDdGXFx1QzQ4MS1cXHVDNDlCXFx1QzQ5RC1cXHVDNEI3XFx1QzRCOS1cXHVDNEQzXFx1QzRENS1cXHVDNEVGXFx1QzRGMS1cXHVDNTBCXFx1QzUwRC1cXHVDNTI3XFx1QzUyOS1cXHVDNTQzXFx1QzU0NS1cXHVDNTVGXFx1QzU2MS1cXHVDNTdCXFx1QzU3RC1cXHVDNTk3XFx1QzU5OS1cXHVDNUIzXFx1QzVCNS1cXHVDNUNGXFx1QzVEMS1cXHVDNUVCXFx1QzVFRC1cXHVDNjA3XFx1QzYwOS1cXHVDNjIzXFx1QzYyNS1cXHVDNjNGXFx1QzY0MS1cXHVDNjVCXFx1QzY1RC1cXHVDNjc3XFx1QzY3OS1cXHVDNjkzXFx1QzY5NS1cXHVDNkFGXFx1QzZCMS1cXHVDNkNCXFx1QzZDRC1cXHVDNkU3XFx1QzZFOS1cXHVDNzAzXFx1QzcwNS1cXHVDNzFGXFx1QzcyMS1cXHVDNzNCXFx1QzczRC1cXHVDNzU3XFx1Qzc1OS1cXHVDNzczXFx1Qzc3NS1cXHVDNzhGXFx1Qzc5MS1cXHVDN0FCXFx1QzdBRC1cXHVDN0M3XFx1QzdDOS1cXHVDN0UzXFx1QzdFNS1cXHVDN0ZGXFx1QzgwMS1cXHVDODFCXFx1QzgxRC1cXHVDODM3XFx1QzgzOS1cXHVDODUzXFx1Qzg1NS1cXHVDODZGXFx1Qzg3MS1cXHVDODhCXFx1Qzg4RC1cXHVDOEE3XFx1QzhBOS1cXHVDOEMzXFx1QzhDNS1cXHVDOERGXFx1QzhFMS1cXHVDOEZCXFx1QzhGRC1cXHVDOTE3XFx1QzkxOS1cXHVDOTMzXFx1QzkzNS1cXHVDOTRGXFx1Qzk1MS1cXHVDOTZCXFx1Qzk2RC1cXHVDOTg3XFx1Qzk4OS1cXHVDOUEzXFx1QzlBNS1cXHVDOUJGXFx1QzlDMS1cXHVDOURCXFx1QzlERC1cXHVDOUY3XFx1QzlGOS1cXHVDQTEzXFx1Q0ExNS1cXHVDQTJGXFx1Q0EzMS1cXHVDQTRCXFx1Q0E0RC1cXHVDQTY3XFx1Q0E2OS1cXHVDQTgzXFx1Q0E4NS1cXHVDQTlGXFx1Q0FBMS1cXHVDQUJCXFx1Q0FCRC1cXHVDQUQ3XFx1Q0FEOS1cXHVDQUYzXFx1Q0FGNS1cXHVDQjBGXFx1Q0IxMS1cXHVDQjJCXFx1Q0IyRC1cXHVDQjQ3XFx1Q0I0OS1cXHVDQjYzXFx1Q0I2NS1cXHVDQjdGXFx1Q0I4MS1cXHVDQjlCXFx1Q0I5RC1cXHVDQkI3XFx1Q0JCOS1cXHVDQkQzXFx1Q0JENS1cXHVDQkVGXFx1Q0JGMS1cXHVDQzBCXFx1Q0MwRC1cXHVDQzI3XFx1Q0MyOS1cXHVDQzQzXFx1Q0M0NS1cXHVDQzVGXFx1Q0M2MS1cXHVDQzdCXFx1Q0M3RC1cXHVDQzk3XFx1Q0M5OS1cXHVDQ0IzXFx1Q0NCNS1cXHVDQ0NGXFx1Q0NEMS1cXHVDQ0VCXFx1Q0NFRC1cXHVDRDA3XFx1Q0QwOS1cXHVDRDIzXFx1Q0QyNS1cXHVDRDNGXFx1Q0Q0MS1cXHVDRDVCXFx1Q0Q1RC1cXHVDRDc3XFx1Q0Q3OS1cXHVDRDkzXFx1Q0Q5NS1cXHVDREFGXFx1Q0RCMS1cXHVDRENCXFx1Q0RDRC1cXHVDREU3XFx1Q0RFOS1cXHVDRTAzXFx1Q0UwNS1cXHVDRTFGXFx1Q0UyMS1cXHVDRTNCXFx1Q0UzRC1cXHVDRTU3XFx1Q0U1OS1cXHVDRTczXFx1Q0U3NS1cXHVDRThGXFx1Q0U5MS1cXHVDRUFCXFx1Q0VBRC1cXHVDRUM3XFx1Q0VDOS1cXHVDRUUzXFx1Q0VFNS1cXHVDRUZGXFx1Q0YwMS1cXHVDRjFCXFx1Q0YxRC1cXHVDRjM3XFx1Q0YzOS1cXHVDRjUzXFx1Q0Y1NS1cXHVDRjZGXFx1Q0Y3MS1cXHVDRjhCXFx1Q0Y4RC1cXHVDRkE3XFx1Q0ZBOS1cXHVDRkMzXFx1Q0ZDNS1cXHVDRkRGXFx1Q0ZFMS1cXHVDRkZCXFx1Q0ZGRC1cXHVEMDE3XFx1RDAxOS1cXHVEMDMzXFx1RDAzNS1cXHVEMDRGXFx1RDA1MS1cXHVEMDZCXFx1RDA2RC1cXHVEMDg3XFx1RDA4OS1cXHVEMEEzXFx1RDBBNS1cXHVEMEJGXFx1RDBDMS1cXHVEMERCXFx1RDBERC1cXHVEMEY3XFx1RDBGOS1cXHVEMTEzXFx1RDExNS1cXHVEMTJGXFx1RDEzMS1cXHVEMTRCXFx1RDE0RC1cXHVEMTY3XFx1RDE2OS1cXHVEMTgzXFx1RDE4NS1cXHVEMTlGXFx1RDFBMS1cXHVEMUJCXFx1RDFCRC1cXHVEMUQ3XFx1RDFEOS1cXHVEMUYzXFx1RDFGNS1cXHVEMjBGXFx1RDIxMS1cXHVEMjJCXFx1RDIyRC1cXHVEMjQ3XFx1RDI0OS1cXHVEMjYzXFx1RDI2NS1cXHVEMjdGXFx1RDI4MS1cXHVEMjlCXFx1RDI5RC1cXHVEMkI3XFx1RDJCOS1cXHVEMkQzXFx1RDJENS1cXHVEMkVGXFx1RDJGMS1cXHVEMzBCXFx1RDMwRC1cXHVEMzI3XFx1RDMyOS1cXHVEMzQzXFx1RDM0NS1cXHVEMzVGXFx1RDM2MS1cXHVEMzdCXFx1RDM3RC1cXHVEMzk3XFx1RDM5OS1cXHVEM0IzXFx1RDNCNS1cXHVEM0NGXFx1RDNEMS1cXHVEM0VCXFx1RDNFRC1cXHVENDA3XFx1RDQwOS1cXHVENDIzXFx1RDQyNS1cXHVENDNGXFx1RDQ0MS1cXHVENDVCXFx1RDQ1RC1cXHVENDc3XFx1RDQ3OS1cXHVENDkzXFx1RDQ5NS1cXHVENEFGXFx1RDRCMS1cXHVENENCXFx1RDRDRC1cXHVENEU3XFx1RDRFOS1cXHVENTAzXFx1RDUwNS1cXHVENTFGXFx1RDUyMS1cXHVENTNCXFx1RDUzRC1cXHVENTU3XFx1RDU1OS1cXHVENTczXFx1RDU3NS1cXHVENThGXFx1RDU5MS1cXHVENUFCXFx1RDVBRC1cXHVENUM3XFx1RDVDOS1cXHVENUUzXFx1RDVFNS1cXHVENUZGXFx1RDYwMS1cXHVENjFCXFx1RDYxRC1cXHVENjM3XFx1RDYzOS1cXHVENjUzXFx1RDY1NS1cXHVENjZGXFx1RDY3MS1cXHVENjhCXFx1RDY4RC1cXHVENkE3XFx1RDZBOS1cXHVENkMzXFx1RDZDNS1cXHVENkRGXFx1RDZFMS1cXHVENkZCXFx1RDZGRC1cXHVENzE3XFx1RDcxOS1cXHVENzMzXFx1RDczNS1cXHVENzRGXFx1RDc1MS1cXHVENzZCXFx1RDc2RC1cXHVENzg3XFx1RDc4OS1cXHVEN0EzXSQvO1xudmFyIHJlRXh0UGljdCA9IC9eKD86W1xceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyMzg4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA1XFx1MjYwNy1cXHUyNjEyXFx1MjYxNC1cXHUyNjg1XFx1MjY5MC1cXHUyNzA1XFx1MjcwOC1cXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2My1cXHUyNzY3XFx1Mjc5NS1cXHUyNzk3XFx1MjdBMVxcdTI3QjBcXHUyN0JGXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVEQzAwLVxcdURDRkZcXHVERDBELVxcdUREMEZcXHVERDJGXFx1REQ2Qy1cXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERBRC1cXHVEREU1XFx1REUwMS1cXHVERTBGXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTNDLVxcdURFM0ZcXHVERTQ5LVxcdURGRkFdfFxcdUQ4M0RbXFx1REMwMC1cXHVERDNEXFx1REQ0Ni1cXHVERTRGXFx1REU4MC1cXHVERUZGXFx1REY3NC1cXHVERjdGXFx1REZENS1cXHVERkZGXXxcXHVEODNFW1xcdURDMEMtXFx1REMwRlxcdURDNDgtXFx1REM0RlxcdURDNUEtXFx1REM1RlxcdURDODgtXFx1REM4RlxcdURDQUUtXFx1RENGRlxcdUREMEMtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REVGRl18XFx1RDgzRltcXHVEQzAwLVxcdURGRkRdKSQvO1xudmFyIGdldENvZGVwb2ludFR5cGUgPSAoY2hhciwgY29kZSkgPT4ge1xuICB2YXIgdHlwZSA9IENvZGVwb2ludFR5cGUuQW55O1xuICBpZiAoY2hhci5zZWFyY2gocmVFeHRlbmQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5FeHRlbmQ7XG4gIH1cbiAgaWYgKGNvZGUgPT09IDB4MjAwZCkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5aV0o7XG4gIH1cbiAgaWYgKGNvZGUgPj0gMHgxZjFlNiAmJiBjb2RlIDw9IDB4MWYxZmYpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuUkk7XG4gIH1cbiAgaWYgKGNoYXIuc2VhcmNoKHJlUHJlcGVuZCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlByZXBlbmQ7XG4gIH1cbiAgaWYgKGNoYXIuc2VhcmNoKHJlU3BhY2luZ01hcmspICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5TcGFjaW5nTWFyaztcbiAgfVxuICBpZiAoY2hhci5zZWFyY2gocmVMKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTDtcbiAgfVxuICBpZiAoY2hhci5zZWFyY2gocmVWKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuVjtcbiAgfVxuICBpZiAoY2hhci5zZWFyY2gocmVUKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuVDtcbiAgfVxuICBpZiAoY2hhci5zZWFyY2gocmVMVikgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkxWO1xuICB9XG4gIGlmIChjaGFyLnNlYXJjaChyZUxWVCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkxWVDtcbiAgfVxuICBpZiAoY2hhci5zZWFyY2gocmVFeHRQaWN0KSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuRXh0UGljdDtcbiAgfVxuICByZXR1cm4gdHlwZTtcbn07XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHgsIHkpIHtcbiAgcmV0dXJuICh4ICYgeSkgIT09IDA7XG59XG52YXIgTm9uQm91bmRhcnlQYWlycyA9IFtcbi8vIEdCNlxuW0NvZGVwb2ludFR5cGUuTCwgQ29kZXBvaW50VHlwZS5MIHwgQ29kZXBvaW50VHlwZS5WIHwgQ29kZXBvaW50VHlwZS5MViB8IENvZGVwb2ludFR5cGUuTFZUXSxcbi8vIEdCN1xuW0NvZGVwb2ludFR5cGUuTFYgfCBDb2RlcG9pbnRUeXBlLlYsIENvZGVwb2ludFR5cGUuViB8IENvZGVwb2ludFR5cGUuVF0sXG4vLyBHQjhcbltDb2RlcG9pbnRUeXBlLkxWVCB8IENvZGVwb2ludFR5cGUuVCwgQ29kZXBvaW50VHlwZS5UXSxcbi8vIEdCOVxuW0NvZGVwb2ludFR5cGUuQW55LCBDb2RlcG9pbnRUeXBlLkV4dGVuZCB8IENvZGVwb2ludFR5cGUuWldKXSxcbi8vIEdCOWFcbltDb2RlcG9pbnRUeXBlLkFueSwgQ29kZXBvaW50VHlwZS5TcGFjaW5nTWFya10sXG4vLyBHQjliXG5bQ29kZXBvaW50VHlwZS5QcmVwZW5kLCBDb2RlcG9pbnRUeXBlLkFueV0sXG4vLyBHQjExXG5bQ29kZXBvaW50VHlwZS5aV0osIENvZGVwb2ludFR5cGUuRXh0UGljdF0sXG4vLyBHQjEyIGFuZCBHQjEzXG5bQ29kZXBvaW50VHlwZS5SSSwgQ29kZXBvaW50VHlwZS5SSV1dO1xuZnVuY3Rpb24gaXNCb3VuZGFyeVBhaXIobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIE5vbkJvdW5kYXJ5UGFpcnMuZmluZEluZGV4KHIgPT4gaW50ZXJzZWN0cyhsZWZ0LCByWzBdKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCByWzFdKSkgPT09IC0xO1xufVxudmFyIGVuZGluZ0Vtb2ppWldKID0gLyg/OltcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjM4OFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNVxcdTI2MDctXFx1MjYxMlxcdTI2MTQtXFx1MjY4NVxcdTI2OTAtXFx1MjcwNVxcdTI3MDgtXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjMtXFx1Mjc2N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwMC1cXHVEQ0ZGXFx1REQwRC1cXHVERDBGXFx1REQyRlxcdURENkMtXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdUREQUQtXFx1RERFNVxcdURFMDEtXFx1REUwRlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REUzQy1cXHVERTNGXFx1REU0OS1cXHVERkZBXXxcXHVEODNEW1xcdURDMDAtXFx1REQzRFxcdURENDYtXFx1REU0RlxcdURFODAtXFx1REVGRlxcdURGNzQtXFx1REY3RlxcdURGRDUtXFx1REZGRl18XFx1RDgzRVtcXHVEQzBDLVxcdURDMEZcXHVEQzQ4LVxcdURDNEZcXHVEQzVBLVxcdURDNUZcXHVEQzg4LVxcdURDOEZcXHVEQ0FFLVxcdURDRkZcXHVERDBDLVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURFRkZdfFxcdUQ4M0ZbXFx1REMwMC1cXHVERkZEXSkoPzpbXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA3RkRcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwODk4LVxcdTA4OUZcXHUwOENBLVxcdTA4RTFcXHUwOEUzLVxcdTA5MDJcXHUwOTNBXFx1MDkzQ1xcdTA5NDEtXFx1MDk0OFxcdTA5NERcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOUJDXFx1MDlCRVxcdTA5QzEtXFx1MDlDNFxcdTA5Q0RcXHUwOUQ3XFx1MDlFMlxcdTA5RTNcXHUwOUZFXFx1MEEwMVxcdTBBMDJcXHUwQTNDXFx1MEE0MVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxXFx1MEE4MlxcdTBBQkNcXHUwQUMxLVxcdTBBQzVcXHUwQUM3XFx1MEFDOFxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBBRkEtXFx1MEFGRlxcdTBCMDFcXHUwQjNDXFx1MEIzRVxcdTBCM0ZcXHUwQjQxLVxcdTBCNDRcXHUwQjREXFx1MEI1NS1cXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJCRVxcdTBCQzBcXHUwQkNEXFx1MEJEN1xcdTBDMDBcXHUwQzA0XFx1MEMzQ1xcdTBDM0UtXFx1MEM0MFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM2MlxcdTBDNjNcXHUwQzgxXFx1MENCQ1xcdTBDQkZcXHUwQ0MyXFx1MENDNlxcdTBDQ0NcXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0UyXFx1MENFM1xcdTBEMDBcXHUwRDAxXFx1MEQzQlxcdTBEM0NcXHUwRDNFXFx1MEQ0MS1cXHUwRDQ0XFx1MEQ0RFxcdTBENTdcXHUwRDYyXFx1MEQ2M1xcdTBEODFcXHUwRENBXFx1MERDRlxcdTBERDItXFx1MERENFxcdTBERDZcXHUwRERGXFx1MEUzMVxcdTBFMzQtXFx1MEUzQVxcdTBFNDctXFx1MEU0RVxcdTBFQjFcXHUwRUI0LVxcdTBFQkNcXHUwRUM4LVxcdTBFQ0VcXHUwRjE4XFx1MEYxOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGNzEtXFx1MEY3RVxcdTBGODAtXFx1MEY4NFxcdTBGODZcXHUwRjg3XFx1MEY4RC1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMkQtXFx1MTAzMFxcdTEwMzItXFx1MTAzN1xcdTEwMzlcXHUxMDNBXFx1MTAzRFxcdTEwM0VcXHUxMDU4XFx1MTA1OVxcdTEwNUUtXFx1MTA2MFxcdTEwNzEtXFx1MTA3NFxcdTEwODJcXHUxMDg1XFx1MTA4NlxcdTEwOERcXHUxMDlEXFx1MTM1RC1cXHUxMzVGXFx1MTcxMi1cXHUxNzE0XFx1MTczMlxcdTE3MzNcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNFxcdTE3QjVcXHUxN0I3LVxcdTE3QkRcXHUxN0M2XFx1MTdDOS1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4MEZcXHUxODg1XFx1MTg4NlxcdTE4QTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3XFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M0JcXHUxQTE3XFx1MUExOFxcdTFBMUJcXHUxQTU2XFx1MUE1OC1cXHUxQTVFXFx1MUE2MFxcdTFBNjJcXHUxQTY1LVxcdTFBNkNcXHUxQTczLVxcdTFBN0NcXHUxQTdGXFx1MUFCMC1cXHUxQUNFXFx1MUIwMC1cXHUxQjAzXFx1MUIzNC1cXHUxQjNBXFx1MUIzQ1xcdTFCNDJcXHUxQjZCLVxcdTFCNzNcXHUxQjgwXFx1MUI4MVxcdTFCQTItXFx1MUJBNVxcdTFCQThcXHUxQkE5XFx1MUJBQi1cXHUxQkFEXFx1MUJFNlxcdTFCRThcXHUxQkU5XFx1MUJFRFxcdTFCRUYtXFx1MUJGMVxcdTFDMkMtXFx1MUMzM1xcdTFDMzZcXHUxQzM3XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0UwXFx1MUNFMi1cXHUxQ0U4XFx1MUNFRFxcdTFDRjRcXHUxQ0Y4XFx1MUNGOVxcdTFEQzAtXFx1MURGRlxcdTIwMENcXHUyMEQwLVxcdTIwRjBcXHUyQ0VGLVxcdTJDRjFcXHUyRDdGXFx1MkRFMC1cXHUyREZGXFx1MzAyQS1cXHUzMDJGXFx1MzA5OVxcdTMwOUFcXHVBNjZGLVxcdUE2NzJcXHVBNjc0LVxcdUE2N0RcXHVBNjlFXFx1QTY5RlxcdUE2RjBcXHVBNkYxXFx1QTgwMlxcdUE4MDZcXHVBODBCXFx1QTgyNVxcdUE4MjZcXHVBODJDXFx1QThDNFxcdUE4QzVcXHVBOEUwLVxcdUE4RjFcXHVBOEZGXFx1QTkyNi1cXHVBOTJEXFx1QTk0Ny1cXHVBOTUxXFx1QTk4MC1cXHVBOTgyXFx1QTlCM1xcdUE5QjYtXFx1QTlCOVxcdUE5QkNcXHVBOUJEXFx1QTlFNVxcdUFBMjktXFx1QUEyRVxcdUFBMzFcXHVBQTMyXFx1QUEzNVxcdUFBMzZcXHVBQTQzXFx1QUE0Q1xcdUFBN0NcXHVBQUIwXFx1QUFCMi1cXHVBQUI0XFx1QUFCN1xcdUFBQjhcXHVBQUJFXFx1QUFCRlxcdUFBQzFcXHVBQUVDXFx1QUFFRFxcdUFBRjZcXHVBQkU1XFx1QUJFOFxcdUFCRURcXHVGQjFFXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXFx1RkY5RVxcdUZGOUZdfFxcdUQ4MDBbXFx1RERGRFxcdURFRTBcXHVERjc2LVxcdURGN0FdfFxcdUQ4MDJbXFx1REUwMS1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMEZcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REVFNVxcdURFRTZdfFxcdUQ4MDNbXFx1REQyNC1cXHVERDI3XFx1REVBQlxcdURFQUNcXHVERUZELVxcdURFRkZcXHVERjQ2LVxcdURGNTBcXHVERjgyLVxcdURGODVdfFxcdUQ4MDRbXFx1REMwMVxcdURDMzgtXFx1REM0NlxcdURDNzBcXHVEQzczXFx1REM3NFxcdURDN0YtXFx1REM4MVxcdURDQjMtXFx1RENCNlxcdURDQjlcXHVEQ0JBXFx1RENDMlxcdUREMDAtXFx1REQwMlxcdUREMjctXFx1REQyQlxcdUREMkQtXFx1REQzNFxcdURENzNcXHVERDgwXFx1REQ4MVxcdUREQjYtXFx1RERCRVxcdUREQzktXFx1RERDQ1xcdUREQ0ZcXHVERTJGLVxcdURFMzFcXHVERTM0XFx1REUzNlxcdURFMzdcXHVERTNFXFx1REU0MVxcdURFREZcXHVERUUzLVxcdURFRUFcXHVERjAwXFx1REYwMVxcdURGM0JcXHVERjNDXFx1REYzRVxcdURGNDBcXHVERjU3XFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMzgtXFx1REMzRlxcdURDNDItXFx1REM0NFxcdURDNDZcXHVEQzVFXFx1RENCMFxcdURDQjMtXFx1RENCOFxcdURDQkFcXHVEQ0JEXFx1RENCRlxcdURDQzBcXHVEQ0MyXFx1RENDM1xcdUREQUZcXHVEREIyLVxcdUREQjVcXHVEREJDXFx1RERCRFxcdUREQkZcXHVEREMwXFx1REREQ1xcdURERERcXHVERTMzLVxcdURFM0FcXHVERTNEXFx1REUzRlxcdURFNDBcXHVERUFCXFx1REVBRFxcdURFQjAtXFx1REVCNVxcdURFQjdcXHVERjFELVxcdURGMUZcXHVERjIyLVxcdURGMjVcXHVERjI3LVxcdURGMkJdfFxcdUQ4MDZbXFx1REMyRi1cXHVEQzM3XFx1REMzOVxcdURDM0FcXHVERDMwXFx1REQzQlxcdUREM0NcXHVERDNFXFx1REQ0M1xcdURERDQtXFx1REREN1xcdUREREFcXHVERERCXFx1RERFMFxcdURFMDEtXFx1REUwQVxcdURFMzMtXFx1REUzOFxcdURFM0ItXFx1REUzRVxcdURFNDdcXHVERTUxLVxcdURFNTZcXHVERTU5LVxcdURFNUJcXHVERThBLVxcdURFOTZcXHVERTk4XFx1REU5OV18XFx1RDgwN1tcXHVEQzMwLVxcdURDMzZcXHVEQzM4LVxcdURDM0RcXHVEQzNGXFx1REM5Mi1cXHVEQ0E3XFx1RENBQS1cXHVEQ0IwXFx1RENCMlxcdURDQjNcXHVEQ0I1XFx1RENCNlxcdUREMzEtXFx1REQzNlxcdUREM0FcXHVERDNDXFx1REQzRFxcdUREM0YtXFx1REQ0NVxcdURENDdcXHVERDkwXFx1REQ5MVxcdUREOTVcXHVERDk3XFx1REVGM1xcdURFRjRcXHVERjAwXFx1REYwMVxcdURGMzYtXFx1REYzQVxcdURGNDBcXHVERjQyXXxcXHVEODBEW1xcdURDNDBcXHVEQzQ3LVxcdURDNTVdfFxcdUQ4MUFbXFx1REVGMC1cXHVERUY0XFx1REYzMC1cXHVERjM2XXxcXHVEODFCW1xcdURGNEZcXHVERjhGLVxcdURGOTJcXHVERkU0XXxcXHVEODJGW1xcdURDOURcXHVEQzlFXXxcXHVEODMzW1xcdURGMDAtXFx1REYyRFxcdURGMzAtXFx1REY0Nl18XFx1RDgzNFtcXHVERDY1XFx1REQ2Ny1cXHVERDY5XFx1REQ2RS1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODM4W1xcdURDMDAtXFx1REMwNlxcdURDMDgtXFx1REMxOFxcdURDMUItXFx1REMyMVxcdURDMjNcXHVEQzI0XFx1REMyNi1cXHVEQzJBXFx1REM4RlxcdUREMzAtXFx1REQzNlxcdURFQUVcXHVERUVDLVxcdURFRUZdfFxcdUQ4MzlbXFx1RENFQy1cXHVEQ0VGXXxcXHVEODNBW1xcdURDRDAtXFx1RENENlxcdURENDQtXFx1REQ0QV18XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdURCNDBbXFx1REMyMC1cXHVEQzdGXFx1REQwMC1cXHVEREVGXSkqXFx1MjAwRCQvO1xudmFyIGVuZHNXaXRoRW1vamlaV0ogPSBzdHIgPT4ge1xuICByZXR1cm4gc3RyLnNlYXJjaChlbmRpbmdFbW9qaVpXSikgIT09IC0xO1xufTtcbnZhciBlbmRpbmdSSXMgPSAvKD86XFx1RDgzQ1tcXHVEREU2LVxcdURERkZdKSskL2c7XG52YXIgZW5kc1dpdGhPZGROdW1iZXJPZlJJcyA9IHN0ciA9PiB7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaChlbmRpbmdSSXMpO1xuICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gQSBSSSBpcyByZXByZXNlbnRlZCBieSBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAgIHZhciBudW1SSXMgPSBtYXRjaFswXS5sZW5ndGggLyAyO1xuICAgIHJldHVybiBudW1SSXMgJSAyID09PSAxO1xuICB9XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgVGV4dFRyYW5zZm9ybXMgPSB7XG4gIGRlbGV0ZShlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBlZGl0b3IuZGVsZXRlKG9wdGlvbnMpO1xuICB9LFxuICBpbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50LCBvcHRpb25zKSB7XG4gICAgZWRpdG9yLmluc2VydEZyYWdtZW50KGZyYWdtZW50LCBvcHRpb25zKTtcbiAgfSxcbiAgaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQgPSBnZXREZWZhdWx0SW5zZXJ0TG9jYXRpb24oZWRpdG9yKVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfVxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZW5kID0gUmFuZ2UuZW5kKGF0KTtcbiAgICAgICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGVuZFxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdGFydCA9IFJhbmdlLnN0YXJ0KGF0KTtcbiAgICAgICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgICAgICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdCxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSBzdGFydFJlZi51bnJlZigpO1xuICAgICAgICAgIHZhciBlbmRQb2ludCA9IGVuZFJlZi51bnJlZigpO1xuICAgICAgICAgIGF0ID0gc3RhcnRQb2ludCB8fCBlbmRQb2ludDtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgICAgIGFuY2hvcjogYXQsXG4gICAgICAgICAgICBmb2N1czogYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXRcbiAgICAgIH0pIHx8IEVkaXRvci5lbGVtZW50UmVhZE9ubHkoZWRpdG9yLCB7XG4gICAgICAgIGF0XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSBhdDtcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6ICdpbnNlcnRfdGV4dCcsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgdGV4dFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkOShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDkoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ5KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ5KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgVHJhbnNmb3JtcyA9IF9vYmplY3RTcHJlYWQkOShfb2JqZWN0U3ByZWFkJDkoX29iamVjdFNwcmVhZCQ5KF9vYmplY3RTcHJlYWQkOSh7fSwgR2VuZXJhbFRyYW5zZm9ybXMpLCBOb2RlVHJhbnNmb3JtcyksIFNlbGVjdGlvblRyYW5zZm9ybXMpLCBUZXh0VHJhbnNmb3Jtcyk7XG5cbnZhciBhcHBseSA9IChlZGl0b3IsIG9wKSA9PiB7XG4gIGZvciAodmFyIHJlZiBvZiBFZGl0b3IucGF0aFJlZnMoZWRpdG9yKSkge1xuICAgIFBhdGhSZWYudHJhbnNmb3JtKHJlZiwgb3ApO1xuICB9XG4gIGZvciAodmFyIF9yZWYgb2YgRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpKSB7XG4gICAgUG9pbnRSZWYudHJhbnNmb3JtKF9yZWYsIG9wKTtcbiAgfVxuICBmb3IgKHZhciBfcmVmMiBvZiBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcikpIHtcbiAgICBSYW5nZVJlZi50cmFuc2Zvcm0oX3JlZjIsIG9wKTtcbiAgfVxuICB2YXIgb2xkRGlydHlQYXRocyA9IERJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IFtdO1xuICB2YXIgb2xkRGlydHlQYXRoS2V5cyA9IERJUlRZX1BBVEhfS0VZUy5nZXQoZWRpdG9yKSB8fCBuZXcgU2V0KCk7XG4gIHZhciBkaXJ0eVBhdGhzO1xuICB2YXIgZGlydHlQYXRoS2V5cztcbiAgdmFyIGFkZCA9IHBhdGggPT4ge1xuICAgIGlmIChwYXRoKSB7XG4gICAgICB2YXIga2V5ID0gcGF0aC5qb2luKCcsJyk7XG4gICAgICBpZiAoIWRpcnR5UGF0aEtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgZGlydHlQYXRoS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgZGlydHlQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgaWYgKFBhdGgub3BlcmF0aW9uQ2FuVHJhbnNmb3JtUGF0aChvcCkpIHtcbiAgICBkaXJ0eVBhdGhzID0gW107XG4gICAgZGlydHlQYXRoS2V5cyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKHZhciBwYXRoIG9mIG9sZERpcnR5UGF0aHMpIHtcbiAgICAgIHZhciBuZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApO1xuICAgICAgYWRkKG5ld1BhdGgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkaXJ0eVBhdGhzID0gb2xkRGlydHlQYXRocztcbiAgICBkaXJ0eVBhdGhLZXlzID0gb2xkRGlydHlQYXRoS2V5cztcbiAgfVxuICB2YXIgbmV3RGlydHlQYXRocyA9IGVkaXRvci5nZXREaXJ0eVBhdGhzKG9wKTtcbiAgZm9yICh2YXIgX3BhdGggb2YgbmV3RGlydHlQYXRocykge1xuICAgIGFkZChfcGF0aCk7XG4gIH1cbiAgRElSVFlfUEFUSFMuc2V0KGVkaXRvciwgZGlydHlQYXRocyk7XG4gIERJUlRZX1BBVEhfS0VZUy5zZXQoZWRpdG9yLCBkaXJ0eVBhdGhLZXlzKTtcbiAgVHJhbnNmb3Jtcy50cmFuc2Zvcm0oZWRpdG9yLCBvcCk7XG4gIGVkaXRvci5vcGVyYXRpb25zLnB1c2gob3ApO1xuICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvciwge1xuICAgIG9wZXJhdGlvbjogb3BcbiAgfSk7XG4gIC8vIENsZWFyIGFueSBmb3JtYXRzIGFwcGxpZWQgdG8gdGhlIGN1cnNvciBpZiB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuXG4gIGlmIChvcC50eXBlID09PSAnc2V0X3NlbGVjdGlvbicpIHtcbiAgICBlZGl0b3IubWFya3MgPSBudWxsO1xuICB9XG4gIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICBGTFVTSElORy5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIEZMVVNISU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgIGVkaXRvci5vbkNoYW5nZSh7XG4gICAgICAgIG9wZXJhdGlvbjogb3BcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm9wZXJhdGlvbnMgPSBbXTtcbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIFwiZGlydHlcIiBwYXRocyBnZW5lcmF0ZWQgZnJvbSBhbiBvcGVyYXRpb24uXG4gKi9cbnZhciBnZXREaXJ0eVBhdGhzID0gKGVkaXRvciwgb3ApID0+IHtcbiAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHJldHVybiBQYXRoLmxldmVscyhwYXRoKTtcbiAgICAgIH1cbiAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwYXRoOiBfcGF0aFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHZhciBsZXZlbHMgPSBQYXRoLmxldmVscyhfcGF0aCk7XG4gICAgICAgIHZhciBkZXNjZW5kYW50cyA9IFRleHQuaXNUZXh0KG5vZGUpID8gW10gOiBBcnJheS5mcm9tKE5vZGUubm9kZXMobm9kZSksIF9yZWYgPT4ge1xuICAgICAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuIF9wYXRoLmNvbmNhdChwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbLi4ubGV2ZWxzLCAuLi5kZXNjZW5kYW50c107XG4gICAgICB9XG4gICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgyXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgdmFyIGFuY2VzdG9ycyA9IFBhdGguYW5jZXN0b3JzKF9wYXRoMik7XG4gICAgICAgIHZhciBwcmV2aW91c1BhdGggPSBQYXRoLnByZXZpb3VzKF9wYXRoMik7XG4gICAgICAgIHJldHVybiBbLi4uYW5jZXN0b3JzLCBwcmV2aW91c1BhdGhdO1xuICAgICAgfVxuICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgzLFxuICAgICAgICAgIG5ld1BhdGhcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX3BhdGgzLCBuZXdQYXRoKSkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2xkQW5jZXN0b3JzID0gW107XG4gICAgICAgIHZhciBuZXdBbmNlc3RvcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgYW5jZXN0b3Igb2YgUGF0aC5hbmNlc3RvcnMoX3BhdGgzKSkge1xuICAgICAgICAgIHZhciBwID0gUGF0aC50cmFuc2Zvcm0oYW5jZXN0b3IsIG9wKTtcbiAgICAgICAgICBvbGRBbmNlc3RvcnMucHVzaChwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfYW5jZXN0b3Igb2YgUGF0aC5hbmNlc3RvcnMobmV3UGF0aCkpIHtcbiAgICAgICAgICB2YXIgX3AgPSBQYXRoLnRyYW5zZm9ybShfYW5jZXN0b3IsIG9wKTtcbiAgICAgICAgICBuZXdBbmNlc3RvcnMucHVzaChfcCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld1BhcmVudCA9IG5ld0FuY2VzdG9yc1tuZXdBbmNlc3RvcnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBuZXdJbmRleCA9IG5ld1BhdGhbbmV3UGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHJlc3VsdFBhdGggPSBuZXdQYXJlbnQuY29uY2F0KG5ld0luZGV4KTtcbiAgICAgICAgcmV0dXJuIFsuLi5vbGRBbmNlc3RvcnMsIC4uLm5ld0FuY2VzdG9ycywgcmVzdWx0UGF0aF07XG4gICAgICB9XG4gICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoNFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHZhciBfYW5jZXN0b3JzID0gUGF0aC5hbmNlc3RvcnMoX3BhdGg0KTtcbiAgICAgICAgcmV0dXJuIFsuLi5fYW5jZXN0b3JzXTtcbiAgICAgIH1cbiAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDVcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICB2YXIgX2xldmVscyA9IFBhdGgubGV2ZWxzKF9wYXRoNSk7XG4gICAgICAgIHZhciBuZXh0UGF0aCA9IFBhdGgubmV4dChfcGF0aDUpO1xuICAgICAgICByZXR1cm4gWy4uLl9sZXZlbHMsIG5leHRQYXRoXTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gIH1cbn07XG5cbnZhciBnZXRGcmFnbWVudCA9IGVkaXRvciA9PiB7XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gTm9kZS5mcmFnbWVudChlZGl0b3IsIHNlbGVjdGlvbik7XG4gIH1cbiAgcmV0dXJuIFtdO1xufTtcblxudmFyIG5vcm1hbGl6ZU5vZGUgPSAoZWRpdG9yLCBlbnRyeSkgPT4ge1xuICB2YXIgW25vZGUsIHBhdGhdID0gZW50cnk7XG4gIC8vIFRoZXJlIGFyZSBubyBjb3JlIG5vcm1hbGl6YXRpb25zIGZvciB0ZXh0IG5vZGVzLlxuICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gRW5zdXJlIHRoYXQgYmxvY2sgYW5kIGlubGluZSBub2RlcyBoYXZlIGF0IGxlYXN0IG9uZSB0ZXh0IGNoaWxkLlxuICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICB2YXIgY2hpbGQgPSB7XG4gICAgICB0ZXh0OiAnJ1xuICAgIH07XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGNoaWxkLCB7XG4gICAgICBhdDogcGF0aC5jb25jYXQoMCksXG4gICAgICB2b2lkczogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgaGF2ZSBibG9jayBvciBpbmxpbmUgY2hpbGRyZW4uXG4gIHZhciBzaG91bGRIYXZlSW5saW5lcyA9IEVkaXRvci5pc0VkaXRvcihub2RlKSA/IGZhbHNlIDogRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgKGVkaXRvci5pc0lubGluZShub2RlKSB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBUZXh0LmlzVGV4dChub2RlLmNoaWxkcmVuWzBdKSB8fCBlZGl0b3IuaXNJbmxpbmUobm9kZS5jaGlsZHJlblswXSkpO1xuICAvLyBTaW5jZSB3ZSdsbCBiZSBhcHBseWluZyBvcGVyYXRpb25zIHdoaWxlIGl0ZXJhdGluZywga2VlcCB0cmFjayBvZiBhblxuICAvLyBpbmRleCB0aGF0IGFjY291bnRzIGZvciBhbnkgYWRkZWQvcmVtb3ZlZCBub2Rlcy5cbiAgdmFyIG4gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyssIG4rKykge1xuICAgIHZhciBjdXJyZW50Tm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gICAgaWYgKFRleHQuaXNUZXh0KGN1cnJlbnROb2RlKSkgY29udGludWU7XG4gICAgdmFyIF9jaGlsZCA9IGN1cnJlbnROb2RlLmNoaWxkcmVuW25dO1xuICAgIHZhciBwcmV2ID0gY3VycmVudE5vZGUuY2hpbGRyZW5bbiAtIDFdO1xuICAgIHZhciBpc0xhc3QgPSBpID09PSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgdmFyIGlzSW5saW5lT3JUZXh0ID0gVGV4dC5pc1RleHQoX2NoaWxkKSB8fCBFbGVtZW50LmlzRWxlbWVudChfY2hpbGQpICYmIGVkaXRvci5pc0lubGluZShfY2hpbGQpO1xuICAgIC8vIE9ubHkgYWxsb3cgYmxvY2sgbm9kZXMgaW4gdGhlIHRvcC1sZXZlbCBjaGlsZHJlbiBhbmQgcGFyZW50IGJsb2Nrc1xuICAgIC8vIHRoYXQgb25seSBjb250YWluIGJsb2NrIG5vZGVzLiBTaW1pbGFybHksIG9ubHkgYWxsb3cgaW5saW5lIG5vZGVzIGluXG4gICAgLy8gb3RoZXIgaW5saW5lIG5vZGVzLCBvciBwYXJlbnQgYmxvY2tzIHRoYXQgb25seSBjb250YWluIGlubGluZXMgYW5kXG4gICAgLy8gdGV4dC5cbiAgICBpZiAoaXNJbmxpbmVPclRleHQgIT09IHNob3VsZEhhdmVJbmxpbmVzKSB7XG4gICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIG4tLTtcbiAgICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KF9jaGlsZCkpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGlubGluZSBub2RlcyBhcmUgc3Vycm91bmRlZCBieSB0ZXh0IG5vZGVzLlxuICAgICAgaWYgKGVkaXRvci5pc0lubGluZShfY2hpbGQpKSB7XG4gICAgICAgIGlmIChwcmV2ID09IG51bGwgfHwgIVRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgdmFyIG5ld0NoaWxkID0ge1xuICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICB9O1xuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBuZXdDaGlsZCwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgdmFyIF9uZXdDaGlsZCA9IHtcbiAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgfTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgX25ld0NoaWxkLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiArIDEpLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlcyB0aGF0IGFyZSBlbXB0eSBvciBtYXRjaC5cbiAgICAgIGlmIChwcmV2ICE9IG51bGwgJiYgVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgaWYgKFRleHQuZXF1YWxzKF9jaGlsZCwgcHJldiwge1xuICAgICAgICAgIGxvb3NlOiB0cnVlXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH0gZWxzZSBpZiAocHJldi50ZXh0ID09PSAnJykge1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiAtIDEpLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH0gZWxzZSBpZiAoX2NoaWxkLnRleHQgPT09ICcnKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2hvdWxkTm9ybWFsaXplID0gKGVkaXRvciwgX3JlZikgPT4ge1xuICB2YXIge1xuICAgIGl0ZXJhdGlvbixcbiAgICBpbml0aWFsRGlydHlQYXRoc0xlbmd0aFxuICB9ID0gX3JlZjtcbiAgdmFyIG1heEl0ZXJhdGlvbnMgPSBpbml0aWFsRGlydHlQYXRoc0xlbmd0aCAqIDQyOyAvLyBIQUNLOiBiZXR0ZXIgd2F5P1xuICBpZiAoaXRlcmF0aW9uID4gbWF4SXRlcmF0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjb21wbGV0ZWx5IG5vcm1hbGl6ZSB0aGUgZWRpdG9yIGFmdGVyIFwiLmNvbmNhdChtYXhJdGVyYXRpb25zLCBcIiBpdGVyYXRpb25zISBUaGlzIGlzIHVzdWFsbHkgZHVlIHRvIGluY29ycmVjdCBub3JtYWxpemF0aW9uIGxvZ2ljIHRoYXQgbGVhdmVzIGEgbm9kZSBpbiBhbiBpbnZhbGlkIHN0YXRlLlwiKSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgYWJvdmUgPSBmdW5jdGlvbiBhYm92ZShlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIge1xuICAgIHZvaWRzID0gZmFsc2UsXG4gICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICBtYXRjaFxuICB9ID0gb3B0aW9ucztcbiAgaWYgKCFhdCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQpO1xuICB2YXIgcmV2ZXJzZSA9IG1vZGUgPT09ICdsb3dlc3QnO1xuICBmb3IgKHZhciBbbiwgcF0gb2YgRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICBhdDogcGF0aCxcbiAgICB2b2lkcyxcbiAgICBtYXRjaCxcbiAgICByZXZlcnNlXG4gIH0pKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KG4pKSBjb250aW51ZTtcbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IocCwgYXQuYW5jaG9yLnBhdGgpICYmIFBhdGguaXNBbmNlc3RvcihwLCBhdC5mb2N1cy5wYXRoKSkge1xuICAgICAgICByZXR1cm4gW24sIHBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIVBhdGguZXF1YWxzKHBhdGgsIHApKSB7XG4gICAgICAgIHJldHVybiBbbiwgcF07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDgoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ4KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkOChPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkOChPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIGFkZE1hcmsgPSAoZWRpdG9yLCBrZXksIHZhbHVlKSA9PiB7XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICB2YXIgbWF0Y2ggPSAobm9kZSwgcGF0aCkgPT4ge1xuICAgICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG1hcmtzIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gdGV4dFxuICAgICAgfVxuXG4gICAgICB2YXIgW3BhcmVudE5vZGUsIHBhcmVudFBhdGhdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuICAgICAgcmV0dXJuICFlZGl0b3IuaXNWb2lkKHBhcmVudE5vZGUpIHx8IGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgfTtcbiAgICB2YXIgZXhwYW5kZWRTZWxlY3Rpb24gPSBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbik7XG4gICAgdmFyIG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIWV4cGFuZGVkU2VsZWN0aW9uKSB7XG4gICAgICB2YXIgW3NlbGVjdGVkTm9kZSwgc2VsZWN0ZWRQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgbWF0Y2goc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGgpKSB7XG4gICAgICAgIHZhciBbcGFyZW50Tm9kZV0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgc2VsZWN0ZWRQYXRoKTtcbiAgICAgICAgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IHBhcmVudE5vZGUgJiYgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4cGFuZGVkU2VsZWN0aW9uIHx8IG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIFtrZXldOiB2YWx1ZVxuICAgICAgfSwge1xuICAgICAgICBtYXRjaCxcbiAgICAgICAgc3BsaXQ6IHRydWUsXG4gICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hcmtzID0gX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30pLCB7fSwge1xuICAgICAgICBba2V5XTogdmFsdWVcbiAgICAgIH0pO1xuICAgICAgZWRpdG9yLm1hcmtzID0gbWFya3M7XG4gICAgICBpZiAoIUZMVVNISU5HLmdldChlZGl0b3IpKSB7XG4gICAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ3KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNyhlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDcoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDcoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBhZnRlciA9IGZ1bmN0aW9uIGFmdGVyKGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgYW5jaG9yID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICBlZGdlOiAnZW5kJ1xuICB9KTtcbiAgdmFyIGZvY3VzID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgdmFyIHJhbmdlID0ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xuICB2YXIge1xuICAgIGRpc3RhbmNlID0gMVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIGQgPSAwO1xuICB2YXIgdGFyZ2V0O1xuICBmb3IgKHZhciBwIG9mIEVkaXRvci5wb3NpdGlvbnMoZWRpdG9yLCBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICBhdDogcmFuZ2VcbiAgfSkpKSB7XG4gICAgaWYgKGQgPiBkaXN0YW5jZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChkICE9PSAwKSB7XG4gICAgICB0YXJnZXQgPSBwO1xuICAgIH1cbiAgICBkKys7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNihlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDYoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ2KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ2KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgYmVmb3JlID0gZnVuY3Rpb24gYmVmb3JlKGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgYW5jaG9yID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pO1xuICB2YXIgZm9jdXMgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgIGVkZ2U6ICdzdGFydCdcbiAgfSk7XG4gIHZhciByYW5nZSA9IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfTtcbiAgdmFyIHtcbiAgICBkaXN0YW5jZSA9IDFcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciBkID0gMDtcbiAgdmFyIHRhcmdldDtcbiAgZm9yICh2YXIgcCBvZiBFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ2KF9vYmplY3RTcHJlYWQkNih7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgYXQ6IHJhbmdlLFxuICAgIHJldmVyc2U6IHRydWVcbiAgfSkpKSB7XG4gICAgaWYgKGQgPiBkaXN0YW5jZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChkICE9PSAwKSB7XG4gICAgICB0YXJnZXQgPSBwO1xuICAgIH1cbiAgICBkKys7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBkZWxldGVCYWNrd2FyZCA9IChlZGl0b3IsIHVuaXQpID0+IHtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICB1bml0LFxuICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgZGVsZXRlRm9yd2FyZCA9IChlZGl0b3IsIHVuaXQpID0+IHtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICB1bml0XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBkZWxldGVGcmFnbWVudCA9IGZ1bmN0aW9uIGRlbGV0ZUZyYWdtZW50KGVkaXRvcikge1xuICB2YXIge1xuICAgIGRpcmVjdGlvbiA9ICdmb3J3YXJkJ1xuICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgIHJldmVyc2U6IGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJ1xuICAgIH0pO1xuICB9XG59O1xuXG52YXIgZWRnZXMgPSAoZWRpdG9yLCBhdCkgPT4ge1xuICByZXR1cm4gW0VkaXRvci5zdGFydChlZGl0b3IsIGF0KSwgRWRpdG9yLmVuZChlZGl0b3IsIGF0KV07XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDUoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ1KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkNShPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkNShPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIGVsZW1lbnRSZWFkT25seSA9IGZ1bmN0aW9uIGVsZW1lbnRSZWFkT25seShlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gRWRpdG9yLmFib3ZlKGVkaXRvciwgX29iamVjdFNwcmVhZCQ1KF9vYmplY3RTcHJlYWQkNSh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzRWxlbWVudFJlYWRPbmx5KGVkaXRvciwgbilcbiAgfSkpO1xufTtcblxudmFyIGVuZCA9IChlZGl0b3IsIGF0KSA9PiB7XG4gIHJldHVybiBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgIGVkZ2U6ICdlbmQnXG4gIH0pO1xufTtcblxudmFyIGZpcnN0ID0gKGVkaXRvciwgYXQpID0+IHtcbiAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ3N0YXJ0J1xuICB9KTtcbiAgcmV0dXJuIEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG59O1xuXG52YXIgZnJhZ21lbnQgPSAoZWRpdG9yLCBhdCkgPT4ge1xuICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gIHJldHVybiBOb2RlLmZyYWdtZW50KGVkaXRvciwgcmFuZ2UpO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ0KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDQoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDQoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBnZXRWb2lkID0gZnVuY3Rpb24gZ2V0Vm9pZChlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gRWRpdG9yLmFib3ZlKGVkaXRvciwgX29iamVjdFNwcmVhZCQ0KF9vYmplY3RTcHJlYWQkNCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pXG4gIH0pKTtcbn07XG5cbnZhciBoYXNCbG9ja3MgPSAoZWRpdG9yLCBlbGVtZW50KSA9PiB7XG4gIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLnNvbWUobiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pKTtcbn07XG5cbnZhciBoYXNJbmxpbmVzID0gKGVkaXRvciwgZWxlbWVudCkgPT4ge1xuICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5zb21lKG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbikpO1xufTtcblxudmFyIGhhc1BhdGggPSAoZWRpdG9yLCBwYXRoKSA9PiB7XG4gIHJldHVybiBOb2RlLmhhcyhlZGl0b3IsIHBhdGgpO1xufTtcblxudmFyIGhhc1RleHRzID0gKGVkaXRvciwgZWxlbWVudCkgPT4ge1xuICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5ldmVyeShuID0+IFRleHQuaXNUZXh0KG4pKTtcbn07XG5cbnZhciBpbnNlcnRCcmVhayA9IGVkaXRvciA9PiB7XG4gIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICBhbHdheXM6IHRydWVcbiAgfSk7XG59O1xuXG52YXIgaW5zZXJ0Tm9kZSA9IChlZGl0b3IsIG5vZGUsIG9wdGlvbnMpID0+IHtcbiAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5vZGUsIG9wdGlvbnMpO1xufTtcblxudmFyIGluc2VydFNvZnRCcmVhayA9IGVkaXRvciA9PiB7XG4gIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICBhbHdheXM6IHRydWVcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQzKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkMyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkMyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIGluc2VydFRleHQgPSBmdW5jdGlvbiBpbnNlcnRUZXh0KGVkaXRvciwgdGV4dCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uLFxuICAgIG1hcmtzXG4gIH0gPSBlZGl0b3I7XG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICBpZiAobWFya3MpIHtcbiAgICAgIHZhciBub2RlID0gX29iamVjdFNwcmVhZCQzKHtcbiAgICAgICAgdGV4dFxuICAgICAgfSwgbWFya3MpO1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5vZGUsIHtcbiAgICAgICAgYXQ6IG9wdGlvbnMuYXQsXG4gICAgICAgIHZvaWRzOiBvcHRpb25zLnZvaWRzXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KGVkaXRvciwgdGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVkaXRvci5tYXJrcyA9IG51bGw7XG4gIH1cbn07XG5cbnZhciBpc0Jsb2NrID0gKGVkaXRvciwgdmFsdWUpID0+IHtcbiAgcmV0dXJuICFlZGl0b3IuaXNJbmxpbmUodmFsdWUpO1xufTtcblxudmFyIGlzRWRnZSA9IChlZGl0b3IsIHBvaW50LCBhdCkgPT4ge1xuICByZXR1cm4gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBwb2ludCwgYXQpIHx8IEVkaXRvci5pc0VuZChlZGl0b3IsIHBvaW50LCBhdCk7XG59O1xuXG52YXIgaXNFbXB0eSA9IChlZGl0b3IsIGVsZW1lbnQpID0+IHtcbiAgdmFyIHtcbiAgICBjaGlsZHJlblxuICB9ID0gZWxlbWVudDtcbiAgdmFyIFtmaXJzdF0gPSBjaGlsZHJlbjtcbiAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgVGV4dC5pc1RleHQoZmlyc3QpICYmIGZpcnN0LnRleHQgPT09ICcnICYmICFlZGl0b3IuaXNWb2lkKGVsZW1lbnQpO1xufTtcblxudmFyIGlzRW5kID0gKGVkaXRvciwgcG9pbnQsIGF0KSA9PiB7XG4gIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgYXQpO1xuICByZXR1cm4gUG9pbnQuZXF1YWxzKHBvaW50LCBlbmQpO1xufTtcblxudmFyIGlzTm9ybWFsaXppbmcgPSBlZGl0b3IgPT4ge1xuICB2YXIgaXNOb3JtYWxpemluZyA9IE5PUk1BTElaSU5HLmdldChlZGl0b3IpO1xuICByZXR1cm4gaXNOb3JtYWxpemluZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlzTm9ybWFsaXppbmc7XG59O1xuXG52YXIgaXNTdGFydCA9IChlZGl0b3IsIHBvaW50LCBhdCkgPT4ge1xuICAvLyBQRVJGOiBJZiB0aGUgb2Zmc2V0IGlzbid0IGAwYCB3ZSBrbm93IGl0J3Mgbm90IHRoZSBzdGFydC5cbiAgaWYgKHBvaW50Lm9mZnNldCAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gIHJldHVybiBQb2ludC5lcXVhbHMocG9pbnQsIHN0YXJ0KTtcbn07XG5cbnZhciBsYXN0ID0gKGVkaXRvciwgYXQpID0+IHtcbiAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgZWRnZTogJ2VuZCdcbiAgfSk7XG4gIHJldHVybiBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xufTtcblxudmFyIGxlYWYgPSBmdW5jdGlvbiBsZWFmKGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICB2YXIgbm9kZSA9IE5vZGUubGVhZihlZGl0b3IsIHBhdGgpO1xuICByZXR1cm4gW25vZGUsIHBhdGhdO1xufTtcblxuZnVuY3Rpb24gbGV2ZWxzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gKCkgPT4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGV2ZWxzID0gW107XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0KTtcbiAgICBmb3IgKHZhciBbbiwgcF0gb2YgTm9kZS5sZXZlbHMoZWRpdG9yLCBwYXRoKSkge1xuICAgICAgaWYgKCFtYXRjaChuLCBwKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldmVscy5wdXNoKFtuLCBwXSk7XG4gICAgICBpZiAoIXZvaWRzICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGxldmVscy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHlpZWxkKiBsZXZlbHM7XG4gIH0oKTtcbn1cblxudmFyIF9leGNsdWRlZCQxID0gW1widGV4dFwiXSxcbiAgX2V4Y2x1ZGVkMiQxID0gW1widGV4dFwiXTtcbnZhciBtYXJrcyA9IGZ1bmN0aW9uIG1hcmtzKGVkaXRvcikge1xuICB2YXIge1xuICAgIG1hcmtzLFxuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICBpZiAoIXNlbGVjdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChtYXJrcykge1xuICAgIHJldHVybiBtYXJrcztcbiAgfVxuICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgdmFyIFttYXRjaF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBtYXRjaDogVGV4dC5pc1RleHRcbiAgICB9KTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciBbX25vZGVdID0gbWF0Y2g7XG4gICAgICB2YXIgX3Jlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX25vZGUsIF9leGNsdWRlZCQxKTtcbiAgICAgIHJldHVybiBfcmVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfVxuICB2YXIge1xuICAgIGFuY2hvclxuICB9ID0gc2VsZWN0aW9uO1xuICB2YXIge1xuICAgIHBhdGhcbiAgfSA9IGFuY2hvcjtcbiAgdmFyIFtub2RlXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgcGF0aCk7XG4gIGlmIChhbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgdmFyIHByZXYgPSBFZGl0b3IucHJldmlvdXMoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aCxcbiAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dFxuICAgIH0pO1xuICAgIHZhciBtYXJrZWRWb2lkID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pICYmIGVkaXRvci5tYXJrYWJsZVZvaWQobilcbiAgICB9KTtcbiAgICBpZiAoIW1hcmtlZFZvaWQpIHtcbiAgICAgIHZhciBibG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKVxuICAgICAgfSk7XG4gICAgICBpZiAocHJldiAmJiBibG9jaykge1xuICAgICAgICB2YXIgW3ByZXZOb2RlLCBwcmV2UGF0aF0gPSBwcmV2O1xuICAgICAgICB2YXIgWywgYmxvY2tQYXRoXSA9IGJsb2NrO1xuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKGJsb2NrUGF0aCwgcHJldlBhdGgpKSB7XG4gICAgICAgICAgbm9kZSA9IHByZXZOb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZDIkMSk7XG4gIHJldHVybiByZXN0O1xufTtcblxudmFyIG5leHQgPSBmdW5jdGlvbiBuZXh0KGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciB7XG4gICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgIHZvaWRzID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciB7XG4gICAgbWF0Y2gsXG4gICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIWF0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBwb2ludEFmdGVyTG9jYXRpb24gPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhdCwge1xuICAgIHZvaWRzXG4gIH0pO1xuICBpZiAoIXBvaW50QWZ0ZXJMb2NhdGlvbikgcmV0dXJuO1xuICB2YXIgWywgdG9dID0gRWRpdG9yLmxhc3QoZWRpdG9yLCBbXSk7XG4gIHZhciBzcGFuID0gW3BvaW50QWZ0ZXJMb2NhdGlvbi5wYXRoLCB0b107XG4gIGlmIChQYXRoLmlzUGF0aChhdCkgJiYgYXQubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgbmV4dCBub2RlIGZyb20gdGhlIHJvb3Qgbm9kZSFcIik7XG4gIH1cbiAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpO1xuICAgICAgbWF0Y2ggPSBuID0+IHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgIH1cbiAgfVxuICB2YXIgW25leHRdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIGF0OiBzcGFuLFxuICAgIG1hdGNoLFxuICAgIG1vZGUsXG4gICAgdm9pZHNcbiAgfSk7XG4gIHJldHVybiBuZXh0O1xufTtcblxudmFyIG5vZGUgPSBmdW5jdGlvbiBub2RlKGVkaXRvciwgYXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gIHJldHVybiBbbm9kZSwgcGF0aF07XG59O1xuXG5mdW5jdGlvbiBub2RlcyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICB2YXIge1xuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgbW9kZSA9ICdhbGwnLFxuICAgICAgdW5pdmVyc2FsID0gZmFsc2UsXG4gICAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgaWdub3JlTm9uU2VsZWN0YWJsZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAoU3Bhbi5pc1NwYW4oYXQpKSB7XG4gICAgICBmcm9tID0gYXRbMF07XG4gICAgICB0byA9IGF0WzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlyc3QgPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICAgIH0pO1xuICAgICAgdmFyIGxhc3QgPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgICAgIGVkZ2U6ICdlbmQnXG4gICAgICB9KTtcbiAgICAgIGZyb20gPSByZXZlcnNlID8gbGFzdCA6IGZpcnN0O1xuICAgICAgdG8gPSByZXZlcnNlID8gZmlyc3QgOiBsYXN0O1xuICAgIH1cbiAgICB2YXIgbm9kZUVudHJpZXMgPSBOb2RlLm5vZGVzKGVkaXRvciwge1xuICAgICAgcmV2ZXJzZSxcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICAgIHBhc3M6IF9yZWYgPT4ge1xuICAgICAgICB2YXIgW25vZGVdID0gX3JlZjtcbiAgICAgICAgaWYgKCFFbGVtZW50LmlzRWxlbWVudChub2RlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXZvaWRzICYmIChFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkgfHwgRWRpdG9yLmlzRWxlbWVudFJlYWRPbmx5KGVkaXRvciwgbm9kZSkpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGlnbm9yZU5vblNlbGVjdGFibGUgJiYgIUVkaXRvci5pc1NlbGVjdGFibGUoZWRpdG9yLCBub2RlKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBoaXQ7XG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIG5vZGVFbnRyaWVzKSB7XG4gICAgICBpZiAoaWdub3JlTm9uU2VsZWN0YWJsZSAmJiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiAhRWRpdG9yLmlzU2VsZWN0YWJsZShlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGlzTG93ZXIgPSBoaXQgJiYgUGF0aC5jb21wYXJlKHBhdGgsIGhpdFsxXSkgPT09IDA7XG4gICAgICAvLyBJbiBoaWdoZXN0IG1vZGUgYW55IG5vZGUgbG93ZXIgdGhhbiB0aGUgbGFzdCBoaXQgaXMgbm90IGEgbWF0Y2guXG4gICAgICBpZiAobW9kZSA9PT0gJ2hpZ2hlc3QnICYmIGlzTG93ZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIW1hdGNoKG5vZGUsIHBhdGgpKSB7XG4gICAgICAgIC8vIElmIHdlJ3ZlIGFycml2ZWQgYXQgYSBsZWFmIHRleHQgbm9kZSB0aGF0IGlzIG5vdCBsb3dlciB0aGFuIHRoZSBsYXN0XG4gICAgICAgIC8vIGhpdCwgdGhlbiB3ZSd2ZSBmb3VuZCBhIGJyYW5jaCB0aGF0IGRvZXNuJ3QgaW5jbHVkZSBhIG1hdGNoLCB3aGljaFxuICAgICAgICAvLyBtZWFucyB0aGUgbWF0Y2ggaXMgbm90IHVuaXZlcnNhbC5cbiAgICAgICAgaWYgKHVuaXZlcnNhbCAmJiAhaXNMb3dlciAmJiBUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gSWYgdGhlcmUncyBhIG1hdGNoIGFuZCBpdCdzIGxvd2VyIHRoYW4gdGhlIGxhc3QsIHVwZGF0ZSB0aGUgaGl0LlxuICAgICAgaWYgKG1vZGUgPT09ICdsb3dlc3QnICYmIGlzTG93ZXIpIHtcbiAgICAgICAgaGl0ID0gW25vZGUsIHBhdGhdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIEluIGxvd2VzdCBtb2RlIHdlIGVtaXQgdGhlIGxhc3QgaGl0LCBvbmNlIGl0J3MgZ3VhcmFudGVlZCBsb3dlc3QuXG4gICAgICB2YXIgZW1pdCA9IG1vZGUgPT09ICdsb3dlc3QnID8gaGl0IDogW25vZGUsIHBhdGhdO1xuICAgICAgaWYgKGVtaXQpIHtcbiAgICAgICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChlbWl0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCBlbWl0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoaXQgPSBbbm9kZSwgcGF0aF07XG4gICAgfVxuICAgIC8vIFNpbmNlIGxvd2VzdCBpcyBhbHdheXMgZW1pdHRpbmcgb25lIGJlaGluZCwgY2F0Y2ggdXAgYXQgdGhlIGVuZC5cbiAgICBpZiAobW9kZSA9PT0gJ2xvd2VzdCcgJiYgaGl0KSB7XG4gICAgICBpZiAodW5pdmVyc2FsKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChoaXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQgaGl0O1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBVbml2ZXJzYWwgZGVmZXJzIHRvIGVuc3VyZSB0aGF0IHRoZSBtYXRjaCBvY2N1cnMgaW4gZXZlcnkgYnJhbmNoLCBzbyB3ZVxuICAgIC8vIHlpZWxkIGFsbCBvZiB0aGUgbWF0Y2hlcyBhZnRlciBpdGVyYXRpbmcuXG4gICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgeWllbGQqIG1hdGNoZXM7XG4gICAgfVxuICB9KCk7XG59XG5cbnZhciBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHtcbiAgICBmb3JjZSA9IGZhbHNlLFxuICAgIG9wZXJhdGlvblxuICB9ID0gb3B0aW9ucztcbiAgdmFyIGdldERpcnR5UGF0aHMgPSBlZGl0b3IgPT4ge1xuICAgIHJldHVybiBESVJUWV9QQVRIUy5nZXQoZWRpdG9yKSB8fCBbXTtcbiAgfTtcbiAgdmFyIGdldERpcnR5UGF0aEtleXMgPSBlZGl0b3IgPT4ge1xuICAgIHJldHVybiBESVJUWV9QQVRIX0tFWVMuZ2V0KGVkaXRvcikgfHwgbmV3IFNldCgpO1xuICB9O1xuICB2YXIgcG9wRGlydHlQYXRoID0gZWRpdG9yID0+IHtcbiAgICB2YXIgcGF0aCA9IGdldERpcnR5UGF0aHMoZWRpdG9yKS5wb3AoKTtcbiAgICB2YXIga2V5ID0gcGF0aC5qb2luKCcsJyk7XG4gICAgZ2V0RGlydHlQYXRoS2V5cyhlZGl0b3IpLmRlbGV0ZShrZXkpO1xuICAgIHJldHVybiBwYXRoO1xuICB9O1xuICBpZiAoIUVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZvcmNlKSB7XG4gICAgdmFyIGFsbFBhdGhzID0gQXJyYXkuZnJvbShOb2RlLm5vZGVzKGVkaXRvciksIF9yZWYgPT4ge1xuICAgICAgdmFyIFssIHBdID0gX3JlZjtcbiAgICAgIHJldHVybiBwO1xuICAgIH0pO1xuICAgIHZhciBhbGxQYXRoS2V5cyA9IG5ldyBTZXQoYWxsUGF0aHMubWFwKHAgPT4gcC5qb2luKCcsJykpKTtcbiAgICBESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCBhbGxQYXRocyk7XG4gICAgRElSVFlfUEFUSF9LRVlTLnNldChlZGl0b3IsIGFsbFBhdGhLZXlzKTtcbiAgfVxuICBpZiAoZ2V0RGlydHlQYXRocyhlZGl0b3IpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIC8qXG4gICAgICBGaXggZGlydHkgZWxlbWVudHMgd2l0aCBubyBjaGlsZHJlbi5cbiAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKCkgZG9lcyBmaXggdGhpcywgYnV0IHNvbWUgbm9ybWFsaXphdGlvbiBmaXhlcyBhbHNvIHJlcXVpcmUgaXQgdG8gd29yay5cbiAgICAgIFJ1bm5pbmcgYW4gaW5pdGlhbCBwYXNzIGF2b2lkcyB0aGUgY2F0Y2gtMjIgcmFjZSBjb25kaXRpb24uXG4gICAgKi9cbiAgICBmb3IgKHZhciBkaXJ0eVBhdGggb2YgZ2V0RGlydHlQYXRocyhlZGl0b3IpKSB7XG4gICAgICBpZiAoTm9kZS5oYXMoZWRpdG9yLCBkaXJ0eVBhdGgpKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgZGlydHlQYXRoKTtcbiAgICAgICAgdmFyIFtub2RlLCBfXSA9IGVudHJ5O1xuICAgICAgICAvKlxuICAgICAgICAgIFRoZSBkZWZhdWx0IG5vcm1hbGl6ZXIgaW5zZXJ0cyBhbiBlbXB0eSB0ZXh0IG5vZGUgaW4gdGhpcyBzY2VuYXJpbywgYnV0IGl0IGNhbiBiZSBjdXN0b21pc2VkLlxuICAgICAgICAgIFNvIHRoZXJlIGlzIHNvbWUgcmlzayBoZXJlLlxuICAgICAgICAgICAgICAgICAgIEFzIGxvbmcgYXMgdGhlIG5vcm1hbGl6ZXIgb25seSBpbnNlcnRzIGNoaWxkIG5vZGVzIGZvciB0aGlzIGNhc2UgaXQgaXMgc2FmZSB0byBkbyBpbiBhbnkgb3JkZXI7XG4gICAgICAgICAgYnkgZGVmaW5pdGlvbiBhZGRpbmcgY2hpbGRyZW4gdG8gYW4gZW1wdHkgbm9kZSBjYW4ndCBjYXVzZSBvdGhlciBwYXRocyB0byBjaGFuZ2UuXG4gICAgICAgICovXG4gICAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKGVudHJ5LCB7XG4gICAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZGlydHlQYXRocyA9IGdldERpcnR5UGF0aHMoZWRpdG9yKTtcbiAgICB2YXIgaW5pdGlhbERpcnR5UGF0aHNMZW5ndGggPSBkaXJ0eVBhdGhzLmxlbmd0aDtcbiAgICB2YXIgaXRlcmF0aW9uID0gMDtcbiAgICB3aGlsZSAoZGlydHlQYXRocy5sZW5ndGggIT09IDApIHtcbiAgICAgIGlmICghZWRpdG9yLnNob3VsZE5vcm1hbGl6ZSh7XG4gICAgICAgIGRpcnR5UGF0aHMsXG4gICAgICAgIGl0ZXJhdGlvbixcbiAgICAgICAgaW5pdGlhbERpcnR5UGF0aHNMZW5ndGgsXG4gICAgICAgIG9wZXJhdGlvblxuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIF9kaXJ0eVBhdGggPSBwb3BEaXJ0eVBhdGgoZWRpdG9yKTtcbiAgICAgIC8vIElmIHRoZSBub2RlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHRyZWUsIGl0IGRvZXMgbm90IG5lZWQgdG8gYmUgbm9ybWFsaXplZC5cbiAgICAgIGlmIChOb2RlLmhhcyhlZGl0b3IsIF9kaXJ0eVBhdGgpKSB7XG4gICAgICAgIHZhciBfZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIF9kaXJ0eVBhdGgpO1xuICAgICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZShfZW50cnksIHtcbiAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpdGVyYXRpb24rKztcbiAgICAgIGRpcnR5UGF0aHMgPSBnZXREaXJ0eVBhdGhzKGVkaXRvcik7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBwYXJlbnQgPSBmdW5jdGlvbiBwYXJlbnQoZWRpdG9yLCBhdCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucyk7XG4gIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gIHZhciBlbnRyeSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGFyZW50UGF0aCk7XG4gIHJldHVybiBlbnRyeTtcbn07XG5cbnZhciBwYXRoUmVmID0gZnVuY3Rpb24gcGF0aFJlZihlZGl0b3IsIHBhdGgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIge1xuICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gIH0gPSBvcHRpb25zO1xuICB2YXIgcmVmID0ge1xuICAgIGN1cnJlbnQ6IHBhdGgsXG4gICAgYWZmaW5pdHksXG4gICAgdW5yZWYoKSB7XG4gICAgICB2YXIge1xuICAgICAgICBjdXJyZW50XG4gICAgICB9ID0gcmVmO1xuICAgICAgdmFyIHBhdGhSZWZzID0gRWRpdG9yLnBhdGhSZWZzKGVkaXRvcik7XG4gICAgICBwYXRoUmVmcy5kZWxldGUocmVmKTtcbiAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgfTtcbiAgdmFyIHJlZnMgPSBFZGl0b3IucGF0aFJlZnMoZWRpdG9yKTtcbiAgcmVmcy5hZGQocmVmKTtcbiAgcmV0dXJuIHJlZjtcbn07XG5cbnZhciBwYXRoUmVmcyA9IGVkaXRvciA9PiB7XG4gIHZhciByZWZzID0gUEFUSF9SRUZTLmdldChlZGl0b3IpO1xuICBpZiAoIXJlZnMpIHtcbiAgICByZWZzID0gbmV3IFNldCgpO1xuICAgIFBBVEhfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgfVxuICByZXR1cm4gcmVmcztcbn07XG5cbnZhciBwYXRoID0gZnVuY3Rpb24gcGF0aChlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICBkZXB0aCxcbiAgICBlZGdlXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gTm9kZS5maXJzdChlZGl0b3IsIGF0KTtcbiAgICAgIGF0ID0gZmlyc3RQYXRoO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIHZhciBbLCBsYXN0UGF0aF0gPSBOb2RlLmxhc3QoZWRpdG9yLCBhdCk7XG4gICAgICBhdCA9IGxhc3RQYXRoO1xuICAgIH1cbiAgfVxuICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgYXQgPSBSYW5nZS5zdGFydChhdCk7XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgYXQgPSBSYW5nZS5lbmQoYXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdCA9IFBhdGguY29tbW9uKGF0LmFuY2hvci5wYXRoLCBhdC5mb2N1cy5wYXRoKTtcbiAgICB9XG4gIH1cbiAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgYXQgPSBhdC5wYXRoO1xuICB9XG4gIGlmIChkZXB0aCAhPSBudWxsKSB7XG4gICAgYXQgPSBhdC5zbGljZSgwLCBkZXB0aCk7XG4gIH1cbiAgcmV0dXJuIGF0O1xufTtcblxudmFyIHBvaW50UmVmID0gZnVuY3Rpb24gcG9pbnRSZWYoZWRpdG9yLCBwb2ludCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciByZWYgPSB7XG4gICAgY3VycmVudDogcG9pbnQsXG4gICAgYWZmaW5pdHksXG4gICAgdW5yZWYoKSB7XG4gICAgICB2YXIge1xuICAgICAgICBjdXJyZW50XG4gICAgICB9ID0gcmVmO1xuICAgICAgdmFyIHBvaW50UmVmcyA9IEVkaXRvci5wb2ludFJlZnMoZWRpdG9yKTtcbiAgICAgIHBvaW50UmVmcy5kZWxldGUocmVmKTtcbiAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgfTtcbiAgdmFyIHJlZnMgPSBFZGl0b3IucG9pbnRSZWZzKGVkaXRvcik7XG4gIHJlZnMuYWRkKHJlZik7XG4gIHJldHVybiByZWY7XG59O1xuXG52YXIgcG9pbnRSZWZzID0gZWRpdG9yID0+IHtcbiAgdmFyIHJlZnMgPSBQT0lOVF9SRUZTLmdldChlZGl0b3IpO1xuICBpZiAoIXJlZnMpIHtcbiAgICByZWZzID0gbmV3IFNldCgpO1xuICAgIFBPSU5UX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gIH1cbiAgcmV0dXJuIHJlZnM7XG59O1xuXG52YXIgcG9pbnQgPSBmdW5jdGlvbiBwb2ludChlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICBlZGdlID0gJ3N0YXJ0J1xuICB9ID0gb3B0aW9ucztcbiAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgIHZhciBwYXRoO1xuICAgIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgdmFyIFssIGxhc3RQYXRoXSA9IE5vZGUubGFzdChlZGl0b3IsIGF0KTtcbiAgICAgIHBhdGggPSBsYXN0UGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIFssIGZpcnN0UGF0aF0gPSBOb2RlLmZpcnN0KGVkaXRvciwgYXQpO1xuICAgICAgcGF0aCA9IGZpcnN0UGF0aDtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIFwiLmNvbmNhdChlZGdlLCBcIiBwb2ludCBpbiB0aGUgbm9kZSBhdCBwYXRoIFtcIikuY29uY2F0KGF0LCBcIl0gYmVjYXVzZSBpdCBoYXMgbm8gXCIpLmNvbmNhdChlZGdlLCBcIiB0ZXh0IG5vZGUuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBvZmZzZXQ6IGVkZ2UgPT09ICdlbmQnID8gbm9kZS50ZXh0Lmxlbmd0aCA6IDBcbiAgICB9O1xuICB9XG4gIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgcmV0dXJuIGVkZ2UgPT09ICdzdGFydCcgPyBzdGFydCA6IGVuZDtcbiAgfVxuICByZXR1cm4gYXQ7XG59O1xuXG5mdW5jdGlvbiBwb3NpdGlvbnMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgdmFyIHtcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIHVuaXQgPSAnb2Zmc2V0JyxcbiAgICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2UsXG4gICAgICBpZ25vcmVOb25TZWxlY3RhYmxlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsZ29yaXRobSBub3RlczpcbiAgICAgKlxuICAgICAqIEVhY2ggc3RlcCBgZGlzdGFuY2VgIGlzIGR5bmFtaWMgZGVwZW5kaW5nIG9uIHRoZSB1bmRlcmx5aW5nIHRleHRcbiAgICAgKiBhbmQgdGhlIGB1bml0YCBzcGVjaWZpZWQuICBFYWNoIHN0ZXAsIGUuZy4sIGEgbGluZSBvciB3b3JkLCBtYXlcbiAgICAgKiBzcGFuIG11bHRpcGxlIHRleHQgbm9kZXMsIHNvIHdlIGl0ZXJhdGUgdGhyb3VnaCB0aGUgdGV4dCBib3RoIG9uXG4gICAgICogdHdvIGxldmVscyBpbiBzdGVwLXN5bmM6XG4gICAgICpcbiAgICAgKiBgbGVhZlRleHRgIHN0b3JlcyB0aGUgdGV4dCBvbiBhIHRleHQgbGVhZiBsZXZlbCwgYW5kIGlzIGFkdmFuY2VkXG4gICAgICogdGhyb3VnaCB1c2luZyB0aGUgY291bnRlcnMgYGxlYWZUZXh0T2Zmc2V0YCBhbmQgYGxlYWZUZXh0UmVtYWluaW5nYC5cbiAgICAgKlxuICAgICAqIGBibG9ja1RleHRgIHN0b3JlcyB0aGUgdGV4dCBvbiBhIGJsb2NrIGxldmVsLCBhbmQgaXMgc2hvcnRlbmVkXG4gICAgICogYnkgYGRpc3RhbmNlYCBldmVyeSB0aW1lIGl0IGlzIGFkdmFuY2VkLlxuICAgICAqXG4gICAgICogV2Ugb25seSBtYWludGFpbiBhIHdpbmRvdyBvZiBvbmUgYmxvY2tUZXh0IGFuZCBvbmUgbGVhZlRleHQgYmVjYXVzZVxuICAgICAqIGEgYmxvY2sgbm9kZSBhbHdheXMgYXBwZWFycyBiZWZvcmUgYWxsIG9mIGl0cyBsZWFmIG5vZGVzLlxuICAgICAqL1xuICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHZhciBmaXJzdCA9IHJldmVyc2UgPyBlbmQgOiBzdGFydDtcbiAgICB2YXIgaXNOZXdCbG9jayA9IGZhbHNlO1xuICAgIHZhciBibG9ja1RleHQgPSAnJztcbiAgICB2YXIgZGlzdGFuY2UgPSAwOyAvLyBEaXN0YW5jZSBmb3IgbGVhZlRleHQgdG8gY2F0Y2ggdXAgdG8gYmxvY2tUZXh0LlxuICAgIHZhciBsZWFmVGV4dFJlbWFpbmluZyA9IDA7XG4gICAgdmFyIGxlYWZUZXh0T2Zmc2V0ID0gMDtcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggYWxsIG5vZGVzIGluIHJhbmdlLCBncmFiYmluZyBlbnRpcmUgdGV4dHVhbCBjb250ZW50XG4gICAgLy8gb2YgYmxvY2sgbm9kZXMgaW4gYmxvY2tUZXh0LCBhbmQgdGV4dCBub2RlcyBpbiBsZWFmVGV4dC5cbiAgICAvLyBFeHBsb2l0cyB0aGUgZmFjdCB0aGF0IG5vZGVzIGFyZSBzZXF1ZW5jZWQgaW4gc3VjaCBhIHdheSB0aGF0IHdlIGZpcnN0XG4gICAgLy8gZW5jb3VudGVyIHRoZSBibG9jayBub2RlLCB0aGVuIGFsbCBvZiBpdHMgdGV4dCBub2Rlcywgc28gd2hlbiBpdGVyYXRpbmdcbiAgICAvLyB0aHJvdWdoIHRoZSBibG9ja1RleHQgYW5kIGxlYWZUZXh0IHdlIGp1c3QgbmVlZCB0byByZW1lbWJlciBhIHdpbmRvdyBvZlxuICAgIC8vIG9uZSBibG9jayBub2RlIGFuZCBsZWFmIG5vZGUsIHJlc3BlY3RpdmVseS5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICByZXZlcnNlLFxuICAgICAgdm9pZHMsXG4gICAgICBpZ25vcmVOb25TZWxlY3RhYmxlXG4gICAgfSkpIHtcbiAgICAgIC8qXG4gICAgICAgKiBFTEVNRU5UIE5PREUgLSBZaWVsZCBwb3NpdGlvbihzKSBmb3Igdm9pZHMsIGNvbGxlY3QgYmxvY2tUZXh0IGZvciBibG9ja3NcbiAgICAgICAqL1xuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgIC8vIFZvaWQgbm9kZXMgYXJlIGEgc3BlY2lhbCBjYXNlLCBzbyBieSBkZWZhdWx0IHdlIHdpbGwgYWx3YXlzXG4gICAgICAgIC8vIHlpZWxkIHRoZWlyIGZpcnN0IHBvaW50LiBJZiB0aGUgYHZvaWRzYCBvcHRpb24gaXMgc2V0IHRvIHRydWUsXG4gICAgICAgIC8vIHRoZW4gd2Ugd2lsbCBpdGVyYXRlIG92ZXIgdGhlaXIgY29udGVudC5cbiAgICAgICAgaWYgKCF2b2lkcyAmJiAoZWRpdG9yLmlzVm9pZChub2RlKSB8fCBlZGl0b3IuaXNFbGVtZW50UmVhZE9ubHkobm9kZSkpKSB7XG4gICAgICAgICAgeWllbGQgRWRpdG9yLnN0YXJ0KGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5saW5lIGVsZW1lbnQgbm9kZXMgYXJlIGlnbm9yZWQgYXMgdGhleSBkb24ndCB0aGVtc2VsdmVzXG4gICAgICAgIC8vIGNvbnRyaWJ1dGUgdG8gYGJsb2NrVGV4dGAgb3IgYGxlYWZUZXh0YCAtIHRoZWlyIHBhcmVudCBhbmRcbiAgICAgICAgLy8gY2hpbGRyZW4gZG8uXG4gICAgICAgIGlmIChlZGl0b3IuaXNJbmxpbmUobm9kZSkpIGNvbnRpbnVlO1xuICAgICAgICAvLyBCbG9jayBlbGVtZW50IG5vZGUgLSBzZXQgYGJsb2NrVGV4dGAgdG8gaXRzIHRleHQgY29udGVudC5cbiAgICAgICAgaWYgKEVkaXRvci5oYXNJbmxpbmVzKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICAvLyBXZSBhbHdheXMgZXhoYXVzdCBibG9jayBub2RlcyBiZWZvcmUgZW5jb3VudGVyaW5nIGEgbmV3IG9uZTpcbiAgICAgICAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGJsb2NrVGV4dCA9PT0gJycsXG4gICAgICAgICAgLy8gICAgIGBibG9ja1RleHQ9JyR7YmxvY2tUZXh0fScgLSBgK1xuICAgICAgICAgIC8vICAgICBgbm90IGV4aGF1c3RlZCBiZWZvcmUgbmV3IGJsb2NrIG5vZGVgLCBwYXRoKVxuICAgICAgICAgIC8vIEVuc3VyZSByYW5nZSBjb25zaWRlcmVkIGlzIGNhcHBlZCB0byBgcmFuZ2VgLCBpbiB0aGVcbiAgICAgICAgICAvLyBzdGFydC9lbmQgZWRnZSBjYXNlcyB3aGVyZSBibG9jayBleHRlbmRzIGJleW9uZCByYW5nZS5cbiAgICAgICAgICAvLyBFcXVpdmFsZW50IHRvIHRoaXMsIGJ1dCBwcmVzdW1hYmx5IG1vcmUgcGVyZm9ybWFudDpcbiAgICAgICAgICAvLyAgIGJsb2NrUmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCAuLi5FZGl0b3IuZWRnZXMoZWRpdG9yLCBwYXRoKSlcbiAgICAgICAgICAvLyAgIGJsb2NrUmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2UsIGJsb2NrUmFuZ2UpIC8vIGludGVyc2VjdFxuICAgICAgICAgIC8vICAgYmxvY2tUZXh0ID0gRWRpdG9yLnN0cmluZyhlZGl0b3IsIGJsb2NrUmFuZ2UsIHsgdm9pZHMgfSlcbiAgICAgICAgICB2YXIgZSA9IFBhdGguaXNBbmNlc3RvcihwYXRoLCBlbmQucGF0aCkgPyBlbmQgOiBFZGl0b3IuZW5kKGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgdmFyIHMgPSBQYXRoLmlzQW5jZXN0b3IocGF0aCwgc3RhcnQucGF0aCkgPyBzdGFydCA6IEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIGJsb2NrVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCB7XG4gICAgICAgICAgICBhbmNob3I6IHMsXG4gICAgICAgICAgICBmb2N1czogZVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaXNOZXdCbG9jayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qXG4gICAgICAgKiBURVhUIExFQUYgTk9ERSAtIEl0ZXJhdGUgdGhyb3VnaCB0ZXh0IGNvbnRlbnQsIHlpZWxkaW5nXG4gICAgICAgKiBwb3NpdGlvbnMgZXZlcnkgYGRpc3RhbmNlYCBvZmZzZXQgYWNjb3JkaW5nIHRvIGB1bml0YC5cbiAgICAgICAqL1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHZhciBpc0ZpcnN0ID0gUGF0aC5lcXVhbHMocGF0aCwgZmlyc3QucGF0aCk7XG4gICAgICAgIC8vIFByb29mIHRoYXQgd2UgYWx3YXlzIGV4aGF1c3QgdGV4dCBub2RlcyBiZWZvcmUgZW5jb3VudGVyaW5nIGEgbmV3IG9uZTpcbiAgICAgICAgLy8gICBjb25zb2xlLmFzc2VydChsZWFmVGV4dFJlbWFpbmluZyA8PSAwLFxuICAgICAgICAvLyAgICAgYGxlYWZUZXh0UmVtYWluaW5nPSR7bGVhZlRleHRSZW1haW5pbmd9IC0gYCtcbiAgICAgICAgLy8gICAgIGBub3QgZXhoYXVzdGVkIGJlZm9yZSBuZXcgbGVhZiB0ZXh0IG5vZGVgLCBwYXRoKVxuICAgICAgICAvLyBSZXNldCBgbGVhZlRleHRgIGNvdW50ZXJzIGZvciBuZXcgdGV4dCBub2RlLlxuICAgICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gcmV2ZXJzZSA/IGZpcnN0Lm9mZnNldCA6IG5vZGUudGV4dC5sZW5ndGggLSBmaXJzdC5vZmZzZXQ7XG4gICAgICAgICAgbGVhZlRleHRPZmZzZXQgPSBmaXJzdC5vZmZzZXQ7IC8vIFdvcmtzIGZvciByZXZlcnNlIHRvby5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZWFmVGV4dFJlbWFpbmluZyA9IG5vZGUudGV4dC5sZW5ndGg7XG4gICAgICAgICAgbGVhZlRleHRPZmZzZXQgPSByZXZlcnNlID8gbGVhZlRleHRSZW1haW5pbmcgOiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFlpZWxkIHBvc2l0aW9uIGF0IHRoZSBzdGFydCBvZiBub2RlIChwb3RlbnRpYWxseSkuXG4gICAgICAgIGlmIChpc0ZpcnN0IHx8IGlzTmV3QmxvY2sgfHwgdW5pdCA9PT0gJ29mZnNldCcpIHtcbiAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgb2Zmc2V0OiBsZWFmVGV4dE9mZnNldFxuICAgICAgICAgIH07XG4gICAgICAgICAgaXNOZXdCbG9jayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFlpZWxkIHBvc2l0aW9ucyBldmVyeSAoZHluYW1pY2FsbHkgY2FsY3VsYXRlZCkgYGRpc3RhbmNlYCBvZmZzZXQuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgLy8gSWYgYGxlYWZUZXh0YCBoYXMgY2F1Z2h0IHVwIHdpdGggYGJsb2NrVGV4dGAgKGRpc3RhbmNlPTApLFxuICAgICAgICAgIC8vIGFuZCBpZiBibG9ja1RleHQgaXMgZXhoYXVzdGVkLCBicmVhayB0byBnZXQgYW5vdGhlciBibG9jayBub2RlLFxuICAgICAgICAgIC8vIG90aGVyd2lzZSBhZHZhbmNlIGJsb2NrVGV4dCBmb3J3YXJkIGJ5IHRoZSBuZXcgYGRpc3RhbmNlYC5cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChibG9ja1RleHQgPT09ICcnKSBicmVhaztcbiAgICAgICAgICAgIGRpc3RhbmNlID0gY2FsY0Rpc3RhbmNlKGJsb2NrVGV4dCwgdW5pdCwgcmV2ZXJzZSk7XG4gICAgICAgICAgICAvLyBTcGxpdCB0aGUgc3RyaW5nIGF0IHRoZSBwcmV2aW91c2x5IGZvdW5kIGRpc3RhbmNlIGFuZCB1c2UgdGhlXG4gICAgICAgICAgICAvLyByZW1haW5pbmcgc3RyaW5nIGZvciB0aGUgbmV4dCBpdGVyYXRpb24uXG4gICAgICAgICAgICBibG9ja1RleHQgPSBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UoYmxvY2tUZXh0LCBkaXN0YW5jZSwgcmV2ZXJzZSlbMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFkdmFuY2UgYGxlYWZUZXh0YCBieSB0aGUgY3VycmVudCBgZGlzdGFuY2VgLlxuICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gcmV2ZXJzZSA/IGxlYWZUZXh0T2Zmc2V0IC0gZGlzdGFuY2UgOiBsZWFmVGV4dE9mZnNldCArIGRpc3RhbmNlO1xuICAgICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gbGVhZlRleHRSZW1haW5pbmcgLSBkaXN0YW5jZTtcbiAgICAgICAgICAvLyBJZiBgbGVhZlRleHRgIGlzIGV4aGF1c3RlZCwgYnJlYWsgdG8gZ2V0IGEgbmV3IGxlYWYgbm9kZVxuICAgICAgICAgIC8vIGFuZCBzZXQgZGlzdGFuY2UgdG8gdGhlIG92ZXJmbG93IGFtb3VudCwgc28gd2UnbGwgKG1heWJlKVxuICAgICAgICAgIC8vIGNhdGNoIHVwIHRvIGJsb2NrVGV4dCBpbiB0aGUgbmV4dCBsZWFmIHRleHQgbm9kZS5cbiAgICAgICAgICBpZiAobGVhZlRleHRSZW1haW5pbmcgPCAwKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IC1sZWFmVGV4dFJlbWFpbmluZztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTdWNjZXNzZnVsbHkgd2Fsa2VkIGBkaXN0YW5jZWAgb2Zmc2V0cyB0aHJvdWdoIGBsZWFmVGV4dGBcbiAgICAgICAgICAvLyB0byBjYXRjaCB1cCB3aXRoIGBibG9ja1RleHRgLCBzbyB3ZSBjYW4gcmVzZXQgYGRpc3RhbmNlYFxuICAgICAgICAgIC8vIGFuZCB5aWVsZCB0aGlzIHBvc2l0aW9uIGluIHRoaXMgbm9kZS5cbiAgICAgICAgICBkaXN0YW5jZSA9IDA7XG4gICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIG9mZnNldDogbGVhZlRleHRPZmZzZXRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFByb29mIHRoYXQgdXBvbiBjb21wbGV0aW9uLCB3ZSd2ZSBleGFodXN0ZWQgYm90aCBsZWFmIGFuZCBibG9jayB0ZXh0OlxuICAgIC8vICAgY29uc29sZS5hc3NlcnQobGVhZlRleHRSZW1haW5pbmcgPD0gMCwgXCJsZWFmVGV4dCB3YXNuJ3QgZXhoYXVzdGVkXCIpXG4gICAgLy8gICBjb25zb2xlLmFzc2VydChibG9ja1RleHQgPT09ICcnLCBcImJsb2NrVGV4dCB3YXNuJ3QgZXhoYXVzdGVkXCIpXG4gICAgLy8gSGVscGVyOlxuICAgIC8vIFJldHVybiB0aGUgZGlzdGFuY2UgaW4gb2Zmc2V0cyBmb3IgYSBzdGVwIG9mIHNpemUgYHVuaXRgIG9uIGdpdmVuIHN0cmluZy5cbiAgICBmdW5jdGlvbiBjYWxjRGlzdGFuY2UodGV4dCwgdW5pdCwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHVuaXQgPT09ICdjaGFyYWN0ZXInKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCByZXZlcnNlKTtcbiAgICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3dvcmQnKSB7XG4gICAgICAgIHJldHVybiBnZXRXb3JkRGlzdGFuY2UodGV4dCwgcmV2ZXJzZSk7XG4gICAgICB9IGVsc2UgaWYgKHVuaXQgPT09ICdsaW5lJyB8fCB1bml0ID09PSAnYmxvY2snKSB7XG4gICAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSgpO1xufVxuXG52YXIgcHJldmlvdXMgPSBmdW5jdGlvbiBwcmV2aW91cyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIge1xuICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICB2b2lkcyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICB2YXIge1xuICAgIG1hdGNoLFxuICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICB9ID0gb3B0aW9ucztcbiAgaWYgKCFhdCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcG9pbnRCZWZvcmVMb2NhdGlvbiA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhdCwge1xuICAgIHZvaWRzXG4gIH0pO1xuICBpZiAoIXBvaW50QmVmb3JlTG9jYXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIFssIHRvXSA9IEVkaXRvci5maXJzdChlZGl0b3IsIFtdKTtcbiAgLy8gVGhlIHNlYXJjaCBsb2NhdGlvbiBpcyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQgdG8gdGhlIHBhdGggb2ZcbiAgLy8gdGhlIHBvaW50IGJlZm9yZSB0aGUgbG9jYXRpb24gcGFzc2VkIGluXG4gIHZhciBzcGFuID0gW3BvaW50QmVmb3JlTG9jYXRpb24ucGF0aCwgdG9dO1xuICBpZiAoUGF0aC5pc1BhdGgoYXQpICYmIGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIG5vZGUgZnJvbSB0aGUgcm9vdCBub2RlIVwiKTtcbiAgfVxuICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCk7XG4gICAgICBtYXRjaCA9IG4gPT4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRjaCA9ICgpID0+IHRydWU7XG4gICAgfVxuICB9XG4gIHZhciBbcHJldmlvdXNdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIHJldmVyc2U6IHRydWUsXG4gICAgYXQ6IHNwYW4sXG4gICAgbWF0Y2gsXG4gICAgbW9kZSxcbiAgICB2b2lkc1xuICB9KTtcbiAgcmV0dXJuIHByZXZpb3VzO1xufTtcblxudmFyIHJhbmdlUmVmID0gZnVuY3Rpb24gcmFuZ2VSZWYoZWRpdG9yLCByYW5nZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIHZhciB7XG4gICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciByZWYgPSB7XG4gICAgY3VycmVudDogcmFuZ2UsXG4gICAgYWZmaW5pdHksXG4gICAgdW5yZWYoKSB7XG4gICAgICB2YXIge1xuICAgICAgICBjdXJyZW50XG4gICAgICB9ID0gcmVmO1xuICAgICAgdmFyIHJhbmdlUmVmcyA9IEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKTtcbiAgICAgIHJhbmdlUmVmcy5kZWxldGUocmVmKTtcbiAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgfTtcbiAgdmFyIHJlZnMgPSBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcik7XG4gIHJlZnMuYWRkKHJlZik7XG4gIHJldHVybiByZWY7XG59O1xuXG52YXIgcmFuZ2VSZWZzID0gZWRpdG9yID0+IHtcbiAgdmFyIHJlZnMgPSBSQU5HRV9SRUZTLmdldChlZGl0b3IpO1xuICBpZiAoIXJlZnMpIHtcbiAgICByZWZzID0gbmV3IFNldCgpO1xuICAgIFJBTkdFX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gIH1cbiAgcmV0dXJuIHJlZnM7XG59O1xuXG52YXIgcmFuZ2UgPSAoZWRpdG9yLCBhdCwgdG8pID0+IHtcbiAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpICYmICF0bykge1xuICAgIHJldHVybiBhdDtcbiAgfVxuICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgdG8gfHwgYXQpO1xuICByZXR1cm4ge1xuICAgIGFuY2hvcjogc3RhcnQsXG4gICAgZm9jdXM6IGVuZFxuICB9O1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQyKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMihlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDIoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDIoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciByZW1vdmVNYXJrID0gKGVkaXRvciwga2V5KSA9PiB7XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICB2YXIgbWF0Y2ggPSAobm9kZSwgcGF0aCkgPT4ge1xuICAgICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG1hcmtzIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gdGV4dFxuICAgICAgfVxuXG4gICAgICB2YXIgW3BhcmVudE5vZGUsIHBhcmVudFBhdGhdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuICAgICAgcmV0dXJuICFlZGl0b3IuaXNWb2lkKHBhcmVudE5vZGUpIHx8IGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgfTtcbiAgICB2YXIgZXhwYW5kZWRTZWxlY3Rpb24gPSBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbik7XG4gICAgdmFyIG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIWV4cGFuZGVkU2VsZWN0aW9uKSB7XG4gICAgICB2YXIgW3NlbGVjdGVkTm9kZSwgc2VsZWN0ZWRQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgbWF0Y2goc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGgpKSB7XG4gICAgICAgIHZhciBbcGFyZW50Tm9kZV0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgc2VsZWN0ZWRQYXRoKTtcbiAgICAgICAgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IHBhcmVudE5vZGUgJiYgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4cGFuZGVkU2VsZWN0aW9uIHx8IG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQpIHtcbiAgICAgIFRyYW5zZm9ybXMudW5zZXROb2RlcyhlZGl0b3IsIGtleSwge1xuICAgICAgICBtYXRjaCxcbiAgICAgICAgc3BsaXQ6IHRydWUsXG4gICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hcmtzID0gX29iamVjdFNwcmVhZCQyKHt9LCBFZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSk7XG4gICAgICBkZWxldGUgbWFya3Nba2V5XTtcbiAgICAgIGVkaXRvci5tYXJrcyA9IG1hcmtzO1xuICAgICAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgICAgICBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBzZXROb3JtYWxpemluZyA9IChlZGl0b3IsIGlzTm9ybWFsaXppbmcpID0+IHtcbiAgTk9STUFMSVpJTkcuc2V0KGVkaXRvciwgaXNOb3JtYWxpemluZyk7XG59O1xuXG52YXIgc3RhcnQgPSAoZWRpdG9yLCBhdCkgPT4ge1xuICByZXR1cm4gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICBlZGdlOiAnc3RhcnQnXG4gIH0pO1xufTtcblxudmFyIHN0cmluZyA9IGZ1bmN0aW9uIHN0cmluZyhlZGl0b3IsIGF0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIHtcbiAgICB2b2lkcyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gIHZhciB0ZXh0ID0gJyc7XG4gIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgYXQ6IHJhbmdlLFxuICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICB2b2lkc1xuICB9KSkge1xuICAgIHZhciB0ID0gbm9kZS50ZXh0O1xuICAgIGlmIChQYXRoLmVxdWFscyhwYXRoLCBlbmQucGF0aCkpIHtcbiAgICAgIHQgPSB0LnNsaWNlKDAsIGVuZC5vZmZzZXQpO1xuICAgIH1cbiAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgc3RhcnQucGF0aCkpIHtcbiAgICAgIHQgPSB0LnNsaWNlKHN0YXJ0Lm9mZnNldCk7XG4gICAgfVxuICAgIHRleHQgKz0gdDtcbiAgfVxuICByZXR1cm4gdGV4dDtcbn07XG5cbnZhciB1bmhhbmdSYW5nZSA9IGZ1bmN0aW9uIHVuaGFuZ1JhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIge1xuICAgIHZvaWRzID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gIC8vIFBFUkY6IGV4aXQgZWFybHkgaWYgd2UgY2FuIGd1YXJhbnRlZSB0aGF0IHRoZSByYW5nZSBpc24ndCBoYW5naW5nLlxuICBpZiAoc3RhcnQub2Zmc2V0ICE9PSAwIHx8IGVuZC5vZmZzZXQgIT09IDAgfHwgUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpIHx8IFBhdGguaGFzUHJldmlvdXMoZW5kLnBhdGgpKSB7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG4gIHZhciBlbmRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICBhdDogZW5kLFxuICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgdm9pZHNcbiAgfSk7XG4gIHZhciBibG9ja1BhdGggPSBlbmRCbG9jayA/IGVuZEJsb2NrWzFdIDogW107XG4gIHZhciBmaXJzdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIHN0YXJ0KTtcbiAgdmFyIGJlZm9yZSA9IHtcbiAgICBhbmNob3I6IGZpcnN0LFxuICAgIGZvY3VzOiBlbmRcbiAgfTtcbiAgdmFyIHNraXAgPSB0cnVlO1xuICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgIGF0OiBiZWZvcmUsXG4gICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgIHJldmVyc2U6IHRydWUsXG4gICAgdm9pZHNcbiAgfSkpIHtcbiAgICBpZiAoc2tpcCkge1xuICAgICAgc2tpcCA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlLnRleHQgIT09ICcnIHx8IFBhdGguaXNCZWZvcmUocGF0aCwgYmxvY2tQYXRoKSkge1xuICAgICAgZW5kID0ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXQ6IG5vZGUudGV4dC5sZW5ndGhcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhbmNob3I6IHN0YXJ0LFxuICAgIGZvY3VzOiBlbmRcbiAgfTtcbn07XG5cbnZhciB3aXRob3V0Tm9ybWFsaXppbmcgPSAoZWRpdG9yLCBmbikgPT4ge1xuICB2YXIgdmFsdWUgPSBFZGl0b3IuaXNOb3JtYWxpemluZyhlZGl0b3IpO1xuICBFZGl0b3Iuc2V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmYWxzZSk7XG4gIHRyeSB7XG4gICAgZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBFZGl0b3Iuc2V0Tm9ybWFsaXppbmcoZWRpdG9yLCB2YWx1ZSk7XG4gIH1cbiAgRWRpdG9yLm5vcm1hbGl6ZShlZGl0b3IpO1xufTtcblxudmFyIGRlbGV0ZVRleHQgPSBmdW5jdGlvbiBkZWxldGVUZXh0KGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgdmFyIF9FZGl0b3Ikdm9pZCwgX0VkaXRvciR2b2lkMjtcbiAgICB2YXIge1xuICAgICAgcmV2ZXJzZSA9IGZhbHNlLFxuICAgICAgdW5pdCA9ICdjaGFyYWN0ZXInLFxuICAgICAgZGlzdGFuY2UgPSAxLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBoYW5naW5nID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpc0NvbGxhcHNlZCA9IGZhbHNlO1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSAmJiBSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgIGlzQ29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgIH1cbiAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgIHZhciBmdXJ0aGVzdFZvaWQgPSBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgfSk7XG4gICAgICBpZiAoIXZvaWRzICYmIGZ1cnRoZXN0Vm9pZCkge1xuICAgICAgICB2YXIgWywgdm9pZFBhdGhdID0gZnVydGhlc3RWb2lkO1xuICAgICAgICBhdCA9IHZvaWRQYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgdW5pdCxcbiAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGFyZ2V0ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhdCwgb3B0cykgfHwgRWRpdG9yLnN0YXJ0KGVkaXRvciwgW10pIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgYXQsIG9wdHMpIHx8IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gICAgICAgIGF0ID0ge1xuICAgICAgICAgIGFuY2hvcjogYXQsXG4gICAgICAgICAgZm9jdXM6IHRhcmdldFxuICAgICAgICB9O1xuICAgICAgICBoYW5naW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWhhbmdpbmcpIHtcbiAgICAgIHZhciBbLCBfZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgIHZhciBlbmRPZkRvYyA9IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gICAgICBpZiAoIVBvaW50LmVxdWFscyhfZW5kLCBlbmRPZkRvYykpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgIHZhciBzdGFydEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgIGF0OiBzdGFydCxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIGVuZEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgIGF0OiBlbmQsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBpc0Fjcm9zc0Jsb2NrcyA9IHN0YXJ0QmxvY2sgJiYgZW5kQmxvY2sgJiYgIVBhdGguZXF1YWxzKHN0YXJ0QmxvY2tbMV0sIGVuZEJsb2NrWzFdKTtcbiAgICB2YXIgaXNTaW5nbGVUZXh0ID0gUGF0aC5lcXVhbHMoc3RhcnQucGF0aCwgZW5kLnBhdGgpO1xuICAgIHZhciBzdGFydE5vbkVkaXRhYmxlID0gdm9pZHMgPyBudWxsIDogKF9FZGl0b3Ikdm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgfSkpICE9PSBudWxsICYmIF9FZGl0b3Ikdm9pZCAhPT0gdm9pZCAwID8gX0VkaXRvciR2b2lkIDogRWRpdG9yLmVsZW1lbnRSZWFkT25seShlZGl0b3IsIHtcbiAgICAgIGF0OiBzdGFydCxcbiAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgIH0pO1xuICAgIHZhciBlbmROb25FZGl0YWJsZSA9IHZvaWRzID8gbnVsbCA6IChfRWRpdG9yJHZvaWQyID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICBhdDogZW5kLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgfSkpICE9PSBudWxsICYmIF9FZGl0b3Ikdm9pZDIgIT09IHZvaWQgMCA/IF9FZGl0b3Ikdm9pZDIgOiBFZGl0b3IuZWxlbWVudFJlYWRPbmx5KGVkaXRvciwge1xuICAgICAgYXQ6IGVuZCxcbiAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgIH0pO1xuICAgIC8vIElmIHRoZSBzdGFydCBvciBlbmQgcG9pbnRzIGFyZSBpbnNpZGUgYW4gaW5saW5lIHZvaWQsIG51ZGdlIHRoZW0gb3V0LlxuICAgIGlmIChzdGFydE5vbkVkaXRhYmxlKSB7XG4gICAgICB2YXIgYmVmb3JlID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIHN0YXJ0KTtcbiAgICAgIGlmIChiZWZvcmUgJiYgc3RhcnRCbG9jayAmJiBQYXRoLmlzQW5jZXN0b3Ioc3RhcnRCbG9ja1sxXSwgYmVmb3JlLnBhdGgpKSB7XG4gICAgICAgIHN0YXJ0ID0gYmVmb3JlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5kTm9uRWRpdGFibGUpIHtcbiAgICAgIHZhciBhZnRlciA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGVuZCk7XG4gICAgICBpZiAoYWZ0ZXIgJiYgZW5kQmxvY2sgJiYgUGF0aC5pc0FuY2VzdG9yKGVuZEJsb2NrWzFdLCBhZnRlci5wYXRoKSkge1xuICAgICAgICBlbmQgPSBhZnRlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gR2V0IHRoZSBoaWdoZXN0IG5vZGVzIHRoYXQgYXJlIGNvbXBsZXRlbHkgaW5zaWRlIHRoZSByYW5nZSwgYXMgd2VsbCBhc1xuICAgIC8vIHRoZSBzdGFydCBhbmQgZW5kIG5vZGVzLlxuICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgdmFyIGxhc3RQYXRoO1xuICAgIGZvciAodmFyIGVudHJ5IG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgdm9pZHNcbiAgICB9KSkge1xuICAgICAgdmFyIFtub2RlLCBwYXRoXSA9IGVudHJ5O1xuICAgICAgaWYgKGxhc3RQYXRoICYmIFBhdGguY29tcGFyZShwYXRoLCBsYXN0UGF0aCkgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIXZvaWRzICYmIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIChFZGl0b3IuaXNWb2lkKGVkaXRvciwgbm9kZSkgfHwgRWRpdG9yLmlzRWxlbWVudFJlYWRPbmx5KGVkaXRvciwgbm9kZSkpIHx8ICFQYXRoLmlzQ29tbW9uKHBhdGgsIHN0YXJ0LnBhdGgpICYmICFQYXRoLmlzQ29tbW9uKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICBtYXRjaGVzLnB1c2goZW50cnkpO1xuICAgICAgICBsYXN0UGF0aCA9IHBhdGg7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgX3JlZiA9PiB7XG4gICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgfSk7XG4gICAgdmFyIHN0YXJ0UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgc3RhcnQpO1xuICAgIHZhciBlbmRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgIHZhciByZW1vdmVkVGV4dCA9ICcnO1xuICAgIGlmICghaXNTaW5nbGVUZXh0ICYmICFzdGFydE5vbkVkaXRhYmxlKSB7XG4gICAgICB2YXIgX3BvaW50ID0gc3RhcnRSZWYuY3VycmVudDtcbiAgICAgIHZhciBbX25vZGVdID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBfcG9pbnQpO1xuICAgICAgdmFyIHtcbiAgICAgICAgcGF0aDogX3BhdGhcbiAgICAgIH0gPSBfcG9pbnQ7XG4gICAgICB2YXIge1xuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSBzdGFydDtcbiAgICAgIHZhciB0ZXh0ID0gX25vZGUudGV4dC5zbGljZShvZmZzZXQpO1xuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdyZW1vdmVfdGV4dCcsXG4gICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIHRleHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW92ZWRUZXh0ID0gdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgcGF0aFJlZnMucmV2ZXJzZSgpLm1hcChyID0+IHIudW5yZWYoKSkuZmlsdGVyKHIgPT4gciAhPT0gbnVsbCkuZm9yRWFjaChwID0+IFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogcCxcbiAgICAgIHZvaWRzXG4gICAgfSkpO1xuICAgIGlmICghZW5kTm9uRWRpdGFibGUpIHtcbiAgICAgIHZhciBfcG9pbnQyID0gZW5kUmVmLmN1cnJlbnQ7XG4gICAgICB2YXIgW19ub2RlMl0gPSBFZGl0b3IubGVhZihlZGl0b3IsIF9wb2ludDIpO1xuICAgICAgdmFyIHtcbiAgICAgICAgcGF0aDogX3BhdGgyXG4gICAgICB9ID0gX3BvaW50MjtcbiAgICAgIHZhciBfb2Zmc2V0ID0gaXNTaW5nbGVUZXh0ID8gc3RhcnQub2Zmc2V0IDogMDtcbiAgICAgIHZhciBfdGV4dCA9IF9ub2RlMi50ZXh0LnNsaWNlKF9vZmZzZXQsIGVuZC5vZmZzZXQpO1xuICAgICAgaWYgKF90ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnLFxuICAgICAgICAgIHBhdGg6IF9wYXRoMixcbiAgICAgICAgICBvZmZzZXQ6IF9vZmZzZXQsXG4gICAgICAgICAgdGV4dDogX3RleHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW92ZWRUZXh0ID0gX3RleHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXNTaW5nbGVUZXh0ICYmIGlzQWNyb3NzQmxvY2tzICYmIGVuZFJlZi5jdXJyZW50ICYmIHN0YXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgIFRyYW5zZm9ybXMubWVyZ2VOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVuZFJlZi5jdXJyZW50LFxuICAgICAgICBoYW5naW5nOiB0cnVlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEZvciBUaGFpIHNjcmlwdCwgZGVsZXRpbmcgTiBjaGFyYWN0ZXIocykgYmFja3dhcmQgc2hvdWxkIGRlbGV0ZVxuICAgIC8vIE4gY29kZSBwb2ludChzKSBpbnN0ZWFkIG9mIGFuIGVudGlyZSBncmFwaGVtZSBjbHVzdGVyLlxuICAgIC8vIFRoZXJlZm9yZSwgdGhlIHJlbWFpbmluZyBjb2RlIHBvaW50cyBzaG91bGQgYmUgaW5zZXJ0ZWQgYmFjay5cbiAgICBpZiAoaXNDb2xsYXBzZWQgJiYgcmV2ZXJzZSAmJiB1bml0ID09PSAnY2hhcmFjdGVyJyAmJiByZW1vdmVkVGV4dC5sZW5ndGggPiAxICYmIHJlbW92ZWRUZXh0Lm1hdGNoKC9bXFx1MEUwMC1cXHUwRTdGXSsvKSkge1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KGVkaXRvciwgcmVtb3ZlZFRleHQuc2xpY2UoMCwgcmVtb3ZlZFRleHQubGVuZ3RoIC0gZGlzdGFuY2UpKTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0VW5yZWYgPSBzdGFydFJlZi51bnJlZigpO1xuICAgIHZhciBlbmRVbnJlZiA9IGVuZFJlZi51bnJlZigpO1xuICAgIHZhciBwb2ludCA9IHJldmVyc2UgPyBzdGFydFVucmVmIHx8IGVuZFVucmVmIDogZW5kVW5yZWYgfHwgc3RhcnRVbnJlZjtcbiAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsICYmIHBvaW50KSB7XG4gICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHBvaW50KTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGluc2VydEZyYWdtZW50ID0gZnVuY3Rpb24gaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIGhhbmdpbmcgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgYXQgPSBnZXREZWZhdWx0SW5zZXJ0TG9jYXRpb24oZWRpdG9yKVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghZnJhZ21lbnQubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZW5kXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgIGF0XG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIGF0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICAgIH1cbiAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgYXRcbiAgICB9KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgaW5zZXJ0IHBvaW50IGlzIGF0IHRoZSBlZGdlIG9mIGFuIGlubGluZSBub2RlLCBtb3ZlIGl0IG91dHNpZGVcbiAgICAvLyBpbnN0ZWFkIHNpbmNlIGl0IHdpbGwgbmVlZCB0byBiZSBzcGxpdCBvdGhlcndpc2UuXG4gICAgdmFyIGlubGluZUVsZW1lbnRNYXRjaCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIGlmIChpbmxpbmVFbGVtZW50TWF0Y2gpIHtcbiAgICAgIHZhciBbLCBfaW5saW5lUGF0aF0gPSBpbmxpbmVFbGVtZW50TWF0Y2g7XG4gICAgICBpZiAoRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIF9pbmxpbmVQYXRoKSkge1xuICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBfaW5saW5lUGF0aCk7XG4gICAgICAgIGF0ID0gYWZ0ZXI7XG4gICAgICB9IGVsc2UgaWYgKEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgYXQsIF9pbmxpbmVQYXRoKSkge1xuICAgICAgICB2YXIgYmVmb3JlID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIF9pbmxpbmVQYXRoKTtcbiAgICAgICAgYXQgPSBiZWZvcmU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBibG9ja01hdGNoID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgbWF0Y2g6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgIGF0LFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgWywgYmxvY2tQYXRoXSA9IGJsb2NrTWF0Y2g7XG4gICAgdmFyIGlzQmxvY2tTdGFydCA9IEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgYXQsIGJsb2NrUGF0aCk7XG4gICAgdmFyIGlzQmxvY2tFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgYmxvY2tQYXRoKTtcbiAgICB2YXIgaXNCbG9ja0VtcHR5ID0gaXNCbG9ja1N0YXJ0ICYmIGlzQmxvY2tFbmQ7XG4gICAgdmFyIG1lcmdlU3RhcnQgPSAhaXNCbG9ja1N0YXJ0IHx8IGlzQmxvY2tTdGFydCAmJiBpc0Jsb2NrRW5kO1xuICAgIHZhciBtZXJnZUVuZCA9ICFpc0Jsb2NrRW5kO1xuICAgIHZhciBbLCBmaXJzdFBhdGhdID0gTm9kZS5maXJzdCh7XG4gICAgICBjaGlsZHJlbjogZnJhZ21lbnRcbiAgICB9LCBbXSk7XG4gICAgdmFyIFssIGxhc3RQYXRoXSA9IE5vZGUubGFzdCh7XG4gICAgICBjaGlsZHJlbjogZnJhZ21lbnRcbiAgICB9LCBbXSk7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICB2YXIgbWF0Y2hlciA9IF9yZWYgPT4ge1xuICAgICAgdmFyIFtuLCBwXSA9IF9yZWY7XG4gICAgICB2YXIgaXNSb290ID0gcC5sZW5ndGggPT09IDA7XG4gICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Jsb2NrRW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobWVyZ2VTdGFydCAmJiBQYXRoLmlzQW5jZXN0b3IocCwgZmlyc3RQYXRoKSAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiAhZWRpdG9yLmlzVm9pZChuKSAmJiAhZWRpdG9yLmlzSW5saW5lKG4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXJnZUVuZCAmJiBQYXRoLmlzQW5jZXN0b3IocCwgbGFzdFBhdGgpICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmICFlZGl0b3IuaXNWb2lkKG4pICYmICFlZGl0b3IuaXNJbmxpbmUobikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBmb3IgKHZhciBlbnRyeSBvZiBOb2RlLm5vZGVzKHtcbiAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgIH0sIHtcbiAgICAgIHBhc3M6IG1hdGNoZXJcbiAgICB9KSkge1xuICAgICAgaWYgKG1hdGNoZXIoZW50cnkpKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBzdGFydHMgPSBbXTtcbiAgICB2YXIgbWlkZGxlcyA9IFtdO1xuICAgIHZhciBlbmRzID0gW107XG4gICAgdmFyIHN0YXJ0aW5nID0gdHJ1ZTtcbiAgICB2YXIgaGFzQmxvY2tzID0gZmFsc2U7XG4gICAgZm9yICh2YXIgW25vZGVdIG9mIG1hdGNoZXMpIHtcbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiAhZWRpdG9yLmlzSW5saW5lKG5vZGUpKSB7XG4gICAgICAgIHN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgIGhhc0Jsb2NrcyA9IHRydWU7XG4gICAgICAgIG1pZGRsZXMucHVzaChub2RlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRpbmcpIHtcbiAgICAgICAgc3RhcnRzLnB1c2gobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBbaW5saW5lTWF0Y2hdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaDogbiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIFssIGlubGluZVBhdGhdID0gaW5saW5lTWF0Y2g7XG4gICAgdmFyIGlzSW5saW5lU3RhcnQgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBpbmxpbmVQYXRoKTtcbiAgICB2YXIgaXNJbmxpbmVFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgaW5saW5lUGF0aCk7XG4gICAgdmFyIG1pZGRsZVJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgaXNCbG9ja0VuZCAmJiAhZW5kcy5sZW5ndGggPyBQYXRoLm5leHQoYmxvY2tQYXRoKSA6IGJsb2NrUGF0aCk7XG4gICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgaXNJbmxpbmVFbmQgPyBQYXRoLm5leHQoaW5saW5lUGF0aCkgOiBpbmxpbmVQYXRoKTtcbiAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoOiBuID0+IGhhc0Jsb2NrcyA/IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbikgOiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgIG1vZGU6IGhhc0Jsb2NrcyA/ICdsb3dlc3QnIDogJ2hpZ2hlc3QnLFxuICAgICAgYWx3YXlzOiBoYXNCbG9ja3MgJiYgKCFpc0Jsb2NrU3RhcnQgfHwgc3RhcnRzLmxlbmd0aCA+IDApICYmICghaXNCbG9ja0VuZCB8fCBlbmRzLmxlbmd0aCA+IDApLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsICFpc0lubGluZVN0YXJ0IHx8IGlzSW5saW5lU3RhcnQgJiYgaXNJbmxpbmVFbmQgPyBQYXRoLm5leHQoaW5saW5lUGF0aCkgOiBpbmxpbmVQYXRoKTtcbiAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgc3RhcnRzLCB7XG4gICAgICBhdDogc3RhcnRSZWYuY3VycmVudCxcbiAgICAgIG1hdGNoOiBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICBpZiAoaXNCbG9ja0VtcHR5ICYmICFzdGFydHMubGVuZ3RoICYmIG1pZGRsZXMubGVuZ3RoICYmICFlbmRzLmxlbmd0aCkge1xuICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBibG9ja1BhdGgsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG1pZGRsZXMsIHtcbiAgICAgIGF0OiBtaWRkbGVSZWYuY3VycmVudCxcbiAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICBtb2RlOiAnbG93ZXN0JyxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGVuZHMsIHtcbiAgICAgIGF0OiBlbmRSZWYuY3VycmVudCxcbiAgICAgIG1hdGNoOiBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICBpZiAoIW9wdGlvbnMuYXQpIHtcbiAgICAgIHZhciBwYXRoO1xuICAgICAgaWYgKGVuZHMubGVuZ3RoID4gMCAmJiBlbmRSZWYuY3VycmVudCkge1xuICAgICAgICBwYXRoID0gUGF0aC5wcmV2aW91cyhlbmRSZWYuY3VycmVudCk7XG4gICAgICB9IGVsc2UgaWYgKG1pZGRsZXMubGVuZ3RoID4gMCAmJiBtaWRkbGVSZWYuY3VycmVudCkge1xuICAgICAgICBwYXRoID0gUGF0aC5wcmV2aW91cyhtaWRkbGVSZWYuY3VycmVudCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMoc3RhcnRSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBpZiAocGF0aCkge1xuICAgICAgICB2YXIgX2VuZCA9IEVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBfZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRSZWYudW5yZWYoKTtcbiAgICBtaWRkbGVSZWYudW5yZWYoKTtcbiAgICBlbmRSZWYudW5yZWYoKTtcbiAgfSk7XG59O1xuXG52YXIgY29sbGFwc2UgPSBmdW5jdGlvbiBjb2xsYXBzZShlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICB2YXIge1xuICAgIGVkZ2UgPSAnYW5jaG9yJ1xuICB9ID0gb3B0aW9ucztcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2FuY2hvcicpIHtcbiAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHNlbGVjdGlvbi5hbmNob3IpO1xuICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdmb2N1cycpIHtcbiAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHNlbGVjdGlvbi5mb2N1cyk7XG4gIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgIHZhciBbc3RhcnRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKTtcbiAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHN0YXJ0KTtcbiAgfSBlbHNlIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKTtcbiAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGVuZCk7XG4gIH1cbn07XG5cbnZhciBkZXNlbGVjdCA9IGVkaXRvciA9PiB7XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIGlmIChzZWxlY3Rpb24pIHtcbiAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgdHlwZTogJ3NldF9zZWxlY3Rpb24nLFxuICAgICAgcHJvcGVydGllczogc2VsZWN0aW9uLFxuICAgICAgbmV3UHJvcGVydGllczogbnVsbFxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgbW92ZSA9IGZ1bmN0aW9uIG1vdmUoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgdmFyIHtcbiAgICBzZWxlY3Rpb25cbiAgfSA9IGVkaXRvcjtcbiAgdmFyIHtcbiAgICBkaXN0YW5jZSA9IDEsXG4gICAgdW5pdCA9ICdjaGFyYWN0ZXInLFxuICAgIHJldmVyc2UgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIHtcbiAgICBlZGdlID0gbnVsbFxuICB9ID0gb3B0aW9ucztcbiAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2ZvY3VzJyA6ICdhbmNob3InO1xuICB9XG4gIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnYW5jaG9yJyA6ICdmb2N1cyc7XG4gIH1cbiAgdmFyIHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA9IHNlbGVjdGlvbjtcbiAgdmFyIG9wdHMgPSB7XG4gICAgZGlzdGFuY2UsXG4gICAgdW5pdCxcbiAgICBpZ25vcmVOb25TZWxlY3RhYmxlOiB0cnVlXG4gIH07XG4gIHZhciBwcm9wcyA9IHt9O1xuICBpZiAoZWRnZSA9PSBudWxsIHx8IGVkZ2UgPT09ICdhbmNob3InKSB7XG4gICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhbmNob3IsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgYW5jaG9yLCBvcHRzKTtcbiAgICBpZiAocG9pbnQpIHtcbiAgICAgIHByb3BzLmFuY2hvciA9IHBvaW50O1xuICAgIH1cbiAgfVxuICBpZiAoZWRnZSA9PSBudWxsIHx8IGVkZ2UgPT09ICdmb2N1cycpIHtcbiAgICB2YXIgX3BvaW50ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBmb2N1cywgb3B0cykgOiBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBmb2N1cywgb3B0cyk7XG4gICAgaWYgKF9wb2ludCkge1xuICAgICAgcHJvcHMuZm9jdXMgPSBfcG9pbnQ7XG4gICAgfVxuICB9XG4gIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpO1xufTtcblxudmFyIHNlbGVjdCA9IChlZGl0b3IsIHRhcmdldCkgPT4ge1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICB0YXJnZXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCB0YXJnZXQpO1xuICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB0YXJnZXQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIVJhbmdlLmlzUmFuZ2UodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIldoZW4gc2V0dGluZyB0aGUgc2VsZWN0aW9uIGFuZCB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgYG51bGxgIHlvdSBtdXN0IHByb3ZpZGUgYXQgbGVhc3QgYW4gYGFuY2hvcmAgYW5kIGBmb2N1c2AsIGJ1dCB5b3UgcGFzc2VkOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHRhcmdldCkpKTtcbiAgfVxuICBlZGl0b3IuYXBwbHkoe1xuICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICBwcm9wZXJ0aWVzOiBzZWxlY3Rpb24sXG4gICAgbmV3UHJvcGVydGllczogdGFyZ2V0XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gb3duS2V5cyQxKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDEoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDEoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBzZXRQb2ludCA9IGZ1bmN0aW9uIHNldFBvaW50KGVkaXRvciwgcHJvcHMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICB2YXIge1xuICAgIHNlbGVjdGlvblxuICB9ID0gZWRpdG9yO1xuICB2YXIge1xuICAgIGVkZ2UgPSAnYm90aCdcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgfVxuICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2FuY2hvcicgOiAnZm9jdXMnO1xuICB9XG4gIHZhciB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH0gPSBzZWxlY3Rpb247XG4gIHZhciBwb2ludCA9IGVkZ2UgPT09ICdhbmNob3InID8gYW5jaG9yIDogZm9jdXM7XG4gIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgIFtlZGdlID09PSAnYW5jaG9yJyA/ICdhbmNob3InIDogJ2ZvY3VzJ106IF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoe30sIHBvaW50KSwgcHJvcHMpXG4gIH0pO1xufTtcblxudmFyIHNldFNlbGVjdGlvbiA9IChlZGl0b3IsIHByb3BzKSA9PiB7XG4gIHZhciB7XG4gICAgc2VsZWN0aW9uXG4gIH0gPSBlZGl0b3I7XG4gIHZhciBvbGRQcm9wcyA9IHt9O1xuICB2YXIgbmV3UHJvcHMgPSB7fTtcbiAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgIGlmIChrID09PSAnYW5jaG9yJyAmJiBwcm9wcy5hbmNob3IgIT0gbnVsbCAmJiAhUG9pbnQuZXF1YWxzKHByb3BzLmFuY2hvciwgc2VsZWN0aW9uLmFuY2hvcikgfHwgayA9PT0gJ2ZvY3VzJyAmJiBwcm9wcy5mb2N1cyAhPSBudWxsICYmICFQb2ludC5lcXVhbHMocHJvcHMuZm9jdXMsIHNlbGVjdGlvbi5mb2N1cykgfHwgayAhPT0gJ2FuY2hvcicgJiYgayAhPT0gJ2ZvY3VzJyAmJiBwcm9wc1trXSAhPT0gc2VsZWN0aW9uW2tdKSB7XG4gICAgICBvbGRQcm9wc1trXSA9IHNlbGVjdGlvbltrXTtcbiAgICAgIG5ld1Byb3BzW2tdID0gcHJvcHNba107XG4gICAgfVxuICB9XG4gIGlmIChPYmplY3Qua2V5cyhvbGRQcm9wcykubGVuZ3RoID4gMCkge1xuICAgIGVkaXRvci5hcHBseSh7XG4gICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICBwcm9wZXJ0aWVzOiBvbGRQcm9wcyxcbiAgICAgIG5ld1Byb3BlcnRpZXM6IG5ld1Byb3BzXG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBpbnNlcnROb2RlcyA9IGZ1bmN0aW9uIGluc2VydE5vZGVzKGVkaXRvciwgbm9kZXMpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgbW9kZSA9ICdsb3dlc3QnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2gsXG4gICAgICBzZWxlY3RcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoTm9kZS5pc05vZGUobm9kZXMpKSB7XG4gICAgICBub2RlcyA9IFtub2Rlc107XG4gICAgfVxuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIFtub2RlXSA9IG5vZGVzO1xuICAgIGlmICghYXQpIHtcbiAgICAgIGF0ID0gZ2V0RGVmYXVsdEluc2VydExvY2F0aW9uKGVkaXRvcik7XG4gICAgICBzZWxlY3QgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoc2VsZWN0ID09IG51bGwpIHtcbiAgICAgIHNlbGVjdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgIGF0XG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBuID0+IFRleHQuaXNUZXh0KG4pO1xuICAgICAgICB9IGVsc2UgaWYgKGVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaCA9IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIFtlbnRyeV0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBhdC5wYXRoLFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIHZhciBbLCBtYXRjaFBhdGhdID0gZW50cnk7XG4gICAgICAgIHZhciBwYXRoUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBtYXRjaFBhdGgpO1xuICAgICAgICB2YXIgaXNBdEVuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBtYXRjaFBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICAgIGF0ID0gaXNBdEVuZCA/IFBhdGgubmV4dChwYXRoKSA6IHBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQoYXQpO1xuICAgIHZhciBpbmRleCA9IGF0W2F0Lmxlbmd0aCAtIDFdO1xuICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICBhdDogcGFyZW50UGF0aFxuICAgIH0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIF9ub2RlIG9mIG5vZGVzKSB7XG4gICAgICB2YXIgX3BhdGggPSBwYXJlbnRQYXRoLmNvbmNhdChpbmRleCk7XG4gICAgICBpbmRleCsrO1xuICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJyxcbiAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgIG5vZGU6IF9ub2RlXG4gICAgICB9KTtcbiAgICAgIGF0ID0gUGF0aC5uZXh0KGF0KTtcbiAgICB9XG4gICAgYXQgPSBQYXRoLnByZXZpb3VzKGF0KTtcbiAgICBpZiAoc2VsZWN0KSB7XG4gICAgICB2YXIgcG9pbnQgPSBFZGl0b3IuZW5kKGVkaXRvciwgYXQpO1xuICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcG9pbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgbGlmdE5vZGVzID0gZnVuY3Rpb24gbGlmdE5vZGVzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgbWF0Y2hcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgfVxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG1hdGNoZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgbW9kZSxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCBfcmVmID0+IHtcbiAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGxpZnQgbm9kZSBhdCBhIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCBoYXMgYSBkZXB0aCBvZiBsZXNzIHRoYW4gYDJgLlwiKSk7XG4gICAgICB9XG4gICAgICB2YXIgcGFyZW50Tm9kZUVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBQYXRoLnBhcmVudChwYXRoKSk7XG4gICAgICB2YXIgW3BhcmVudCwgcGFyZW50UGF0aF0gPSBwYXJlbnROb2RlRW50cnk7XG4gICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICB2YXIge1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0gPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciB0b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG4gICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIHRvOiB0b1BhdGgsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhcmVudFBhdGgsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIHRvOiBwYXJlbnRQYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICB2YXIgX3RvUGF0aCA9IFBhdGgubmV4dChwYXJlbnRQYXRoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgdG86IF90b1BhdGgsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3BsaXRQYXRoID0gUGF0aC5uZXh0KHBhdGgpO1xuICAgICAgICB2YXIgX3RvUGF0aDIgPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogc3BsaXRQYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB0bzogX3RvUGF0aDIsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJ0ZXh0XCJdLFxuICBfZXhjbHVkZWQyID0gW1wiY2hpbGRyZW5cIl07XG52YXIgaGFzU2luZ2xlQ2hpbGROZXN0ID0gKGVkaXRvciwgbm9kZSkgPT4ge1xuICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkpIHtcbiAgICB2YXIgZWxlbWVudCA9IG5vZGU7XG4gICAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGhhc1NpbmdsZUNoaWxkTmVzdChlZGl0b3IsIGVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbnZhciBtZXJnZU5vZGVzID0gZnVuY3Rpb24gbWVyZ2VOb2RlcyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBtYXRjaCxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgbW9kZSA9ICdsb3dlc3QnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpO1xuICAgICAgICBtYXRjaCA9IG4gPT4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2ggPSBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICBhdFxuICAgICAgICB9KTtcbiAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFtjdXJyZW50XSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2gsXG4gICAgICB2b2lkcyxcbiAgICAgIG1vZGVcbiAgICB9KTtcbiAgICB2YXIgcHJldiA9IEVkaXRvci5wcmV2aW91cyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgbWF0Y2gsXG4gICAgICB2b2lkcyxcbiAgICAgIG1vZGVcbiAgICB9KTtcbiAgICBpZiAoIWN1cnJlbnQgfHwgIXByZXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIFtub2RlLCBwYXRoXSA9IGN1cnJlbnQ7XG4gICAgdmFyIFtwcmV2Tm9kZSwgcHJldlBhdGhdID0gcHJldjtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDAgfHwgcHJldlBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuZXdQYXRoID0gUGF0aC5uZXh0KHByZXZQYXRoKTtcbiAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguY29tbW9uKHBhdGgsIHByZXZQYXRoKTtcbiAgICB2YXIgaXNQcmV2aW91c1NpYmxpbmcgPSBQYXRoLmlzU2libGluZyhwYXRoLCBwcmV2UGF0aCk7XG4gICAgdmFyIGxldmVscyA9IEFycmF5LmZyb20oRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoXG4gICAgfSksIF9yZWYgPT4ge1xuICAgICAgdmFyIFtuXSA9IF9yZWY7XG4gICAgICByZXR1cm4gbjtcbiAgICB9KS5zbGljZShjb21tb25QYXRoLmxlbmd0aCkuc2xpY2UoMCwgLTEpO1xuICAgIC8vIERldGVybWluZSBpZiB0aGUgbWVyZ2Ugd2lsbCBsZWF2ZSBhbiBhbmNlc3RvciBvZiB0aGUgcGF0aCBlbXB0eSBhcyBhXG4gICAgLy8gcmVzdWx0LCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gcmVtb3ZlIGl0IGFmdGVyIG1lcmdpbmcuXG4gICAgdmFyIGVtcHR5QW5jZXN0b3IgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICBhdDogcGF0aCxcbiAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgIG1hdGNoOiBuID0+IGxldmVscy5pbmNsdWRlcyhuKSAmJiBoYXNTaW5nbGVDaGlsZE5lc3QoZWRpdG9yLCBuKVxuICAgIH0pO1xuICAgIHZhciBlbXB0eVJlZiA9IGVtcHR5QW5jZXN0b3IgJiYgRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBlbXB0eUFuY2VzdG9yWzFdKTtcbiAgICB2YXIgcHJvcGVydGllcztcbiAgICB2YXIgcG9zaXRpb247XG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIG5vZGVzIGFyZSBlcXVpdmFsZW50LCBhbmQgZmlndXJlIG91dCB3aGF0IHRoZSBwb3NpdGlvblxuICAgIC8vIGFuZCBleHRyYSBwcm9wZXJ0aWVzIG9mIHRoZSBtZXJnZSB3aWxsIGJlLlxuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSAmJiBUZXh0LmlzVGV4dChwcmV2Tm9kZSkpIHtcbiAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZCk7XG4gICAgICBwb3NpdGlvbiA9IHByZXZOb2RlLnRleHQubGVuZ3RoO1xuICAgICAgcHJvcGVydGllcyA9IHJlc3Q7XG4gICAgfSBlbHNlIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFbGVtZW50LmlzRWxlbWVudChwcmV2Tm9kZSkpIHtcbiAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZDIpO1xuICAgICAgcG9zaXRpb24gPSBwcmV2Tm9kZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICBwcm9wZXJ0aWVzID0gcmVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1lcmdlIHRoZSBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gd2l0aCB0aGUgcHJldmlvdXMgc2libGluZyBiZWNhdXNlIGl0IGlzIG5vdCB0aGUgc2FtZSBraW5kOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSwgXCIgXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocHJldk5vZGUpKSk7XG4gICAgfVxuICAgIC8vIElmIHRoZSBub2RlIGlzbid0IGFscmVhZHkgdGhlIG5leHQgc2libGluZyBvZiB0aGUgcHJldmlvdXMgbm9kZSwgbW92ZVxuICAgIC8vIGl0IHNvIHRoYXQgaXQgaXMgYmVmb3JlIG1lcmdpbmcuXG4gICAgaWYgKCFpc1ByZXZpb3VzU2libGluZykge1xuICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwYXRoLFxuICAgICAgICB0bzogbmV3UGF0aCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSB3YXMgZ29pbmcgdG8gYmUgYW4gZW1wdHkgYW5jZXN0b3Igb2YgdGhlIG5vZGUgdGhhdCB3YXMgbWVyZ2VkLFxuICAgIC8vIHdlIHJlbW92ZSBpdCBmcm9tIHRoZSB0cmVlLlxuICAgIGlmIChlbXB0eVJlZikge1xuICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVtcHR5UmVmLmN1cnJlbnQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHRhcmdldCBub2RlIHRoYXQgd2UncmUgbWVyZ2luZyB3aXRoIGlzIGVtcHR5LCByZW1vdmUgaXQgaW5zdGVhZFxuICAgIC8vIG9mIG1lcmdpbmcgdGhlIHR3by4gVGhpcyBpcyBhIGNvbW1vbiByaWNoIHRleHQgZWRpdG9yIGJlaGF2aW9yIHRvXG4gICAgLy8gcHJldmVudCBsb3NpbmcgZm9ybWF0dGluZyB3aGVuIGRlbGV0aW5nIGVudGlyZSBub2RlcyB3aGVuIHlvdSBoYXZlIGFcbiAgICAvLyBoYW5naW5nIHNlbGVjdGlvbi5cbiAgICAvLyBpZiBwcmV2Tm9kZSBpcyBmaXJzdCBjaGlsZCBpbiBwYXJlbnQsZG9uJ3QgcmVtb3ZlIGl0LlxuICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChwcmV2Tm9kZSkgJiYgRWRpdG9yLmlzRW1wdHkoZWRpdG9yLCBwcmV2Tm9kZSkgfHwgVGV4dC5pc1RleHQocHJldk5vZGUpICYmIHByZXZOb2RlLnRleHQgPT09ICcnICYmIHByZXZQYXRoW3ByZXZQYXRoLmxlbmd0aCAtIDFdICE9PSAwKSB7XG4gICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcHJldlBhdGgsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogJ21lcmdlX25vZGUnLFxuICAgICAgICBwYXRoOiBuZXdQYXRoLFxuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgcHJvcGVydGllc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbXB0eVJlZikge1xuICAgICAgZW1wdHlSZWYudW5yZWYoKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIG1vdmVOb2RlcyA9IChlZGl0b3IsIG9wdGlvbnMpID0+IHtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgdG8sXG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgfVxuICAgIHZhciB0b1JlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgdG8pO1xuICAgIHZhciB0YXJnZXRzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaCxcbiAgICAgIG1vZGUsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20odGFyZ2V0cywgX3JlZiA9PiB7XG4gICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgfSk7XG4gICAgZm9yICh2YXIgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICB2YXIgbmV3UGF0aCA9IHRvUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAocGF0aC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICB0eXBlOiAnbW92ZV9ub2RlJyxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIG5ld1BhdGhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodG9SZWYuY3VycmVudCAmJiBQYXRoLmlzU2libGluZyhuZXdQYXRoLCBwYXRoKSAmJiBQYXRoLmlzQWZ0ZXIobmV3UGF0aCwgcGF0aCkpIHtcbiAgICAgICAgLy8gV2hlbiBwZXJmb3JtaW5nIGEgc2libGluZyBtb3ZlIHRvIGEgbGF0ZXIgaW5kZXgsIHRoZSBwYXRoIGF0IHRoZSBkZXN0aW5hdGlvbiBpcyBzaGlmdGVkXG4gICAgICAgIC8vIHRvIGJlZm9yZSB0aGUgaW5zZXJ0aW9uIHBvaW50IGluc3RlYWQgb2YgYWZ0ZXIuIFRvIGVuc3VyZSBvdXIgZ3JvdXAgb2Ygbm9kZXMgYXJlIGluc2VydGVkXG4gICAgICAgIC8vIGluIHRoZSBjb3JyZWN0IG9yZGVyIHdlIGluY3JlbWVudCB0b1JlZiB0byBhY2NvdW50IGZvciB0aGF0XG4gICAgICAgIHRvUmVmLmN1cnJlbnQgPSBQYXRoLm5leHQodG9SZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRvUmVmLnVucmVmKCk7XG4gIH0pO1xufTtcblxudmFyIHJlbW92ZU5vZGVzID0gZnVuY3Rpb24gcmVtb3ZlTm9kZXMoZWRpdG9yKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZSxcbiAgICAgIG1vZGUgPSAnbG93ZXN0J1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtYXRjaFxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgIH1cbiAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZGVwdGhzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBtYXRjaCxcbiAgICAgIG1vZGUsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20oZGVwdGhzLCBfcmVmID0+IHtcbiAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHZhciBbbm9kZV0gPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZScsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBub2RlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgc2V0Tm9kZXMgPSBmdW5jdGlvbiBzZXROb2RlcyhlZGl0b3IsIHByb3BzKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICB2YXIge1xuICAgICAgbWF0Y2gsXG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBjb21wYXJlLFxuICAgICAgbWVyZ2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgc3BsaXQgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICB9XG4gICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNwbGl0ICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpICYmIEVkaXRvci5sZWFmKGVkaXRvciwgYXQuYW5jaG9yKVswXS50ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gSWYgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCBpbiBhIG5vbi1lbXB0eSBub2RlIGFuZCAnc3BsaXQnIGlzIHRydWUsIHRoZXJlJ3Mgbm90aGluZyB0b1xuICAgICAgICAvLyBzZXQgdGhhdCB3b24ndCBnZXQgbm9ybWFsaXplZCBhd2F5XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByYW5nZVJlZiA9IEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGF0LCB7XG4gICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgfSk7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgdmFyIHNwbGl0TW9kZSA9IG1vZGUgPT09ICdsb3dlc3QnID8gJ2xvd2VzdCcgOiAnaGlnaGVzdCc7XG4gICAgICB2YXIgZW5kQXRFbmRPZk5vZGUgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBlbmQsIGVuZC5wYXRoKTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIG1vZGU6IHNwbGl0TW9kZSxcbiAgICAgICAgdm9pZHMsXG4gICAgICAgIGFsd2F5czogIWVuZEF0RW5kT2ZOb2RlXG4gICAgICB9KTtcbiAgICAgIHZhciBzdGFydEF0U3RhcnRPZk5vZGUgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHN0YXJ0LCBzdGFydC5wYXRoKTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZTogc3BsaXRNb2RlLFxuICAgICAgICB2b2lkcyxcbiAgICAgICAgYWx3YXlzOiAhc3RhcnRBdFN0YXJ0T2ZOb2RlXG4gICAgICB9KTtcbiAgICAgIGF0ID0gcmFuZ2VSZWYudW5yZWYoKTtcbiAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY29tcGFyZSkge1xuICAgICAgY29tcGFyZSA9IChwcm9wLCBub2RlUHJvcCkgPT4gcHJvcCAhPT0gbm9kZVByb3A7XG4gICAgfVxuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgbW9kZSxcbiAgICAgIHZvaWRzXG4gICAgfSkpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAvLyBGSVhNRTogaXMgdGhpcyBjb3JyZWN0P1xuICAgICAgdmFyIG5ld1Byb3BlcnRpZXMgPSB7fTtcbiAgICAgIC8vIFlvdSBjYW4ndCBzZXQgcHJvcGVydGllcyBvbiB0aGUgZWRpdG9yIG5vZGUuXG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgaGFzQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgICAgICBpZiAoayA9PT0gJ2NoaWxkcmVuJyB8fCBrID09PSAndGV4dCcpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGFyZShwcm9wc1trXSwgbm9kZVtrXSkpIHtcbiAgICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAvLyBPbWl0IG5ldyBwcm9wZXJ0aWVzIGZyb20gdGhlIG9sZCBwcm9wZXJ0aWVzIGxpc3RcbiAgICAgICAgICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eShrKSkgcHJvcGVydGllc1trXSA9IG5vZGVba107XG4gICAgICAgICAgLy8gT21pdCBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbmV3IHByb3BlcnRpZXMgbGlzdFxuICAgICAgICAgIGlmIChtZXJnZSkge1xuICAgICAgICAgICAgaWYgKHByb3BzW2tdICE9IG51bGwpIG5ld1Byb3BlcnRpZXNba10gPSBtZXJnZShub2RlW2tdLCBwcm9wc1trXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9wc1trXSAhPSBudWxsKSBuZXdQcm9wZXJ0aWVzW2tdID0gcHJvcHNba107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzQ2hhbmdlcykge1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdzZXRfbm9kZScsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgIG5ld1Byb3BlcnRpZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHJhbmdlIGludG8gYSBwb2ludCBieSBkZWxldGluZyBpdCdzIGNvbnRlbnQuXG4gKi9cbnZhciBkZWxldGVSYW5nZSA9IChlZGl0b3IsIHJhbmdlKSA9PiB7XG4gIGlmIChSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkpIHtcbiAgICByZXR1cm4gcmFuZ2UuYW5jaG9yO1xuICB9IGVsc2Uge1xuICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICBhdDogcmFuZ2VcbiAgICB9KTtcbiAgICByZXR1cm4gcG9pbnRSZWYudW5yZWYoKTtcbiAgfVxufTtcbnZhciBzcGxpdE5vZGVzID0gZnVuY3Rpb24gc3BsaXROb2RlcyhlZGl0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoLFxuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgaGVpZ2h0ID0gMCxcbiAgICAgIGFsd2F5cyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIG1hdGNoID0gbiA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgIH1cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIGF0ID0gZGVsZXRlUmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgfVxuICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYSBwYXRoLCB0aGUgZGVmYXVsdCBoZWlnaHQtc2tpcHBpbmcgYW5kIHBvc2l0aW9uXG4gICAgLy8gY291bnRlcnMgbmVlZCB0byBhY2NvdW50IGZvciB1cyBwb3RlbnRpYWxseSBzcGxpdHRpbmcgYXQgYSBub24tbGVhZi5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICB2YXIgcGF0aCA9IGF0O1xuICAgICAgdmFyIHBvaW50ID0gRWRpdG9yLnBvaW50KGVkaXRvciwgcGF0aCk7XG4gICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCk7XG4gICAgICBtYXRjaCA9IG4gPT4gbiA9PT0gcGFyZW50O1xuICAgICAgaGVpZ2h0ID0gcG9pbnQucGF0aC5sZW5ndGggLSBwYXRoLmxlbmd0aCArIDE7XG4gICAgICBhdCA9IHBvaW50O1xuICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYmVmb3JlUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgYXQsIHtcbiAgICAgIGFmZmluaXR5OiAnYmFja3dhcmQnXG4gICAgfSk7XG4gICAgdmFyIGFmdGVyUmVmO1xuICAgIHRyeSB7XG4gICAgICB2YXIgW2hpZ2hlc3RdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIGlmICghaGlnaGVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdm9pZE1hdGNoID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICAgIH0pO1xuICAgICAgdmFyIG51ZGdlID0gMDtcbiAgICAgIGlmICghdm9pZHMgJiYgdm9pZE1hdGNoKSB7XG4gICAgICAgIHZhciBbdm9pZE5vZGUsIHZvaWRQYXRoXSA9IHZvaWRNYXRjaDtcbiAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KHZvaWROb2RlKSAmJiBlZGl0b3IuaXNJbmxpbmUodm9pZE5vZGUpKSB7XG4gICAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgdm9pZFBhdGgpO1xuICAgICAgICAgIGlmICghYWZ0ZXIpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0ge1xuICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBhZnRlclBhdGggPSBQYXRoLm5leHQodm9pZFBhdGgpO1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHRleHQsIHtcbiAgICAgICAgICAgICAgYXQ6IGFmdGVyUGF0aCxcbiAgICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWZ0ZXIgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhZnRlclBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdCA9IGFmdGVyO1xuICAgICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpYmxpbmdIZWlnaHQgPSBhdC5wYXRoLmxlbmd0aCAtIHZvaWRQYXRoLmxlbmd0aDtcbiAgICAgICAgaGVpZ2h0ID0gc2libGluZ0hlaWdodCArIDE7XG4gICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICB9XG4gICAgICBhZnRlclJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGF0KTtcbiAgICAgIHZhciBkZXB0aCA9IGF0LnBhdGgubGVuZ3RoIC0gaGVpZ2h0O1xuICAgICAgdmFyIFssIGhpZ2hlc3RQYXRoXSA9IGhpZ2hlc3Q7XG4gICAgICB2YXIgbG93ZXN0UGF0aCA9IGF0LnBhdGguc2xpY2UoMCwgZGVwdGgpO1xuICAgICAgdmFyIHBvc2l0aW9uID0gaGVpZ2h0ID09PSAwID8gYXQub2Zmc2V0IDogYXQucGF0aFtkZXB0aF0gKyBudWRnZTtcbiAgICAgIGZvciAodmFyIFtub2RlLCBfcGF0aF0gb2YgRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGxvd2VzdFBhdGgsXG4gICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KSkge1xuICAgICAgICB2YXIgc3BsaXQgPSBmYWxzZTtcbiAgICAgICAgaWYgKF9wYXRoLmxlbmd0aCA8IGhpZ2hlc3RQYXRoLmxlbmd0aCB8fCBfcGF0aC5sZW5ndGggPT09IDAgfHwgIXZvaWRzICYmIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfcG9pbnQgPSBiZWZvcmVSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIGlzRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgX3BvaW50LCBfcGF0aCk7XG4gICAgICAgIGlmIChhbHdheXMgfHwgIWJlZm9yZVJlZiB8fCAhRWRpdG9yLmlzRWRnZShlZGl0b3IsIF9wb2ludCwgX3BhdGgpKSB7XG4gICAgICAgICAgc3BsaXQgPSB0cnVlO1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gTm9kZS5leHRyYWN0UHJvcHMobm9kZSk7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdzcGxpdF9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb24gPSBfcGF0aFtfcGF0aC5sZW5ndGggLSAxXSArIChzcGxpdCB8fCBpc0VuZCA/IDEgOiAwKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmF0ID09IG51bGwpIHtcbiAgICAgICAgdmFyIF9wb2ludDIgPSBhZnRlclJlZi5jdXJyZW50IHx8IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX3BvaW50Mik7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHZhciBfYWZ0ZXJSZWY7XG4gICAgICBiZWZvcmVSZWYudW5yZWYoKTtcbiAgICAgIChfYWZ0ZXJSZWYgPSBhZnRlclJlZikgPT09IG51bGwgfHwgX2FmdGVyUmVmID09PSB2b2lkIDAgfHwgX2FmdGVyUmVmLnVucmVmKCk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciB1bnNldE5vZGVzID0gZnVuY3Rpb24gdW5zZXROb2RlcyhlZGl0b3IsIHByb3BzKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIHByb3BzID0gW3Byb3BzXTtcbiAgfVxuICB2YXIgb2JqID0ge307XG4gIGZvciAodmFyIGtleSBvZiBwcm9wcykge1xuICAgIG9ialtrZXldID0gbnVsbDtcbiAgfVxuICBUcmFuc2Zvcm1zLnNldE5vZGVzKGVkaXRvciwgb2JqLCBvcHRpb25zKTtcbn07XG5cbnZhciB1bndyYXBOb2RlcyA9IGZ1bmN0aW9uIHVud3JhcE5vZGVzKGVkaXRvcikge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgIHNwbGl0ID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgfVxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIGF0ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgIH1cbiAgICB2YXIgcmFuZ2VSZWYgPSBSYW5nZS5pc1JhbmdlKGF0KSA/IEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGF0KSA6IG51bGw7XG4gICAgdmFyIG1hdGNoZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoLFxuICAgICAgbW9kZSxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCBfcmVmID0+IHtcbiAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICB9XG4gICAgLy8gdW53cmFwTm9kZSB3aWxsIGNhbGwgbGlmdE5vZGUgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBzcGxpdHRpbmcgdGhlIG5vZGUgd2hlbiBuZXN0ZWQuXG4gICAgLy8gSWYgd2UgZG8gbm90IHJldmVyc2UgdGhlIG9yZGVyIGFuZCBjYWxsIGl0IGZyb20gdG9wIHRvIHRoZSBib3R0b20sIGl0IHdpbGwgcmVtb3ZlIGFsbCBibG9ja3NcbiAgICAvLyB0aGF0IHdyYXAgdGFyZ2V0IG5vZGUuIFNvIHdlIHJldmVyc2UgdGhlIG9yZGVyLlxuICAgICkucmV2ZXJzZSgpO1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHBhdGgpO1xuICAgICAgaWYgKHNwbGl0ICYmIHJhbmdlUmVmKSB7XG4gICAgICAgIHJhbmdlID0gUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlUmVmLmN1cnJlbnQsIHJhbmdlKTtcbiAgICAgIH1cbiAgICAgIFRyYW5zZm9ybXMubGlmdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcmFuZ2UsXG4gICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNBbmNlc3Rvcihub2RlKSAmJiBub2RlLmNoaWxkcmVuLmluY2x1ZGVzKG4pLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH1cbiAgICBpZiAocmFuZ2VSZWYpIHtcbiAgICAgIHJhbmdlUmVmLnVucmVmKCk7XG4gICAgfVxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIHdyYXBOb2RlcyA9IGZ1bmN0aW9uIHdyYXBOb2RlcyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICBzcGxpdCA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaCxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgbWF0Y2ggPSBtYXRjaFBhdGgoZWRpdG9yLCBhdCk7XG4gICAgICB9IGVsc2UgaWYgKGVkaXRvci5pc0lubGluZShlbGVtZW50KSkge1xuICAgICAgICBtYXRjaCA9IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbikgfHwgVGV4dC5pc1RleHQobik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaCA9IG4gPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNwbGl0ICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgdmFyIHJhbmdlUmVmID0gRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgYXQsIHtcbiAgICAgICAgYWZmaW5pdHk6ICdpbndhcmQnXG4gICAgICB9KTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgYXQgPSByYW5nZVJlZi51bnJlZigpO1xuICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJvb3RzID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdCxcbiAgICAgIG1hdGNoOiBlZGl0b3IuaXNJbmxpbmUoZWxlbWVudCkgPyBuID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbikgOiBuID0+IEVkaXRvci5pc0VkaXRvcihuKSxcbiAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgdm9pZHNcbiAgICB9KSk7XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgIHZhciBhID0gUmFuZ2UuaXNSYW5nZShhdCkgPyBSYW5nZS5pbnRlcnNlY3Rpb24oYXQsIEVkaXRvci5yYW5nZShlZGl0b3IsIHJvb3RQYXRoKSkgOiBhdDtcbiAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdGNoZXMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYSxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBbZmlyc3RdID0gbWF0Y2hlcztcbiAgICAgICAgICB2YXIgbGFzdCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICB2YXIgWywgZmlyc3RQYXRoXSA9IGZpcnN0O1xuICAgICAgICAgIHZhciBbLCBsYXN0UGF0aF0gPSBsYXN0O1xuICAgICAgICAgIGlmIChmaXJzdFBhdGgubGVuZ3RoID09PSAwICYmIGxhc3RQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBubyBtYXRjaGluZyBwYXJlbnQgLSB1c3VhbGx5IG1lYW5zIHRoZSBub2RlIGlzIGFuIGVkaXRvciAtIGRvbid0IGRvIGFueXRoaW5nXG4gICAgICAgICAgICByZXR1cm4gMDsgLy8gY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNvbW1vblBhdGggPSBQYXRoLmVxdWFscyhmaXJzdFBhdGgsIGxhc3RQYXRoKSA/IFBhdGgucGFyZW50KGZpcnN0UGF0aCkgOiBQYXRoLmNvbW1vbihmaXJzdFBhdGgsIGxhc3RQYXRoKTtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBmaXJzdFBhdGgsIGxhc3RQYXRoKTtcbiAgICAgICAgICB2YXIgY29tbW9uTm9kZUVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBjb21tb25QYXRoKTtcbiAgICAgICAgICB2YXIgW2NvbW1vbk5vZGVdID0gY29tbW9uTm9kZUVudHJ5O1xuICAgICAgICAgIHZhciBkZXB0aCA9IGNvbW1vblBhdGgubGVuZ3RoICsgMTtcbiAgICAgICAgICB2YXIgd3JhcHBlclBhdGggPSBQYXRoLm5leHQobGFzdFBhdGguc2xpY2UoMCwgZGVwdGgpKTtcbiAgICAgICAgICB2YXIgd3JhcHBlciA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZWxlbWVudCksIHt9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgd3JhcHBlciwge1xuICAgICAgICAgICAgYXQ6IHdyYXBwZXJQYXRoLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiByYW5nZSxcbiAgICAgICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNBbmNlc3Rvcihjb21tb25Ob2RlKSAmJiBjb21tb25Ob2RlLmNoaWxkcmVuLmluY2x1ZGVzKG4pLFxuICAgICAgICAgICAgdG86IHdyYXBwZXJQYXRoLmNvbmNhdCgwKSxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfcmV0O1xuICAgIGZvciAodmFyIFssIHJvb3RQYXRoXSBvZiByb290cykge1xuICAgICAgX3JldCA9IF9sb29wKCk7XG4gICAgICBpZiAoX3JldCA9PT0gMCkgY29udGludWU7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFNsYXRlIGBFZGl0b3JgIG9iamVjdC5cbiAqL1xudmFyIGNyZWF0ZUVkaXRvciA9ICgpID0+IHtcbiAgdmFyIGVkaXRvciA9IHtcbiAgICBjaGlsZHJlbjogW10sXG4gICAgb3BlcmF0aW9uczogW10sXG4gICAgc2VsZWN0aW9uOiBudWxsLFxuICAgIG1hcmtzOiBudWxsLFxuICAgIGlzRWxlbWVudFJlYWRPbmx5OiAoKSA9PiBmYWxzZSxcbiAgICBpc0lubGluZTogKCkgPT4gZmFsc2UsXG4gICAgaXNTZWxlY3RhYmxlOiAoKSA9PiB0cnVlLFxuICAgIGlzVm9pZDogKCkgPT4gZmFsc2UsXG4gICAgbWFya2FibGVWb2lkOiAoKSA9PiBmYWxzZSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge30sXG4gICAgLy8gQ29yZVxuICAgIGFwcGx5OiBmdW5jdGlvbiBhcHBseSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXBwbHkoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIC8vIEVkaXRvclxuICAgIGFkZE1hcms6IGZ1bmN0aW9uIGFkZE1hcmskMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG4gICAgICByZXR1cm4gYWRkTWFyayhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZGVsZXRlQmFja3dhcmQ6IGZ1bmN0aW9uIGRlbGV0ZUJhY2t3YXJkJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbGV0ZUJhY2t3YXJkKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBkZWxldGVGb3J3YXJkOiBmdW5jdGlvbiBkZWxldGVGb3J3YXJkJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlbGV0ZUZvcndhcmQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGRlbGV0ZUZyYWdtZW50OiBmdW5jdGlvbiBkZWxldGVGcmFnbWVudCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTVdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWxldGVGcmFnbWVudChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZ2V0RnJhZ21lbnQ6IGZ1bmN0aW9uIGdldEZyYWdtZW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5Nl0gPSBhcmd1bWVudHNbX2tleTZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEZyYWdtZW50KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpbnNlcnRCcmVhazogZnVuY3Rpb24gaW5zZXJ0QnJlYWskMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNyksIF9rZXk3ID0gMDsgX2tleTcgPCBfbGVuNzsgX2tleTcrKykge1xuICAgICAgICBhcmdzW19rZXk3XSA9IGFyZ3VtZW50c1tfa2V5N107XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zZXJ0QnJlYWsoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGluc2VydFNvZnRCcmVhazogZnVuY3Rpb24gaW5zZXJ0U29mdEJyZWFrJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuOCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjgpLCBfa2V5OCA9IDA7IF9rZXk4IDwgX2xlbjg7IF9rZXk4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5OF0gPSBhcmd1bWVudHNbX2tleThdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc2VydFNvZnRCcmVhayhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaW5zZXJ0RnJhZ21lbnQ6IGZ1bmN0aW9uIGluc2VydEZyYWdtZW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuOSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjkpLCBfa2V5OSA9IDA7IF9rZXk5IDwgX2xlbjk7IF9rZXk5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5OV0gPSBhcmd1bWVudHNbX2tleTldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc2VydEZyYWdtZW50KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpbnNlcnROb2RlOiBmdW5jdGlvbiBpbnNlcnROb2RlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMCksIF9rZXkxMCA9IDA7IF9rZXkxMCA8IF9sZW4xMDsgX2tleTEwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTBdID0gYXJndW1lbnRzW19rZXkxMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zZXJ0Tm9kZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaW5zZXJ0VGV4dDogZnVuY3Rpb24gaW5zZXJ0VGV4dCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjExID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTEpLCBfa2V5MTEgPSAwOyBfa2V5MTEgPCBfbGVuMTE7IF9rZXkxMSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTExXSA9IGFyZ3VtZW50c1tfa2V5MTFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc2VydFRleHQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZU5vZGU6IGZ1bmN0aW9uIG5vcm1hbGl6ZU5vZGUkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjEyKSwgX2tleTEyID0gMDsgX2tleTEyIDwgX2xlbjEyOyBfa2V5MTIrKykge1xuICAgICAgICBhcmdzW19rZXkxMl0gPSBhcmd1bWVudHNbX2tleTEyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3JtYWxpemVOb2RlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICByZW1vdmVNYXJrOiBmdW5jdGlvbiByZW1vdmVNYXJrJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xMyksIF9rZXkxMyA9IDA7IF9rZXkxMyA8IF9sZW4xMzsgX2tleTEzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTNdID0gYXJndW1lbnRzW19rZXkxM107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlTWFyayhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZ2V0RGlydHlQYXRoczogZnVuY3Rpb24gZ2V0RGlydHlQYXRocyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTQpLCBfa2V5MTQgPSAwOyBfa2V5MTQgPCBfbGVuMTQ7IF9rZXkxNCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTE0XSA9IGFyZ3VtZW50c1tfa2V5MTRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldERpcnR5UGF0aHMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHNob3VsZE5vcm1hbGl6ZTogZnVuY3Rpb24gc2hvdWxkTm9ybWFsaXplJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xNSksIF9rZXkxNSA9IDA7IF9rZXkxNSA8IF9sZW4xNTsgX2tleTE1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTVdID0gYXJndW1lbnRzW19rZXkxNV07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hvdWxkTm9ybWFsaXplKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICAvLyBFZGl0b3IgaW50ZXJmYWNlXG4gICAgYWJvdmU6IGZ1bmN0aW9uIGFib3ZlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xNiksIF9rZXkxNiA9IDA7IF9rZXkxNiA8IF9sZW4xNjsgX2tleTE2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTZdID0gYXJndW1lbnRzW19rZXkxNl07XG4gICAgICB9XG4gICAgICByZXR1cm4gYWJvdmUoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGFmdGVyOiBmdW5jdGlvbiBhZnRlciQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE3ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTcpLCBfa2V5MTcgPSAwOyBfa2V5MTcgPCBfbGVuMTc7IF9rZXkxNysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTE3XSA9IGFyZ3VtZW50c1tfa2V5MTddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFmdGVyKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBiZWZvcmU6IGZ1bmN0aW9uIGJlZm9yZSQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjE4ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMTgpLCBfa2V5MTggPSAwOyBfa2V5MTggPCBfbGVuMTg7IF9rZXkxOCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTE4XSA9IGFyZ3VtZW50c1tfa2V5MThdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJlZm9yZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgY29sbGFwc2U6IGZ1bmN0aW9uIGNvbGxhcHNlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMTkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4xOSksIF9rZXkxOSA9IDA7IF9rZXkxOSA8IF9sZW4xOTsgX2tleTE5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MTldID0gYXJndW1lbnRzW19rZXkxOV07XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sbGFwc2UoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGRlbGV0ZTogZnVuY3Rpb24gX2RlbGV0ZSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yMCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIwKSwgX2tleTIwID0gMDsgX2tleTIwIDwgX2xlbjIwOyBfa2V5MjArKykge1xuICAgICAgICBhcmdzW19rZXkyMF0gPSBhcmd1bWVudHNbX2tleTIwXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWxldGVUZXh0KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBkZXNlbGVjdDogZnVuY3Rpb24gZGVzZWxlY3QkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yMSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIxKSwgX2tleTIxID0gMDsgX2tleTIxIDwgX2xlbjIxOyBfa2V5MjErKykge1xuICAgICAgICBhcmdzW19rZXkyMV0gPSBhcmd1bWVudHNbX2tleTIxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNlbGVjdChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yMiksIF9rZXkyMiA9IDA7IF9rZXkyMiA8IF9sZW4yMjsgX2tleTIyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjJdID0gYXJndW1lbnRzW19rZXkyMl07XG4gICAgICB9XG4gICAgICByZXR1cm4gZWRnZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGVsZW1lbnRSZWFkT25seTogZnVuY3Rpb24gZWxlbWVudFJlYWRPbmx5JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yMyksIF9rZXkyMyA9IDA7IF9rZXkyMyA8IF9sZW4yMzsgX2tleTIzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjNdID0gYXJndW1lbnRzW19rZXkyM107XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudFJlYWRPbmx5KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjI0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjQpLCBfa2V5MjQgPSAwOyBfa2V5MjQgPCBfbGVuMjQ7IF9rZXkyNCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTI0XSA9IGFyZ3VtZW50c1tfa2V5MjRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVuZChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZmlyc3Q6IGZ1bmN0aW9uIGZpcnN0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yNSksIF9rZXkyNSA9IDA7IF9rZXkyNSA8IF9sZW4yNTsgX2tleTI1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjVdID0gYXJndW1lbnRzW19rZXkyNV07XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3QoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGZyYWdtZW50OiBmdW5jdGlvbiBmcmFnbWVudCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjI2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMjYpLCBfa2V5MjYgPSAwOyBfa2V5MjYgPCBfbGVuMjY7IF9rZXkyNisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTI2XSA9IGFyZ3VtZW50c1tfa2V5MjZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyYWdtZW50KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBnZXRNYXJrczogZnVuY3Rpb24gZ2V0TWFya3MoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yNyksIF9rZXkyNyA9IDA7IF9rZXkyNyA8IF9sZW4yNzsgX2tleTI3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjddID0gYXJndW1lbnRzW19rZXkyN107XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFya3MoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGhhc0Jsb2NrczogZnVuY3Rpb24gaGFzQmxvY2tzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yOCksIF9rZXkyOCA9IDA7IF9rZXkyOCA8IF9sZW4yODsgX2tleTI4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjhdID0gYXJndW1lbnRzW19rZXkyOF07XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzQmxvY2tzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBoYXNJbmxpbmVzOiBmdW5jdGlvbiBoYXNJbmxpbmVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMjkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yOSksIF9rZXkyOSA9IDA7IF9rZXkyOSA8IF9sZW4yOTsgX2tleTI5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MjldID0gYXJndW1lbnRzW19rZXkyOV07XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzSW5saW5lcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaGFzUGF0aDogZnVuY3Rpb24gaGFzUGF0aCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzApLCBfa2V5MzAgPSAwOyBfa2V5MzAgPCBfbGVuMzA7IF9rZXkzMCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTMwXSA9IGFyZ3VtZW50c1tfa2V5MzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1BhdGgoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGhhc1RleHRzOiBmdW5jdGlvbiBoYXNUZXh0cyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzEpLCBfa2V5MzEgPSAwOyBfa2V5MzEgPCBfbGVuMzE7IF9rZXkzMSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTMxXSA9IGFyZ3VtZW50c1tfa2V5MzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1RleHRzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpbnNlcnROb2RlczogZnVuY3Rpb24gaW5zZXJ0Tm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMyKSwgX2tleTMyID0gMDsgX2tleTMyIDwgX2xlbjMyOyBfa2V5MzIrKykge1xuICAgICAgICBhcmdzW19rZXkzMl0gPSBhcmd1bWVudHNbX2tleTMyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnNlcnROb2RlcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaXNCbG9jazogZnVuY3Rpb24gaXNCbG9jayQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMzID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzMpLCBfa2V5MzMgPSAwOyBfa2V5MzMgPCBfbGVuMzM7IF9rZXkzMysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTMzXSA9IGFyZ3VtZW50c1tfa2V5MzNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQmxvY2soZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGlzRWRnZTogZnVuY3Rpb24gaXNFZGdlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zNCksIF9rZXkzNCA9IDA7IF9rZXkzNCA8IF9sZW4zNDsgX2tleTM0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzRdID0gYXJndW1lbnRzW19rZXkzNF07XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNFZGdlKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zNSksIF9rZXkzNSA9IDA7IF9rZXkzNSA8IF9sZW4zNTsgX2tleTM1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzVdID0gYXJndW1lbnRzW19rZXkzNV07XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNFbXB0eShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgaXNFbmQ6IGZ1bmN0aW9uIGlzRW5kJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zNiksIF9rZXkzNiA9IDA7IF9rZXkzNiA8IF9sZW4zNjsgX2tleTM2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzZdID0gYXJndW1lbnRzW19rZXkzNl07XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNFbmQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGlzTm9ybWFsaXppbmc6IGZ1bmN0aW9uIGlzTm9ybWFsaXppbmckMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4zNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjM3KSwgX2tleTM3ID0gMDsgX2tleTM3IDwgX2xlbjM3OyBfa2V5MzcrKykge1xuICAgICAgICBhcmdzW19rZXkzN10gPSBhcmd1bWVudHNbX2tleTM3XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc05vcm1hbGl6aW5nKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBpc1N0YXJ0OiBmdW5jdGlvbiBpc1N0YXJ0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMzggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zOCksIF9rZXkzOCA9IDA7IF9rZXkzOCA8IF9sZW4zODsgX2tleTM4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5MzhdID0gYXJndW1lbnRzW19rZXkzOF07XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTdGFydChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgbGFzdDogZnVuY3Rpb24gbGFzdCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjM5ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMzkpLCBfa2V5MzkgPSAwOyBfa2V5MzkgPCBfbGVuMzk7IF9rZXkzOSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTM5XSA9IGFyZ3VtZW50c1tfa2V5MzldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3QoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIGxlYWY6IGZ1bmN0aW9uIGxlYWYkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40MCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQwKSwgX2tleTQwID0gMDsgX2tleTQwIDwgX2xlbjQwOyBfa2V5NDArKykge1xuICAgICAgICBhcmdzW19rZXk0MF0gPSBhcmd1bWVudHNbX2tleTQwXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWFmKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBsZXZlbHM6IGZ1bmN0aW9uIGxldmVscyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNDEpLCBfa2V5NDEgPSAwOyBfa2V5NDEgPCBfbGVuNDE7IF9rZXk0MSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTQxXSA9IGFyZ3VtZW50c1tfa2V5NDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxldmVscyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgbGlmdE5vZGVzOiBmdW5jdGlvbiBsaWZ0Tm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40MiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQyKSwgX2tleTQyID0gMDsgX2tleTQyIDwgX2xlbjQyOyBfa2V5NDIrKykge1xuICAgICAgICBhcmdzW19rZXk0Ml0gPSBhcmd1bWVudHNbX2tleTQyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaWZ0Tm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG1lcmdlTm9kZXM6IGZ1bmN0aW9uIG1lcmdlTm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40MyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQzKSwgX2tleTQzID0gMDsgX2tleTQzIDwgX2xlbjQzOyBfa2V5NDMrKykge1xuICAgICAgICBhcmdzW19rZXk0M10gPSBhcmd1bWVudHNbX2tleTQzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZU5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBtb3ZlOiBmdW5jdGlvbiBtb3ZlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40NCksIF9rZXk0NCA9IDA7IF9rZXk0NCA8IF9sZW40NDsgX2tleTQ0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDRdID0gYXJndW1lbnRzW19rZXk0NF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbW92ZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgbW92ZU5vZGVzOiBmdW5jdGlvbiBtb3ZlTm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40NSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQ1KSwgX2tleTQ1ID0gMDsgX2tleTQ1IDwgX2xlbjQ1OyBfa2V5NDUrKykge1xuICAgICAgICBhcmdzW19rZXk0NV0gPSBhcmd1bWVudHNbX2tleTQ1XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtb3ZlTm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW40NiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQ2KSwgX2tleTQ2ID0gMDsgX2tleTQ2IDwgX2xlbjQ2OyBfa2V5NDYrKykge1xuICAgICAgICBhcmdzW19rZXk0Nl0gPSBhcmd1bWVudHNbX2tleTQ2XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0KGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBub2RlOiBmdW5jdGlvbiBub2RlJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40NyksIF9rZXk0NyA9IDA7IF9rZXk0NyA8IF9sZW40NzsgX2tleTQ3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDddID0gYXJndW1lbnRzW19rZXk0N107XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgbm9kZXM6IGZ1bmN0aW9uIG5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40OCksIF9rZXk0OCA9IDA7IF9rZXk0OCA8IF9sZW40ODsgX2tleTQ4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDhdID0gYXJndW1lbnRzW19rZXk0OF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24gbm9ybWFsaXplJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNDkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40OSksIF9rZXk0OSA9IDA7IF9rZXk0OSA8IF9sZW40OTsgX2tleTQ5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NDldID0gYXJndW1lbnRzW19rZXk0OV07XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9ybWFsaXplKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjUwID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTApLCBfa2V5NTAgPSAwOyBfa2V5NTAgPCBfbGVuNTA7IF9rZXk1MCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTUwXSA9IGFyZ3VtZW50c1tfa2V5NTBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudChlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcGF0aDogZnVuY3Rpb24gcGF0aCQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjUxID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTEpLCBfa2V5NTEgPSAwOyBfa2V5NTEgPCBfbGVuNTE7IF9rZXk1MSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTUxXSA9IGFyZ3VtZW50c1tfa2V5NTFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGgoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBhdGhSZWY6IGZ1bmN0aW9uIHBhdGhSZWYkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41MiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUyKSwgX2tleTUyID0gMDsgX2tleTUyIDwgX2xlbjUyOyBfa2V5NTIrKykge1xuICAgICAgICBhcmdzW19rZXk1Ml0gPSBhcmd1bWVudHNbX2tleTUyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoUmVmKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwYXRoUmVmczogZnVuY3Rpb24gcGF0aFJlZnMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41MyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUzKSwgX2tleTUzID0gMDsgX2tleTUzIDwgX2xlbjUzOyBfa2V5NTMrKykge1xuICAgICAgICBhcmdzW19rZXk1M10gPSBhcmd1bWVudHNbX2tleTUzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoUmVmcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcG9pbnQ6IGZ1bmN0aW9uIHBvaW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNTQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41NCksIF9rZXk1NCA9IDA7IF9rZXk1NCA8IF9sZW41NDsgX2tleTU0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NTRdID0gYXJndW1lbnRzW19rZXk1NF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9pbnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHBvaW50UmVmOiBmdW5jdGlvbiBwb2ludFJlZiQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTUpLCBfa2V5NTUgPSAwOyBfa2V5NTUgPCBfbGVuNTU7IF9rZXk1NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU1XSA9IGFyZ3VtZW50c1tfa2V5NTVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvaW50UmVmKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBwb2ludFJlZnM6IGZ1bmN0aW9uIHBvaW50UmVmcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU2ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTYpLCBfa2V5NTYgPSAwOyBfa2V5NTYgPCBfbGVuNTY7IF9rZXk1NisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU2XSA9IGFyZ3VtZW50c1tfa2V5NTZdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvaW50UmVmcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcG9zaXRpb25zOiBmdW5jdGlvbiBwb3NpdGlvbnMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41NyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjU3KSwgX2tleTU3ID0gMDsgX2tleTU3IDwgX2xlbjU3OyBfa2V5NTcrKykge1xuICAgICAgICBhcmdzW19rZXk1N10gPSBhcmd1bWVudHNbX2tleTU3XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3NpdGlvbnMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjU4ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNTgpLCBfa2V5NTggPSAwOyBfa2V5NTggPCBfbGVuNTg7IF9rZXk1OCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTU4XSA9IGFyZ3VtZW50c1tfa2V5NThdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXZpb3VzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICByYW5nZTogZnVuY3Rpb24gcmFuZ2UkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW41OSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjU5KSwgX2tleTU5ID0gMDsgX2tleTU5IDwgX2xlbjU5OyBfa2V5NTkrKykge1xuICAgICAgICBhcmdzW19rZXk1OV0gPSBhcmd1bWVudHNbX2tleTU5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYW5nZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgcmFuZ2VSZWY6IGZ1bmN0aW9uIHJhbmdlUmVmJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42MCksIF9rZXk2MCA9IDA7IF9rZXk2MCA8IF9sZW42MDsgX2tleTYwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjBdID0gYXJndW1lbnRzW19rZXk2MF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFuZ2VSZWYoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHJhbmdlUmVmczogZnVuY3Rpb24gcmFuZ2VSZWZzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjEgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42MSksIF9rZXk2MSA9IDA7IF9rZXk2MSA8IF9sZW42MTsgX2tleTYxKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjFdID0gYXJndW1lbnRzW19rZXk2MV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFuZ2VSZWZzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICByZW1vdmVOb2RlczogZnVuY3Rpb24gcmVtb3ZlTm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42MiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYyKSwgX2tleTYyID0gMDsgX2tleTYyIDwgX2xlbjYyOyBfa2V5NjIrKykge1xuICAgICAgICBhcmdzW19rZXk2Ml0gPSBhcmd1bWVudHNbX2tleTYyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVOb2RlcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgc2VsZWN0OiBmdW5jdGlvbiBzZWxlY3QkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42MyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYzKSwgX2tleTYzID0gMDsgX2tleTYzIDwgX2xlbjYzOyBfa2V5NjMrKykge1xuICAgICAgICBhcmdzW19rZXk2M10gPSBhcmd1bWVudHNbX2tleTYzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3QoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHNldE5vZGVzOiBmdW5jdGlvbiBzZXROb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjY0ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNjQpLCBfa2V5NjQgPSAwOyBfa2V5NjQgPCBfbGVuNjQ7IF9rZXk2NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTY0XSA9IGFyZ3VtZW50c1tfa2V5NjRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldE5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzZXROb3JtYWxpemluZzogZnVuY3Rpb24gc2V0Tm9ybWFsaXppbmckMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42NSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjY1KSwgX2tleTY1ID0gMDsgX2tleTY1IDwgX2xlbjY1OyBfa2V5NjUrKykge1xuICAgICAgICBhcmdzW19rZXk2NV0gPSBhcmd1bWVudHNbX2tleTY1XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXROb3JtYWxpemluZyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgc2V0UG9pbnQ6IGZ1bmN0aW9uIHNldFBvaW50JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42NiksIF9rZXk2NiA9IDA7IF9rZXk2NiA8IF9sZW42NjsgX2tleTY2KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjZdID0gYXJndW1lbnRzW19rZXk2Nl07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0UG9pbnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gc2V0U2VsZWN0aW9uJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42NyksIF9rZXk2NyA9IDA7IF9rZXk2NyA8IF9sZW42NzsgX2tleTY3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjddID0gYXJndW1lbnRzW19rZXk2N107XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0U2VsZWN0aW9uKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICBzcGxpdE5vZGVzOiBmdW5jdGlvbiBzcGxpdE5vZGVzJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42OCksIF9rZXk2OCA9IDA7IF9rZXk2OCA8IF9sZW42ODsgX2tleTY4KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjhdID0gYXJndW1lbnRzW19rZXk2OF07XG4gICAgICB9XG4gICAgICByZXR1cm4gc3BsaXROb2RlcyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0JDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNjkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42OSksIF9rZXk2OSA9IDA7IF9rZXk2OSA8IF9sZW42OTsgX2tleTY5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NjldID0gYXJndW1lbnRzW19rZXk2OV07XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhcnQoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nJDEoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNzAgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43MCksIF9rZXk3MCA9IDA7IF9rZXk3MCA8IF9sZW43MDsgX2tleTcwKyspIHtcbiAgICAgICAgYXJnc1tfa2V5NzBdID0gYXJndW1lbnRzW19rZXk3MF07XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICB1bmhhbmdSYW5nZTogZnVuY3Rpb24gdW5oYW5nUmFuZ2UkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43MSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcxKSwgX2tleTcxID0gMDsgX2tleTcxIDwgX2xlbjcxOyBfa2V5NzErKykge1xuICAgICAgICBhcmdzW19rZXk3MV0gPSBhcmd1bWVudHNbX2tleTcxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmhhbmdSYW5nZShlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgdW5zZXROb2RlczogZnVuY3Rpb24gdW5zZXROb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjcyID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzIpLCBfa2V5NzIgPSAwOyBfa2V5NzIgPCBfbGVuNzI7IF9rZXk3MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTcyXSA9IGFyZ3VtZW50c1tfa2V5NzJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuc2V0Tm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIHVud3JhcE5vZGVzOiBmdW5jdGlvbiB1bndyYXBOb2RlcyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjczID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzMpLCBfa2V5NzMgPSAwOyBfa2V5NzMgPCBfbGVuNzM7IF9rZXk3MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTczXSA9IGFyZ3VtZW50c1tfa2V5NzNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVud3JhcE5vZGVzKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICB2b2lkOiBmdW5jdGlvbiBfdm9pZCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43NCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjc0KSwgX2tleTc0ID0gMDsgX2tleTc0IDwgX2xlbjc0OyBfa2V5NzQrKykge1xuICAgICAgICBhcmdzW19rZXk3NF0gPSBhcmd1bWVudHNbX2tleTc0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRWb2lkKGVkaXRvciwgLi4uYXJncyk7XG4gICAgfSxcbiAgICB3aXRob3V0Tm9ybWFsaXppbmc6IGZ1bmN0aW9uIHdpdGhvdXROb3JtYWxpemluZyQxKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjc1ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNzUpLCBfa2V5NzUgPSAwOyBfa2V5NzUgPCBfbGVuNzU7IF9rZXk3NSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTc1XSA9IGFyZ3VtZW50c1tfa2V5NzVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsIC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgd3JhcE5vZGVzOiBmdW5jdGlvbiB3cmFwTm9kZXMkMSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW43NiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjc2KSwgX2tleTc2ID0gMDsgX2tleTc2IDwgX2xlbjc2OyBfa2V5NzYrKykge1xuICAgICAgICBhcmdzW19rZXk3Nl0gPSBhcmd1bWVudHNbX2tleTc2XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwTm9kZXMoZWRpdG9yLCAuLi5hcmdzKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG5leHBvcnQgeyBFZGl0b3IsIEVsZW1lbnQsIExvY2F0aW9uLCBOb2RlLCBPcGVyYXRpb24sIFBhdGgsIFBhdGhSZWYsIFBvaW50LCBQb2ludFJlZiwgUmFuZ2UsIFJhbmdlUmVmLCBTY3J1YmJlciwgU3BhbiwgVGV4dCwgVHJhbnNmb3JtcywgYWJvdmUsIGFkZE1hcmssIGFmdGVyLCBhcHBseSwgYmVmb3JlLCBjb2xsYXBzZSwgY3JlYXRlRWRpdG9yLCBkZWxldGVCYWNrd2FyZCwgZGVsZXRlRm9yd2FyZCwgZGVsZXRlRnJhZ21lbnQsIGRlbGV0ZVRleHQsIGRlc2VsZWN0LCBlZGdlcywgZWxlbWVudFJlYWRPbmx5LCBlbmQsIGZpcnN0LCBmcmFnbWVudCwgZ2V0RGlydHlQYXRocywgZ2V0RnJhZ21lbnQsIGdldFZvaWQsIGhhc0Jsb2NrcywgaGFzSW5saW5lcywgaGFzUGF0aCwgaGFzVGV4dHMsIGluc2VydEJyZWFrLCBpbnNlcnRGcmFnbWVudCwgaW5zZXJ0Tm9kZSwgaW5zZXJ0Tm9kZXMsIGluc2VydFNvZnRCcmVhaywgaW5zZXJ0VGV4dCwgaXNCbG9jaywgaXNFZGdlLCBpc0VkaXRvciwgaXNFbXB0eSwgaXNFbmQsIGlzTm9ybWFsaXppbmcsIGlzU3RhcnQsIGxhc3QsIGxlYWYsIGxldmVscywgbGlmdE5vZGVzLCBtYXJrcywgbWVyZ2VOb2RlcywgbW92ZSwgbW92ZU5vZGVzLCBuZXh0LCBub2RlLCBub2Rlcywgbm9ybWFsaXplLCBub3JtYWxpemVOb2RlLCBwYXJlbnQsIHBhdGgsIHBhdGhSZWYsIHBhdGhSZWZzLCBwb2ludCwgcG9pbnRSZWYsIHBvaW50UmVmcywgcG9zaXRpb25zLCBwcmV2aW91cywgcmFuZ2UsIHJhbmdlUmVmLCByYW5nZVJlZnMsIHJlbW92ZU1hcmssIHJlbW92ZU5vZGVzLCBzZWxlY3QsIHNldE5vZGVzLCBzZXROb3JtYWxpemluZywgc2V0UG9pbnQsIHNldFNlbGVjdGlvbiwgc2hvdWxkTm9ybWFsaXplLCBzcGxpdE5vZGVzLCBzdGFydCwgc3RyaW5nLCB1bmhhbmdSYW5nZSwgdW5zZXROb2RlcywgdW53cmFwTm9kZXMsIHdpdGhvdXROb3JtYWxpemluZywgd3JhcE5vZGVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJpc1BsYWluT2JqZWN0IiwiY3JlYXRlRHJhZnQiLCJmaW5pc2hEcmFmdCIsImlzRHJhZnQiLCJwcm9kdWNlIiwiUGF0aFJlZiIsInRyYW5zZm9ybSIsInJlZiIsIm9wIiwiY3VycmVudCIsImFmZmluaXR5IiwicGF0aCIsIlBhdGgiLCJ1bnJlZiIsIlBvaW50UmVmIiwicG9pbnQiLCJQb2ludCIsIlJhbmdlUmVmIiwiUmFuZ2UiLCJESVJUWV9QQVRIUyIsIldlYWtNYXAiLCJESVJUWV9QQVRIX0tFWVMiLCJGTFVTSElORyIsIk5PUk1BTElaSU5HIiwiUEFUSF9SRUZTIiwiUE9JTlRfUkVGUyIsIlJBTkdFX1JFRlMiLCJhbmNlc3RvcnMiLCJvcHRpb25zIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwicmV2ZXJzZSIsInBhdGhzIiwibGV2ZWxzIiwic2xpY2UiLCJjb21tb24iLCJhbm90aGVyIiwiaSIsImF2IiwiYnYiLCJwdXNoIiwiY29tcGFyZSIsIm1pbiIsIk1hdGgiLCJlbmRzQWZ0ZXIiLCJhcyIsImJzIiwiZXF1YWxzIiwiZW5kc0F0IiwiZW5kc0JlZm9yZSIsImV2ZXJ5IiwibiIsImhhc1ByZXZpb3VzIiwiaXNBZnRlciIsImlzQW5jZXN0b3IiLCJpc0JlZm9yZSIsImlzQ2hpbGQiLCJpc0NvbW1vbiIsImlzRGVzY2VuZGFudCIsImlzUGFyZW50IiwiaXNQYXRoIiwidmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJpc1NpYmxpbmciLCJhbCIsImJsIiwibGlzdCIsIm5leHQiLCJFcnJvciIsImNvbmNhdCIsImxhc3QiLCJvcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoIiwib3BlcmF0aW9uIiwidHlwZSIsInBhcmVudCIsInByZXZpb3VzIiwicmVsYXRpdmUiLCJhbmNlc3RvciIsInAiLCJfb3AiLCJfb3AyIiwicG9zaXRpb24iLCJfb3AzIiwiX3Bvc2l0aW9uIiwiX29wNCIsIm5ld1BhdGgiLCJvbnAiLCJjb3B5IiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX3RvUHJpbWl0aXZlIiwiaW5wdXQiLCJoaW50IiwicHJpbSIsInRvUHJpbWl0aXZlIiwicmVzIiwiY2FsbCIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsIl90b1Byb3BlcnR5S2V5IiwiYXJnIiwia2V5IiwiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJvd25LZXlzJGUiLCJlIiwiciIsInQiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiYXBwbHkiLCJfb2JqZWN0U3ByZWFkJGUiLCJmb3JFYWNoIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJhcHBseVRvRHJhZnQiLCJlZGl0b3IiLCJzZWxlY3Rpb24iLCJub2RlIiwiTm9kZSIsImluZGV4IiwiY2hpbGRyZW4iLCJzcGxpY2UiLCJwb2ludHMiLCJfcGF0aCIsIm9mZnNldCIsInRleHQiLCJfbm9kZSIsImxlYWYiLCJiZWZvcmUiLCJhZnRlciIsIl9wb2ludCIsIl9rZXkiLCJfcGF0aDIiLCJfbm9kZTIiLCJnZXQiLCJwcmV2UGF0aCIsInByZXYiLCJfcGFyZW50IiwiX2luZGV4IiwiVGV4dCIsImlzVGV4dCIsIlNjcnViYmVyIiwic3RyaW5naWZ5IiwiX3BvaW50MiIsIl9rZXkyIiwiX3BhdGgzIiwiX25vZGUzIiwiX3BhcmVudDIiLCJfaW5kZXgyIiwidHJ1ZVBhdGgiLCJuZXdQYXJlbnQiLCJuZXdJbmRleCIsIl9wb2ludDMiLCJfa2V5MyIsIl9wYXRoNCIsIl9pbmRleDMiLCJfcGFyZW50MyIsIl9wb2ludDQiLCJfa2V5NCIsInJlc3VsdCIsIl9wcmV2IiwidGV4dHMiLCJwcmVmZXJOZXh0IiwiX3BhdGg1IiwiX29mZnNldCIsIl90ZXh0IiwiX25vZGU0IiwiX2JlZm9yZSIsIl9hZnRlciIsIl9wb2ludDUiLCJfa2V5NSIsIl9wYXRoNiIsInByb3BlcnRpZXMiLCJuZXdQcm9wZXJ0aWVzIiwiX25vZGU1IiwiX2tleTYiLCJfa2V5NyIsImhhc093blByb3BlcnR5IiwiX25ld1Byb3BlcnRpZXMiLCJpc1JhbmdlIiwiX2tleTgiLCJfdmFsdWUiLCJfcGF0aDciLCJfcHJvcGVydGllcyIsIl9ub2RlNiIsIl9wYXJlbnQ0IiwiX2luZGV4NCIsIm5ld05vZGUiLCJfYmVmb3JlMiIsIl9hZnRlcjIiLCJfYmVmb3JlMyIsIl9hZnRlcjMiLCJfcG9pbnQ2IiwiX2tleTkiLCJHZW5lcmFsVHJhbnNmb3JtcyIsIk5vZGVUcmFuc2Zvcm1zIiwiaW5zZXJ0Tm9kZXMiLCJub2RlcyIsImxpZnROb2RlcyIsIm1lcmdlTm9kZXMiLCJtb3ZlTm9kZXMiLCJyZW1vdmVOb2RlcyIsInNldE5vZGVzIiwicHJvcHMiLCJzcGxpdE5vZGVzIiwidW5zZXROb2RlcyIsInVud3JhcE5vZGVzIiwid3JhcE5vZGVzIiwiZWxlbWVudCIsIlNlbGVjdGlvblRyYW5zZm9ybXMiLCJjb2xsYXBzZSIsImRlc2VsZWN0IiwibW92ZSIsInNlbGVjdCIsInRhcmdldCIsInNldFBvaW50Iiwic2V0U2VsZWN0aW9uIiwiaXNEZWVwRXF1YWwiLCJhIiwiYiIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwic291cmNlIiwiZXhjbHVkZWQiLCJzb3VyY2VLZXlzIiwiaW5kZXhPZiIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsInNvdXJjZVN5bWJvbEtleXMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9leGNsdWRlZCQ0Iiwib3duS2V5cyRkIiwiX29iamVjdFNwcmVhZCRkIiwiZWRnZXMiLCJyYW5nZSIsImFuY2hvciIsImZvY3VzIiwiaXNCYWNrd2FyZCIsImVuZCIsImluY2x1ZGVzIiwicnMiLCJyZSIsInRzIiwidGUiLCJzdGFydCIsImlzQWZ0ZXJTdGFydCIsImlzQmVmb3JlRW5kIiwiaXNQb2ludCIsImludGVyc2VjdGlvbiIsInJlc3QiLCJzMSIsImUxIiwiczIiLCJlMiIsImlzQ29sbGFwc2VkIiwiaXNFeHBhbmRlZCIsImlzRm9yd2FyZCIsImFmZmluaXR5QW5jaG9yIiwiYWZmaW5pdHlGb2N1cyIsImlzRWxlbWVudCIsImlzTm9kZUxpc3QiLCJFZGl0b3IiLCJpc0VkaXRvciIsIkVsZW1lbnQiLCJpc0VsZW1lbnRMaXN0IiwidmFsIiwiaXNFbGVtZW50UHJvcHMiLCJpc0VsZW1lbnRUeXBlIiwiZWxlbWVudFZhbCIsImVsZW1lbnRLZXkiLCJtYXRjaGVzIiwiX2V4Y2x1ZGVkJDMiLCJfZXhjbHVkZWQyJDMiLCJJU19OT0RFX0xJU1RfQ0FDSEUiLCJyb290IiwiZW50cnkiLCJjaGlsZCIsImMiLCJjaGlsZFBhdGgiLCJkZXNjZW5kYW50IiwiZGVzY2VuZGFudHMiLCJlbGVtZW50cyIsImV4dHJhY3RQcm9wcyIsImZpcnN0IiwiZnJhZ21lbnQiLCJuZXdSb290Iiwibm9kZUVudHJpZXMiLCJwYXNzIiwiX3JlZiIsIl9sZWFmIiwiaGFzIiwiaXNOb2RlIiwiY2FjaGVkUmVzdWx0Iiwic2V0IiwiaXNUZXh0UHJvcHMiLCJmcm9tIiwidG8iLCJ2aXNpdGVkIiwiU2V0IiwiYWRkIiwibmV4dEluZGV4IiwiX25ld1BhdGgiLCJwYXJlbnRQYXRoIiwic3RyaW5nIiwibWFwIiwiam9pbiIsIm93bktleXMkYyIsIl9vYmplY3RTcHJlYWQkYyIsIk9wZXJhdGlvbiIsImlzTm9kZU9wZXJhdGlvbiIsImlzT3BlcmF0aW9uIiwiZW5kc1dpdGgiLCJpc09wZXJhdGlvbkxpc3QiLCJpc1NlbGVjdGlvbk9wZXJhdGlvbiIsImlzVGV4dE9wZXJhdGlvbiIsImludmVyc2UiLCJpbnZlcnNlUGF0aCIsImludmVyc2VOZXdQYXRoIiwiSVNfRURJVE9SX0NBQ0hFIiwiY2FjaGVkSXNFZGl0b3IiLCJhZGRNYXJrIiwiZGVsZXRlRnJhZ21lbnQiLCJpbnNlcnRCcmVhayIsImluc2VydFNvZnRCcmVhayIsImluc2VydEZyYWdtZW50IiwiaW5zZXJ0Tm9kZSIsImluc2VydFRleHQiLCJpc0VsZW1lbnRSZWFkT25seSIsImlzSW5saW5lIiwiaXNTZWxlY3RhYmxlIiwiaXNWb2lkIiwibm9ybWFsaXplTm9kZSIsIm9uQ2hhbmdlIiwicmVtb3ZlTWFyayIsImdldERpcnR5UGF0aHMiLCJtYXJrcyIsIm9wZXJhdGlvbnMiLCJhYm92ZSIsImF0IiwiZGVsZXRlQmFja3dhcmQiLCJ1bml0IiwiZGVsZXRlRm9yd2FyZCIsImVsZW1lbnRSZWFkT25seSIsImhhc0Jsb2NrcyIsImhhc0lubGluZXMiLCJoYXNQYXRoIiwiaGFzVGV4dHMiLCJpc0Jsb2NrIiwiaXNFZGdlIiwiaXNFbXB0eSIsImlzRW5kIiwiaXNOb3JtYWxpemluZyIsImlzU3RhcnQiLCJnZXRNYXJrcyIsIm5vcm1hbGl6ZSIsInBhdGhSZWYiLCJwYXRoUmVmcyIsInBvaW50UmVmIiwicG9pbnRSZWZzIiwicG9zaXRpb25zIiwicmFuZ2VSZWYiLCJyYW5nZVJlZnMiLCJzZXROb3JtYWxpemluZyIsInVuaGFuZ1JhbmdlIiwidm9pZCIsIndpdGhvdXROb3JtYWxpemluZyIsImZuIiwiTG9jYXRpb24iLCJpc0xvY2F0aW9uIiwiU3BhbiIsImlzU3BhbiIsIm93bktleXMkYiIsIl9vYmplY3RTcHJlYWQkYiIsIl9zY3J1YmJlciIsInNldFNjcnViYmVyIiwic2NydWJiZXIiLCJKU09OIiwiX2V4Y2x1ZGVkJDIiLCJfZXhjbHVkZWQyJDIiLCJvd25LZXlzJGEiLCJfb2JqZWN0U3ByZWFkJGEiLCJsb29zZSIsIm9taXRUZXh0IiwiaXNUZXh0TGlzdCIsImRlY29yYXRpb25zIiwibGVhdmVzIiwiZGVjIiwibGVhZkVuZCIsImRlY29yYXRpb25TdGFydCIsImRlY29yYXRpb25FbmQiLCJsZWFmU3RhcnQiLCJhc3NpZ24iLCJtaWRkbGUiLCJvZmYiLCJfb2ZmIiwiZ2V0RGVmYXVsdEluc2VydExvY2F0aW9uIiwibWF0Y2hQYXRoIiwiZ2V0Q2hhcmFjdGVyRGlzdGFuY2UiLCJzdHIiLCJpc1JUTCIsImlzTFRSIiwiY29kZXBvaW50cyIsImNvZGVwb2ludHNJdGVyYXRvclJUTCIsImxlZnQiLCJDb2RlcG9pbnRUeXBlIiwiTm9uZSIsInJpZ2h0IiwiZGlzdGFuY2UiLCJnYjExIiwiZ2IxMk9yMTMiLCJjaGFyIiwiY29kZSIsImNvZGVQb2ludEF0IiwiZ2V0Q29kZXBvaW50VHlwZSIsImludGVyc2VjdHMiLCJaV0oiLCJFeHRQaWN0IiwiZW5kc1dpdGhFbW9qaVpXSiIsInN1YnN0cmluZyIsIlJJIiwiZW5kc1dpdGhPZGROdW1iZXJPZlJJcyIsImlzQm91bmRhcnlQYWlyIiwiU1BBQ0UiLCJQVU5DVFVBVElPTiIsIkNIQU1FTEVPTiIsImdldFdvcmREaXN0YW5jZSIsImRpc3QiLCJzdGFydGVkIiwiY2hhckRpc3QiLCJyZW1haW5pbmciLCJzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UiLCJpc1dvcmRDaGFyYWN0ZXIiLCJ0ZXN0IiwibmV4dENoYXIiLCJuZXh0UmVtYWluaW5nIiwiY2hhcjEiLCJjaGFyQXQiLCJpc0xvd1N1cnJvZ2F0ZSIsImNoYXJDb2RlQXQiLCJjaGFyMiIsImlzSGlnaFN1cnJvZ2F0ZSIsImNoYXJDb2RlIiwicmVFeHRlbmQiLCJyZVByZXBlbmQiLCJyZVNwYWNpbmdNYXJrIiwicmVMIiwicmVWIiwicmVUIiwicmVMViIsInJlTFZUIiwicmVFeHRQaWN0IiwiQW55Iiwic2VhcmNoIiwiRXh0ZW5kIiwiUHJlcGVuZCIsIlNwYWNpbmdNYXJrIiwiTCIsIlYiLCJUIiwiTFYiLCJMVlQiLCJ4IiwieSIsIk5vbkJvdW5kYXJ5UGFpcnMiLCJmaW5kSW5kZXgiLCJlbmRpbmdFbW9qaVpXSiIsImVuZGluZ1JJcyIsIm1hdGNoIiwibnVtUklzIiwiVGV4dFRyYW5zZm9ybXMiLCJkZWxldGUiLCJ2b2lkcyIsInN0YXJ0UmVmIiwiZW5kUmVmIiwiVHJhbnNmb3JtcyIsInN0YXJ0UG9pbnQiLCJlbmRQb2ludCIsIm93bktleXMkOSIsIl9vYmplY3RTcHJlYWQkOSIsIl9yZWYyIiwib2xkRGlydHlQYXRocyIsIm9sZERpcnR5UGF0aEtleXMiLCJkaXJ0eVBhdGhzIiwiZGlydHlQYXRoS2V5cyIsIm5ld0RpcnR5UGF0aHMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJwcmV2aW91c1BhdGgiLCJvbGRBbmNlc3RvcnMiLCJuZXdBbmNlc3RvcnMiLCJfYW5jZXN0b3IiLCJfcCIsInJlc3VsdFBhdGgiLCJfYW5jZXN0b3JzIiwiX2xldmVscyIsIm5leHRQYXRoIiwiZ2V0RnJhZ21lbnQiLCJzaG91bGRIYXZlSW5saW5lcyIsImN1cnJlbnROb2RlIiwiX2NoaWxkIiwiaXNMYXN0IiwiaXNJbmxpbmVPclRleHQiLCJuZXdDaGlsZCIsIl9uZXdDaGlsZCIsInNob3VsZE5vcm1hbGl6ZSIsIml0ZXJhdGlvbiIsImluaXRpYWxEaXJ0eVBhdGhzTGVuZ3RoIiwibWF4SXRlcmF0aW9ucyIsIm1vZGUiLCJvd25LZXlzJDgiLCJfb2JqZWN0U3ByZWFkJDgiLCJwYXJlbnROb2RlIiwibWFya2FibGVWb2lkIiwiZXhwYW5kZWRTZWxlY3Rpb24iLCJtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkIiwic2VsZWN0ZWROb2RlIiwic2VsZWN0ZWRQYXRoIiwic3BsaXQiLCJvd25LZXlzJDciLCJfb2JqZWN0U3ByZWFkJDciLCJlZGdlIiwiZCIsIm93bktleXMkNiIsIl9vYmplY3RTcHJlYWQkNiIsImRpcmVjdGlvbiIsIm93bktleXMkNSIsIl9vYmplY3RTcHJlYWQkNSIsIm93bktleXMkNCIsIl9vYmplY3RTcHJlYWQkNCIsImdldFZvaWQiLCJzb21lIiwiYWx3YXlzIiwib3duS2V5cyQzIiwiX29iamVjdFNwcmVhZCQzIiwiX2V4Y2x1ZGVkJDEiLCJfZXhjbHVkZWQyJDEiLCJfcmVzdCIsIm1hcmtlZFZvaWQiLCJibG9jayIsInByZXZOb2RlIiwiYmxvY2tQYXRoIiwicG9pbnRBZnRlckxvY2F0aW9uIiwic3BhbiIsInVuaXZlcnNhbCIsImlnbm9yZU5vblNlbGVjdGFibGUiLCJoaXQiLCJpc0xvd2VyIiwiZW1pdCIsImZvcmNlIiwiZ2V0RGlydHlQYXRoS2V5cyIsInBvcERpcnR5UGF0aCIsInBvcCIsImFsbFBhdGhzIiwiYWxsUGF0aEtleXMiLCJkaXJ0eVBhdGgiLCJfIiwiX2RpcnR5UGF0aCIsIl9lbnRyeSIsInJlZnMiLCJkZXB0aCIsImZpcnN0UGF0aCIsImxhc3RQYXRoIiwiaXNOZXdCbG9jayIsImJsb2NrVGV4dCIsImxlYWZUZXh0UmVtYWluaW5nIiwibGVhZlRleHRPZmZzZXQiLCJzIiwiaXNGaXJzdCIsImNhbGNEaXN0YW5jZSIsInBvaW50QmVmb3JlTG9jYXRpb24iLCJvd25LZXlzJDIiLCJfb2JqZWN0U3ByZWFkJDIiLCJlbmRCbG9jayIsInNraXAiLCJkZWxldGVUZXh0IiwiX0VkaXRvciR2b2lkIiwiX0VkaXRvciR2b2lkMiIsImhhbmdpbmciLCJmdXJ0aGVzdFZvaWQiLCJ2b2lkUGF0aCIsIm9wdHMiLCJfZW5kIiwiZW5kT2ZEb2MiLCJzdGFydEJsb2NrIiwiaXNBY3Jvc3NCbG9ja3MiLCJpc1NpbmdsZVRleHQiLCJzdGFydE5vbkVkaXRhYmxlIiwiZW5kTm9uRWRpdGFibGUiLCJyZW1vdmVkVGV4dCIsInN0YXJ0VW5yZWYiLCJlbmRVbnJlZiIsImlubGluZUVsZW1lbnRNYXRjaCIsIl9pbmxpbmVQYXRoIiwiYmxvY2tNYXRjaCIsImlzQmxvY2tTdGFydCIsImlzQmxvY2tFbmQiLCJpc0Jsb2NrRW1wdHkiLCJtZXJnZVN0YXJ0IiwibWVyZ2VFbmQiLCJtYXRjaGVyIiwiaXNSb290Iiwic3RhcnRzIiwibWlkZGxlcyIsImVuZHMiLCJzdGFydGluZyIsImlubGluZU1hdGNoIiwiaW5saW5lUGF0aCIsImlzSW5saW5lU3RhcnQiLCJpc0lubGluZUVuZCIsIm1pZGRsZVJlZiIsIm93bktleXMkMSIsIl9vYmplY3RTcHJlYWQkMSIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJrIiwiaXNBdEVuZCIsInBhcmVudE5vZGVFbnRyeSIsInRvUGF0aCIsIl90b1BhdGgiLCJzcGxpdFBhdGgiLCJfdG9QYXRoMiIsIl9leGNsdWRlZCIsIl9leGNsdWRlZDIiLCJoYXNTaW5nbGVDaGlsZE5lc3QiLCJjb21tb25QYXRoIiwiaXNQcmV2aW91c1NpYmxpbmciLCJlbXB0eUFuY2VzdG9yIiwiZW1wdHlSZWYiLCJ0b1JlZiIsInRhcmdldHMiLCJkZXB0aHMiLCJtZXJnZSIsInNwbGl0TW9kZSIsImVuZEF0RW5kT2ZOb2RlIiwic3RhcnRBdFN0YXJ0T2ZOb2RlIiwicHJvcCIsIm5vZGVQcm9wIiwiaGFzQ2hhbmdlcyIsImRlbGV0ZVJhbmdlIiwiaGVpZ2h0IiwiYmVmb3JlUmVmIiwiYWZ0ZXJSZWYiLCJoaWdoZXN0Iiwidm9pZE1hdGNoIiwibnVkZ2UiLCJ2b2lkTm9kZSIsImFmdGVyUGF0aCIsInNpYmxpbmdIZWlnaHQiLCJoaWdoZXN0UGF0aCIsImxvd2VzdFBhdGgiLCJfYWZ0ZXJSZWYiLCJfbG9vcCIsIm93bktleXMiLCJfb2JqZWN0U3ByZWFkIiwicm9vdHMiLCJyb290UGF0aCIsImNvbW1vbk5vZGVFbnRyeSIsImNvbW1vbk5vZGUiLCJ3cmFwcGVyUGF0aCIsIndyYXBwZXIiLCJfcmV0IiwiY3JlYXRlRWRpdG9yIiwiYXBwbHkkMSIsIl9sZW4iLCJhcmdzIiwiYWRkTWFyayQxIiwiX2xlbjIiLCJkZWxldGVCYWNrd2FyZCQxIiwiX2xlbjMiLCJkZWxldGVGb3J3YXJkJDEiLCJfbGVuNCIsImRlbGV0ZUZyYWdtZW50JDEiLCJfbGVuNSIsImdldEZyYWdtZW50JDEiLCJfbGVuNiIsImluc2VydEJyZWFrJDEiLCJfbGVuNyIsImluc2VydFNvZnRCcmVhayQxIiwiX2xlbjgiLCJpbnNlcnRGcmFnbWVudCQxIiwiX2xlbjkiLCJpbnNlcnROb2RlJDEiLCJfbGVuMTAiLCJfa2V5MTAiLCJpbnNlcnRUZXh0JDEiLCJfbGVuMTEiLCJfa2V5MTEiLCJub3JtYWxpemVOb2RlJDEiLCJfbGVuMTIiLCJfa2V5MTIiLCJyZW1vdmVNYXJrJDEiLCJfbGVuMTMiLCJfa2V5MTMiLCJnZXREaXJ0eVBhdGhzJDEiLCJfbGVuMTQiLCJfa2V5MTQiLCJzaG91bGROb3JtYWxpemUkMSIsIl9sZW4xNSIsIl9rZXkxNSIsImFib3ZlJDEiLCJfbGVuMTYiLCJfa2V5MTYiLCJhZnRlciQxIiwiX2xlbjE3IiwiX2tleTE3IiwiYmVmb3JlJDEiLCJfbGVuMTgiLCJfa2V5MTgiLCJjb2xsYXBzZSQxIiwiX2xlbjE5IiwiX2tleTE5IiwiX2RlbGV0ZSIsIl9sZW4yMCIsIl9rZXkyMCIsImRlc2VsZWN0JDEiLCJfbGVuMjEiLCJfa2V5MjEiLCJlZGdlcyQxIiwiX2xlbjIyIiwiX2tleTIyIiwiZWxlbWVudFJlYWRPbmx5JDEiLCJfbGVuMjMiLCJfa2V5MjMiLCJlbmQkMSIsIl9sZW4yNCIsIl9rZXkyNCIsImZpcnN0JDEiLCJfbGVuMjUiLCJfa2V5MjUiLCJmcmFnbWVudCQxIiwiX2xlbjI2IiwiX2tleTI2IiwiX2xlbjI3IiwiX2tleTI3IiwiaGFzQmxvY2tzJDEiLCJfbGVuMjgiLCJfa2V5MjgiLCJoYXNJbmxpbmVzJDEiLCJfbGVuMjkiLCJfa2V5MjkiLCJoYXNQYXRoJDEiLCJfbGVuMzAiLCJfa2V5MzAiLCJoYXNUZXh0cyQxIiwiX2xlbjMxIiwiX2tleTMxIiwiaW5zZXJ0Tm9kZXMkMSIsIl9sZW4zMiIsIl9rZXkzMiIsImlzQmxvY2skMSIsIl9sZW4zMyIsIl9rZXkzMyIsImlzRWRnZSQxIiwiX2xlbjM0IiwiX2tleTM0IiwiaXNFbXB0eSQxIiwiX2xlbjM1IiwiX2tleTM1IiwiaXNFbmQkMSIsIl9sZW4zNiIsIl9rZXkzNiIsImlzTm9ybWFsaXppbmckMSIsIl9sZW4zNyIsIl9rZXkzNyIsImlzU3RhcnQkMSIsIl9sZW4zOCIsIl9rZXkzOCIsImxhc3QkMSIsIl9sZW4zOSIsIl9rZXkzOSIsImxlYWYkMSIsIl9sZW40MCIsIl9rZXk0MCIsImxldmVscyQxIiwiX2xlbjQxIiwiX2tleTQxIiwibGlmdE5vZGVzJDEiLCJfbGVuNDIiLCJfa2V5NDIiLCJtZXJnZU5vZGVzJDEiLCJfbGVuNDMiLCJfa2V5NDMiLCJtb3ZlJDEiLCJfbGVuNDQiLCJfa2V5NDQiLCJtb3ZlTm9kZXMkMSIsIl9sZW40NSIsIl9rZXk0NSIsIm5leHQkMSIsIl9sZW40NiIsIl9rZXk0NiIsIm5vZGUkMSIsIl9sZW40NyIsIl9rZXk0NyIsIm5vZGVzJDEiLCJfbGVuNDgiLCJfa2V5NDgiLCJub3JtYWxpemUkMSIsIl9sZW40OSIsIl9rZXk0OSIsInBhcmVudCQxIiwiX2xlbjUwIiwiX2tleTUwIiwicGF0aCQxIiwiX2xlbjUxIiwiX2tleTUxIiwicGF0aFJlZiQxIiwiX2xlbjUyIiwiX2tleTUyIiwicGF0aFJlZnMkMSIsIl9sZW41MyIsIl9rZXk1MyIsInBvaW50JDEiLCJfbGVuNTQiLCJfa2V5NTQiLCJwb2ludFJlZiQxIiwiX2xlbjU1IiwiX2tleTU1IiwicG9pbnRSZWZzJDEiLCJfbGVuNTYiLCJfa2V5NTYiLCJwb3NpdGlvbnMkMSIsIl9sZW41NyIsIl9rZXk1NyIsInByZXZpb3VzJDEiLCJfbGVuNTgiLCJfa2V5NTgiLCJyYW5nZSQxIiwiX2xlbjU5IiwiX2tleTU5IiwicmFuZ2VSZWYkMSIsIl9sZW42MCIsIl9rZXk2MCIsInJhbmdlUmVmcyQxIiwiX2xlbjYxIiwiX2tleTYxIiwicmVtb3ZlTm9kZXMkMSIsIl9sZW42MiIsIl9rZXk2MiIsInNlbGVjdCQxIiwiX2xlbjYzIiwiX2tleTYzIiwic2V0Tm9kZXMkMSIsIl9sZW42NCIsIl9rZXk2NCIsInNldE5vcm1hbGl6aW5nJDEiLCJfbGVuNjUiLCJfa2V5NjUiLCJzZXRQb2ludCQxIiwiX2xlbjY2IiwiX2tleTY2Iiwic2V0U2VsZWN0aW9uJDEiLCJfbGVuNjciLCJfa2V5NjciLCJzcGxpdE5vZGVzJDEiLCJfbGVuNjgiLCJfa2V5NjgiLCJzdGFydCQxIiwiX2xlbjY5IiwiX2tleTY5Iiwic3RyaW5nJDEiLCJfbGVuNzAiLCJfa2V5NzAiLCJ1bmhhbmdSYW5nZSQxIiwiX2xlbjcxIiwiX2tleTcxIiwidW5zZXROb2RlcyQxIiwiX2xlbjcyIiwiX2tleTcyIiwidW53cmFwTm9kZXMkMSIsIl9sZW43MyIsIl9rZXk3MyIsIl92b2lkIiwiX2xlbjc0IiwiX2tleTc0Iiwid2l0aG91dE5vcm1hbGl6aW5nJDEiLCJfbGVuNzUiLCJfa2V5NzUiLCJ3cmFwTm9kZXMkMSIsIl9sZW43NiIsIl9rZXk3NiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/slate/dist/index.es.js\n");

/***/ })

};
;