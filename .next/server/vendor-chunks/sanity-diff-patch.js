"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sanity-diff-patch";
exports.ids = ["vendor-chunks/sanity-diff-patch"];
exports.modules = {

/***/ "(ssr)/./node_modules/sanity-diff-patch/dist/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/sanity-diff-patch/dist/index.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar diffMatchPatch = __webpack_require__(/*! @sanity/diff-match-patch */ \"(ssr)/./node_modules/@sanity/diff-match-patch/dist/index.cjs\");\nfunction pathToString(path) {\n    return path.reduce((target, segment, i)=>{\n        if (Array.isArray(segment)) {\n            return \"\".concat(target, \"[\").concat(segment.join(\":\"), \"]\");\n        }\n        if (isKeyedObject(segment)) {\n            return \"\".concat(target, '[_key==\"').concat(segment._key, '\"]');\n        }\n        if (typeof segment === \"number\") {\n            return \"\".concat(target, \"[\").concat(segment, \"]\");\n        } else if (typeof segment === \"string\" && /^\\d+$/.test(segment)) {\n            return \"\".concat(target, '[\"').concat(segment, '\"]');\n        }\n        if (typeof segment === \"string\") {\n            const separator = i === 0 ? \"\" : \".\";\n            return \"\".concat(target).concat(separator).concat(segment);\n        }\n        throw new Error('Unsupported path segment \"'.concat(segment, '\"'));\n    }, \"\");\n}\nfunction isKeyedObject(obj) {\n    return typeof obj === \"object\" && typeof obj._key === \"string\";\n}\nclass DiffError extends Error {\n    constructor(message, path, value){\n        const serializedPath = pathToString(path);\n        super(\"\".concat(message, \" (at '\").concat(serializedPath, \"')\"));\n        this.path = path;\n        this.serializedPath = serializedPath;\n        this.value = value;\n    }\n}\nconst idPattern = /^[a-z0-9][a-z0-9_.-]+$/i;\nconst propPattern = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nconst propStartPattern = /^[a-z_]/i;\nfunction validateProperty(property, value, path) {\n    if (!propStartPattern.test(property)) {\n        throw new DiffError(\"Keys must start with a letter (a-z)\", path.concat(property), value);\n    }\n    if (!propPattern.test(property)) {\n        throw new DiffError(\"Keys can only contain letters, numbers and underscores\", path.concat(property), value);\n    }\n    if (property === \"_key\" || property === \"_ref\" || property === \"_type\") {\n        if (typeof value !== \"string\") {\n            throw new DiffError(\"Keys must be strings\", path.concat(property), value);\n        }\n        if (!idPattern.test(value)) {\n            throw new DiffError(\"Invalid key - use less exotic characters\", path.concat(property), value);\n        }\n    }\n    return property;\n}\nconst ignoredKeys = [\n    \"_id\",\n    \"_type\",\n    \"_createdAt\",\n    \"_updatedAt\",\n    \"_rev\"\n];\nconst defaultOptions = {\n    hideWarnings: false,\n    diffMatchPatch: {\n        enabled: true,\n        // Only use diff-match-patch if target string is longer than this threshold\n        lengthThresholdAbsolute: 30,\n        // Only use generated diff-match-patch if the patch length is less than or equal to\n        // (targetString * relative). Example: A 100 character target with a relative factor\n        // of 1.2 will allow a 120 character diff-match-patch. If larger than this number,\n        // it will fall back to a regular `set` patch.\n        lengthThresholdRelative: 1.2\n    }\n};\nfunction mergeOptions(options) {\n    return {\n        ...defaultOptions,\n        ...options,\n        diffMatchPatch: {\n            ...defaultOptions.diffMatchPatch,\n            ...options.diffMatchPatch || {}\n        }\n    };\n}\nfunction diffPatch(itemA, itemB, opts) {\n    const options = mergeOptions(opts || {});\n    const id = options.id || itemA._id === itemB._id && itemA._id;\n    const revisionLocked = options.ifRevisionID;\n    const ifRevisionID = typeof revisionLocked === \"boolean\" ? itemA._rev : revisionLocked;\n    const basePath = options.basePath || [];\n    if (!id) {\n        throw new Error(\"_id on itemA and itemB not present or differs, specify document id the mutations should be applied to\");\n    }\n    if (revisionLocked === true && !ifRevisionID) {\n        throw new Error(\"`ifRevisionID` is set to `true`, but no `_rev` was passed in item A. Either explicitly set `ifRevisionID` to a revision, or pass `_rev` as part of item A.\");\n    }\n    if (basePath.length === 0 && itemA._type !== itemB._type) {\n        throw new Error(\"_type is immutable and cannot be changed (\".concat(itemA._type, \" => \").concat(itemB._type, \")\"));\n    }\n    const operations = diffItem(itemA, itemB, options, basePath, []);\n    return serializePatches(operations, {\n        id,\n        ifRevisionID: revisionLocked ? ifRevisionID : void 0\n    });\n}\nfunction diffItem(itemA, itemB) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions;\n    let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    let patches = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    if (itemA === itemB) {\n        return patches;\n    }\n    const aType = Array.isArray(itemA) ? \"array\" : typeof itemA;\n    const bType = Array.isArray(itemB) ? \"array\" : typeof itemB;\n    const aIsUndefined = aType === \"undefined\";\n    const bIsUndefined = bType === \"undefined\";\n    if (aIsUndefined && !bIsUndefined) {\n        patches.push({\n            op: \"set\",\n            path,\n            value: itemB\n        });\n        return patches;\n    }\n    if (!aIsUndefined && bIsUndefined) {\n        patches.push({\n            op: \"unset\",\n            path\n        });\n        return patches;\n    }\n    const options = mergeOptions(opts);\n    const dataType = aIsUndefined ? bType : aType;\n    const isContainer = dataType === \"object\" || dataType === \"array\";\n    if (!isContainer) {\n        return diffPrimitive(itemA, itemB, options, path, patches);\n    }\n    if (aType !== bType) {\n        patches.push({\n            op: \"set\",\n            path,\n            value: itemB\n        });\n        return patches;\n    }\n    return dataType === \"array\" ? diffArray(itemA, itemB, options, path, patches) : diffObject(itemA, itemB, options, path, patches);\n}\nfunction diffObject(itemA, itemB, options, path, patches) {\n    const atRoot = path.length === 0;\n    const aKeys = Object.keys(itemA).filter(atRoot ? isNotIgnoredKey : yes).map((key)=>validateProperty(key, itemA[key], path));\n    const aKeysLength = aKeys.length;\n    const bKeys = Object.keys(itemB).filter(atRoot ? isNotIgnoredKey : yes).map((key)=>validateProperty(key, itemB[key], path));\n    const bKeysLength = bKeys.length;\n    for(let i = 0; i < aKeysLength; i++){\n        const key = aKeys[i];\n        if (!(key in itemB)) {\n            patches.push({\n                op: \"unset\",\n                path: path.concat(key)\n            });\n        }\n    }\n    for(let i = 0; i < bKeysLength; i++){\n        const key = bKeys[i];\n        diffItem(itemA[key], itemB[key], options, path.concat([\n            key\n        ]), patches);\n    }\n    return patches;\n}\nfunction diffArray(itemA, itemB, options, path, patches) {\n    if (itemB.length > itemA.length) {\n        patches.push({\n            op: \"insert\",\n            after: path.concat([\n                -1\n            ]),\n            items: itemB.slice(itemA.length).map((item, i)=>nullifyUndefined(item, path, i, options))\n        });\n    }\n    if (itemB.length < itemA.length) {\n        const isSingle = itemA.length - itemB.length === 1;\n        const unsetItems = itemA.slice(itemB.length);\n        if (isRevisionLocked(options) || !isUniquelyKeyed(unsetItems)) {\n            patches.push({\n                op: \"unset\",\n                path: path.concat([\n                    isSingle ? itemB.length : [\n                        itemB.length,\n                        \"\"\n                    ]\n                ])\n            });\n        } else {\n            patches.push(...unsetItems.map((item)=>({\n                    op: \"unset\",\n                    path: path.concat({\n                        _key: item._key\n                    })\n                })));\n        }\n    }\n    for(let i = 0; i < itemB.length; i++){\n        if (Array.isArray(itemB[i])) {\n            throw new DiffError(\"Multi-dimensional arrays not supported\", path.concat(i), itemB[i]);\n        }\n    }\n    const overlapping = Math.min(itemA.length, itemB.length);\n    const segmentA = itemA.slice(0, overlapping);\n    const segmentB = itemB.slice(0, overlapping);\n    return isUniquelyKeyed(segmentA) && isUniquelyKeyed(segmentB) ? diffArrayByKey(segmentA, segmentB, options, path, patches) : diffArrayByIndex(segmentA, segmentB, options, path, patches);\n}\nfunction diffArrayByIndex(itemA, itemB, options, path, patches) {\n    for(let i = 0; i < itemA.length; i++){\n        diffItem(itemA[i], nullifyUndefined(itemB[i], path, i, options), options, path.concat(i), patches);\n    }\n    return patches;\n}\nfunction diffArrayByKey(itemA, itemB, options, path, patches) {\n    const keyedA = indexByKey(itemA);\n    const keyedB = indexByKey(itemB);\n    if (!arrayIsEqual(keyedA.keys, keyedB.keys)) {\n        return diffArrayByIndex(itemA, itemB, options, path, patches);\n    }\n    for(let i = 0; i < keyedB.keys.length; i++){\n        const key = keyedB.keys[i];\n        const valueA = keyedA.index[key];\n        const valueB = nullifyUndefined(keyedB.index[key], path, i, options);\n        diffItem(valueA, valueB, options, path.concat({\n            _key: key\n        }), patches);\n    }\n    return patches;\n}\nfunction getDiffMatchPatch(itemA, itemB, options, path) {\n    const { enabled, lengthThresholdRelative, lengthThresholdAbsolute } = options.diffMatchPatch;\n    const segment = path[path.length - 1];\n    if (!enabled || // Don't use for anything but strings\n    typeof itemA !== \"string\" || typeof itemB !== \"string\" || // Don't use for `_key`, `_ref` etc\n    typeof segment === \"string\" && segment[0] === \"_\" || // Don't use on short strings\n    itemB.length < lengthThresholdAbsolute) {\n        return void 0;\n    }\n    let strPatch = \"\";\n    try {\n        const patch = diffMatchPatch.makeDiff(itemA, itemB);\n        const diff = diffMatchPatch.cleanupEfficiency(patch);\n        strPatch = diffMatchPatch.stringifyPatches(diffMatchPatch.makePatches(diff));\n    } catch (err) {\n        return void 0;\n    }\n    return strPatch.length > itemB.length * lengthThresholdRelative ? void 0 : {\n        op: \"diffMatchPatch\",\n        path,\n        value: strPatch\n    };\n}\nfunction diffPrimitive(itemA, itemB, options, path, patches) {\n    const dmp = getDiffMatchPatch(itemA, itemB, options, path);\n    patches.push(dmp || {\n        op: \"set\",\n        path,\n        value: itemB\n    });\n    return patches;\n}\nfunction isNotIgnoredKey(key) {\n    return ignoredKeys.indexOf(key) === -1;\n}\nfunction serializePatches(patches, options) {\n    if (patches.length === 0) {\n        return [];\n    }\n    const { id, ifRevisionID } = options;\n    const set = patches.filter((patch)=>patch.op === \"set\");\n    const unset = patches.filter((patch)=>patch.op === \"unset\");\n    const insert = patches.filter((patch)=>patch.op === \"insert\");\n    const dmp = patches.filter((patch)=>patch.op === \"diffMatchPatch\");\n    const withSet = set.length > 0 && set.reduce((patch, item)=>{\n        const path = pathToString(item.path);\n        patch.set[path] = item.value;\n        return patch;\n    }, {\n        id,\n        set: {}\n    });\n    const withUnset = unset.length > 0 && unset.reduce((patch, item)=>{\n        const path = pathToString(item.path);\n        patch.unset.push(path);\n        return patch;\n    }, {\n        id,\n        unset: []\n    });\n    const withInsert = insert.reduce((acc, item)=>{\n        const after = pathToString(item.after);\n        return acc.concat({\n            id,\n            insert: {\n                after,\n                items: item.items\n            }\n        });\n    }, []);\n    const withDmp = dmp.length > 0 && dmp.reduce((patch, item)=>{\n        const path = pathToString(item.path);\n        patch.diffMatchPatch[path] = item.value;\n        return patch;\n    }, {\n        id,\n        diffMatchPatch: {}\n    });\n    const patchSet = [\n        withSet,\n        withUnset,\n        withDmp,\n        ...withInsert\n    ].filter((item)=>item !== false);\n    return patchSet.map((patch, i)=>({\n            patch: ifRevisionID && i === 0 ? {\n                ...patch,\n                ifRevisionID\n            } : patch\n        }));\n}\nfunction isUniquelyKeyed(arr) {\n    const keys = [];\n    for(let i = 0; i < arr.length; i++){\n        const key = getKey(arr[i]);\n        if (!key || keys.indexOf(key) !== -1) {\n            return false;\n        }\n        keys.push(key);\n    }\n    return true;\n}\nfunction getKey(obj) {\n    return typeof obj === \"object\" && obj !== null && obj._key;\n}\nfunction indexByKey(arr) {\n    return arr.reduce((acc, item)=>{\n        acc.keys.push(item._key);\n        acc.index[item._key] = item;\n        return acc;\n    }, {\n        keys: [],\n        index: {}\n    });\n}\nfunction arrayIsEqual(itemA, itemB) {\n    return itemA.length === itemB.length && itemA.every((item, i)=>itemB[i] === item);\n}\nfunction nullifyUndefined(item, path, index, options) {\n    if (typeof item !== \"undefined\") {\n        return item;\n    }\n    if (!options.hideWarnings) {\n        const serializedPath = pathToString(path.concat(index));\n        console.warn(\"undefined value in array converted to null (at '\".concat(serializedPath, \"')\"));\n    }\n    return null;\n}\nfunction isRevisionLocked(options) {\n    return Boolean(options.ifRevisionID);\n}\nfunction yes(_) {\n    return true;\n}\nexports.DiffError = DiffError;\nexports.diffItem = diffItem;\nexports.diffPatch = diffPatch; //# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2FuaXR5LWRpZmYtcGF0Y2gvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0YsSUFBSUMsaUJBQWlCQyxtQkFBT0EsQ0FBQztBQUM3QixTQUFTQyxhQUFhQyxJQUFJO0lBQ3hCLE9BQU9BLEtBQUtDLE1BQU0sQ0FBQyxDQUFDQyxRQUFRQyxTQUFTQztRQUNuQyxJQUFJQyxNQUFNQyxPQUFPLENBQUNILFVBQVU7WUFDMUIsT0FBTyxHQUFHSSxNQUFNLENBQUNMLFFBQVEsS0FBS0ssTUFBTSxDQUFDSixRQUFRSyxJQUFJLENBQUMsTUFBTTtRQUMxRDtRQUNBLElBQUlDLGNBQWNOLFVBQVU7WUFDMUIsT0FBTyxHQUFHSSxNQUFNLENBQUNMLFFBQVEsWUFBYUssTUFBTSxDQUFDSixRQUFRTyxJQUFJLEVBQUU7UUFDN0Q7UUFDQSxJQUFJLE9BQU9QLFlBQVksVUFBVTtZQUMvQixPQUFPLEdBQUdJLE1BQU0sQ0FBQ0wsUUFBUSxLQUFLSyxNQUFNLENBQUNKLFNBQVM7UUFDaEQsT0FBTyxJQUFJLE9BQU9BLFlBQVksWUFBWSxRQUFRUSxJQUFJLENBQUNSLFVBQVU7WUFDL0QsT0FBTyxHQUFHSSxNQUFNLENBQUNMLFFBQVEsTUFBT0ssTUFBTSxDQUFDSixTQUFTO1FBQ2xEO1FBQ0EsSUFBSSxPQUFPQSxZQUFZLFVBQVU7WUFDL0IsTUFBTVMsWUFBWVIsTUFBTSxJQUFJLEtBQUs7WUFDakMsT0FBTyxHQUFHRyxNQUFNLENBQUNMLFFBQVFLLE1BQU0sQ0FBQ0ssV0FBV0wsTUFBTSxDQUFDSjtRQUNwRDtRQUNBLE1BQU0sSUFBSVUsTUFBTSw2QkFBOEJOLE1BQU0sQ0FBQ0osU0FBUztJQUNoRSxHQUFHO0FBQ0w7QUFDQSxTQUFTTSxjQUFjSyxHQUFHO0lBQ3hCLE9BQU8sT0FBT0EsUUFBUSxZQUFZLE9BQU9BLElBQUlKLElBQUksS0FBSztBQUN4RDtBQUNBLE1BQU1LLGtCQUFrQkY7SUFDdEJHLFlBQVlDLE9BQU8sRUFBRWpCLElBQUksRUFBRUosS0FBSyxDQUFFO1FBQ2hDLE1BQU1zQixpQkFBaUJuQixhQUFhQztRQUNwQyxLQUFLLENBQUMsR0FBR08sTUFBTSxDQUFDVSxTQUFTLFVBQVVWLE1BQU0sQ0FBQ1csZ0JBQWdCO1FBQzFELElBQUksQ0FBQ2xCLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNrQixjQUFjLEdBQUdBO1FBQ3RCLElBQUksQ0FBQ3RCLEtBQUssR0FBR0E7SUFDZjtBQUNGO0FBQ0EsTUFBTXVCLFlBQVk7QUFDbEIsTUFBTUMsY0FBYztBQUNwQixNQUFNQyxtQkFBbUI7QUFDekIsU0FBU0MsaUJBQWlCQyxRQUFRLEVBQUUzQixLQUFLLEVBQUVJLElBQUk7SUFDN0MsSUFBSSxDQUFDcUIsaUJBQWlCVixJQUFJLENBQUNZLFdBQVc7UUFDcEMsTUFBTSxJQUFJUixVQUFVLHVDQUF1Q2YsS0FBS08sTUFBTSxDQUFDZ0IsV0FBVzNCO0lBQ3BGO0lBQ0EsSUFBSSxDQUFDd0IsWUFBWVQsSUFBSSxDQUFDWSxXQUFXO1FBQy9CLE1BQU0sSUFBSVIsVUFBVSwwREFBMERmLEtBQUtPLE1BQU0sQ0FBQ2dCLFdBQVczQjtJQUN2RztJQUNBLElBQUkyQixhQUFhLFVBQVVBLGFBQWEsVUFBVUEsYUFBYSxTQUFTO1FBQ3RFLElBQUksT0FBTzNCLFVBQVUsVUFBVTtZQUM3QixNQUFNLElBQUltQixVQUFVLHdCQUF3QmYsS0FBS08sTUFBTSxDQUFDZ0IsV0FBVzNCO1FBQ3JFO1FBQ0EsSUFBSSxDQUFDdUIsVUFBVVIsSUFBSSxDQUFDZixRQUFRO1lBQzFCLE1BQU0sSUFBSW1CLFVBQVUsNENBQTRDZixLQUFLTyxNQUFNLENBQUNnQixXQUFXM0I7UUFDekY7SUFDRjtJQUNBLE9BQU8yQjtBQUNUO0FBQ0EsTUFBTUMsY0FBYztJQUFDO0lBQU87SUFBUztJQUFjO0lBQWM7Q0FBTztBQUN4RSxNQUFNQyxpQkFBaUI7SUFDckJDLGNBQWM7SUFDZDdCLGdCQUFnQjtRQUNkOEIsU0FBUztRQUNULDJFQUEyRTtRQUMzRUMseUJBQXlCO1FBQ3pCLG1GQUFtRjtRQUNuRixvRkFBb0Y7UUFDcEYsa0ZBQWtGO1FBQ2xGLDhDQUE4QztRQUM5Q0MseUJBQXlCO0lBQzNCO0FBQ0Y7QUFDQSxTQUFTQyxhQUFhQyxPQUFPO0lBQzNCLE9BQU87UUFDTCxHQUFHTixjQUFjO1FBQ2pCLEdBQUdNLE9BQU87UUFDVmxDLGdCQUFnQjtZQUNkLEdBQUc0QixlQUFlNUIsY0FBYztZQUNoQyxHQUFJa0MsUUFBUWxDLGNBQWMsSUFBSSxDQUFDLENBQUM7UUFDbEM7SUFDRjtBQUNGO0FBQ0EsU0FBU21DLFVBQVVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxJQUFJO0lBQ25DLE1BQU1KLFVBQVVELGFBQWFLLFFBQVEsQ0FBQztJQUN0QyxNQUFNQyxLQUFLTCxRQUFRSyxFQUFFLElBQUlILE1BQU1JLEdBQUcsS0FBS0gsTUFBTUcsR0FBRyxJQUFJSixNQUFNSSxHQUFHO0lBQzdELE1BQU1DLGlCQUFpQlAsUUFBUVEsWUFBWTtJQUMzQyxNQUFNQSxlQUFlLE9BQU9ELG1CQUFtQixZQUFZTCxNQUFNTyxJQUFJLEdBQUdGO0lBQ3hFLE1BQU1HLFdBQVdWLFFBQVFVLFFBQVEsSUFBSSxFQUFFO0lBQ3ZDLElBQUksQ0FBQ0wsSUFBSTtRQUNQLE1BQU0sSUFBSXZCLE1BQU07SUFDbEI7SUFDQSxJQUFJeUIsbUJBQW1CLFFBQVEsQ0FBQ0MsY0FBYztRQUM1QyxNQUFNLElBQUkxQixNQUFNO0lBQ2xCO0lBQ0EsSUFBSTRCLFNBQVNDLE1BQU0sS0FBSyxLQUFLVCxNQUFNVSxLQUFLLEtBQUtULE1BQU1TLEtBQUssRUFBRTtRQUN4RCxNQUFNLElBQUk5QixNQUFNLDZDQUE2Q04sTUFBTSxDQUFDMEIsTUFBTVUsS0FBSyxFQUFFLFFBQVFwQyxNQUFNLENBQUMyQixNQUFNUyxLQUFLLEVBQUU7SUFDL0c7SUFDQSxNQUFNQyxhQUFhQyxTQUFTWixPQUFPQyxPQUFPSCxTQUFTVSxVQUFVLEVBQUU7SUFDL0QsT0FBT0ssaUJBQWlCRixZQUFZO1FBQ2xDUjtRQUNBRyxjQUFjRCxpQkFBaUJDLGVBQWUsS0FBSztJQUNyRDtBQUNGO0FBQ0EsU0FBU00sU0FBU1osS0FBSyxFQUFFQyxLQUFLO0lBQzVCLElBQUlDLE9BQU9ZLFVBQVVMLE1BQU0sR0FBRyxLQUFLSyxTQUFTLENBQUMsRUFBRSxLQUFLQyxZQUFZRCxTQUFTLENBQUMsRUFBRSxHQUFHdEI7SUFDL0UsSUFBSXpCLE9BQU8rQyxVQUFVTCxNQUFNLEdBQUcsS0FBS0ssU0FBUyxDQUFDLEVBQUUsS0FBS0MsWUFBWUQsU0FBUyxDQUFDLEVBQUUsR0FBRyxFQUFFO0lBQ2pGLElBQUlFLFVBQVVGLFVBQVVMLE1BQU0sR0FBRyxLQUFLSyxTQUFTLENBQUMsRUFBRSxLQUFLQyxZQUFZRCxTQUFTLENBQUMsRUFBRSxHQUFHLEVBQUU7SUFDcEYsSUFBSWQsVUFBVUMsT0FBTztRQUNuQixPQUFPZTtJQUNUO0lBQ0EsTUFBTUMsUUFBUTdDLE1BQU1DLE9BQU8sQ0FBQzJCLFNBQVMsVUFBVSxPQUFPQTtJQUN0RCxNQUFNa0IsUUFBUTlDLE1BQU1DLE9BQU8sQ0FBQzRCLFNBQVMsVUFBVSxPQUFPQTtJQUN0RCxNQUFNa0IsZUFBZUYsVUFBVTtJQUMvQixNQUFNRyxlQUFlRixVQUFVO0lBQy9CLElBQUlDLGdCQUFnQixDQUFDQyxjQUFjO1FBQ2pDSixRQUFRSyxJQUFJLENBQUM7WUFDWEMsSUFBSTtZQUNKdkQ7WUFDQUosT0FBT3NDO1FBQ1Q7UUFDQSxPQUFPZTtJQUNUO0lBQ0EsSUFBSSxDQUFDRyxnQkFBZ0JDLGNBQWM7UUFDakNKLFFBQVFLLElBQUksQ0FBQztZQUNYQyxJQUFJO1lBQ0p2RDtRQUNGO1FBQ0EsT0FBT2lEO0lBQ1Q7SUFDQSxNQUFNbEIsVUFBVUQsYUFBYUs7SUFDN0IsTUFBTXFCLFdBQVdKLGVBQWVELFFBQVFEO0lBQ3hDLE1BQU1PLGNBQWNELGFBQWEsWUFBWUEsYUFBYTtJQUMxRCxJQUFJLENBQUNDLGFBQWE7UUFDaEIsT0FBT0MsY0FBY3pCLE9BQU9DLE9BQU9ILFNBQVMvQixNQUFNaUQ7SUFDcEQ7SUFDQSxJQUFJQyxVQUFVQyxPQUFPO1FBQ25CRixRQUFRSyxJQUFJLENBQUM7WUFDWEMsSUFBSTtZQUNKdkQ7WUFDQUosT0FBT3NDO1FBQ1Q7UUFDQSxPQUFPZTtJQUNUO0lBQ0EsT0FBT08sYUFBYSxVQUFVRyxVQUFVMUIsT0FBT0MsT0FBT0gsU0FBUy9CLE1BQU1pRCxXQUFXVyxXQUFXM0IsT0FBT0MsT0FBT0gsU0FBUy9CLE1BQU1pRDtBQUMxSDtBQUNBLFNBQVNXLFdBQVczQixLQUFLLEVBQUVDLEtBQUssRUFBRUgsT0FBTyxFQUFFL0IsSUFBSSxFQUFFaUQsT0FBTztJQUN0RCxNQUFNWSxTQUFTN0QsS0FBSzBDLE1BQU0sS0FBSztJQUMvQixNQUFNb0IsUUFBUXJFLE9BQU9zRSxJQUFJLENBQUM5QixPQUFPK0IsTUFBTSxDQUFDSCxTQUFTSSxrQkFBa0JDLEtBQUtDLEdBQUcsQ0FBQ0MsQ0FBQUEsTUFBTzlDLGlCQUFpQjhDLEtBQUtuQyxLQUFLLENBQUNtQyxJQUFJLEVBQUVwRTtJQUNySCxNQUFNcUUsY0FBY1AsTUFBTXBCLE1BQU07SUFDaEMsTUFBTTRCLFFBQVE3RSxPQUFPc0UsSUFBSSxDQUFDN0IsT0FBTzhCLE1BQU0sQ0FBQ0gsU0FBU0ksa0JBQWtCQyxLQUFLQyxHQUFHLENBQUNDLENBQUFBLE1BQU85QyxpQkFBaUI4QyxLQUFLbEMsS0FBSyxDQUFDa0MsSUFBSSxFQUFFcEU7SUFDckgsTUFBTXVFLGNBQWNELE1BQU01QixNQUFNO0lBQ2hDLElBQUssSUFBSXRDLElBQUksR0FBR0EsSUFBSWlFLGFBQWFqRSxJQUFLO1FBQ3BDLE1BQU1nRSxNQUFNTixLQUFLLENBQUMxRCxFQUFFO1FBQ3BCLElBQUksQ0FBRWdFLENBQUFBLE9BQU9sQyxLQUFJLEdBQUk7WUFDbkJlLFFBQVFLLElBQUksQ0FBQztnQkFDWEMsSUFBSTtnQkFDSnZELE1BQU1BLEtBQUtPLE1BQU0sQ0FBQzZEO1lBQ3BCO1FBQ0Y7SUFDRjtJQUNBLElBQUssSUFBSWhFLElBQUksR0FBR0EsSUFBSW1FLGFBQWFuRSxJQUFLO1FBQ3BDLE1BQU1nRSxNQUFNRSxLQUFLLENBQUNsRSxFQUFFO1FBQ3BCeUMsU0FBU1osS0FBSyxDQUFDbUMsSUFBSSxFQUFFbEMsS0FBSyxDQUFDa0MsSUFBSSxFQUFFckMsU0FBUy9CLEtBQUtPLE1BQU0sQ0FBQztZQUFDNkQ7U0FBSSxHQUFHbkI7SUFDaEU7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsU0FBU1UsVUFBVTFCLEtBQUssRUFBRUMsS0FBSyxFQUFFSCxPQUFPLEVBQUUvQixJQUFJLEVBQUVpRCxPQUFPO0lBQ3JELElBQUlmLE1BQU1RLE1BQU0sR0FBR1QsTUFBTVMsTUFBTSxFQUFFO1FBQy9CTyxRQUFRSyxJQUFJLENBQUM7WUFDWEMsSUFBSTtZQUNKaUIsT0FBT3hFLEtBQUtPLE1BQU0sQ0FBQztnQkFBQyxDQUFDO2FBQUU7WUFDdkJrRSxPQUFPdkMsTUFBTXdDLEtBQUssQ0FBQ3pDLE1BQU1TLE1BQU0sRUFBRXlCLEdBQUcsQ0FBQyxDQUFDUSxNQUFNdkUsSUFBTXdFLGlCQUFpQkQsTUFBTTNFLE1BQU1JLEdBQUcyQjtRQUNwRjtJQUNGO0lBQ0EsSUFBSUcsTUFBTVEsTUFBTSxHQUFHVCxNQUFNUyxNQUFNLEVBQUU7UUFDL0IsTUFBTW1DLFdBQVc1QyxNQUFNUyxNQUFNLEdBQUdSLE1BQU1RLE1BQU0sS0FBSztRQUNqRCxNQUFNb0MsYUFBYTdDLE1BQU15QyxLQUFLLENBQUN4QyxNQUFNUSxNQUFNO1FBQzNDLElBQUlxQyxpQkFBaUJoRCxZQUFZLENBQUNpRCxnQkFBZ0JGLGFBQWE7WUFDN0Q3QixRQUFRSyxJQUFJLENBQUM7Z0JBQ1hDLElBQUk7Z0JBQ0p2RCxNQUFNQSxLQUFLTyxNQUFNLENBQUM7b0JBQUNzRSxXQUFXM0MsTUFBTVEsTUFBTSxHQUFHO3dCQUFDUixNQUFNUSxNQUFNO3dCQUFFO3FCQUFHO2lCQUFDO1lBQ2xFO1FBQ0YsT0FBTztZQUNMTyxRQUFRSyxJQUFJLElBQUl3QixXQUFXWCxHQUFHLENBQUNRLENBQUFBLE9BQVM7b0JBQ3RDcEIsSUFBSTtvQkFDSnZELE1BQU1BLEtBQUtPLE1BQU0sQ0FBQzt3QkFDaEJHLE1BQU1pRSxLQUFLakUsSUFBSTtvQkFDakI7Z0JBQ0Y7UUFDRjtJQUNGO0lBQ0EsSUFBSyxJQUFJTixJQUFJLEdBQUdBLElBQUk4QixNQUFNUSxNQUFNLEVBQUV0QyxJQUFLO1FBQ3JDLElBQUlDLE1BQU1DLE9BQU8sQ0FBQzRCLEtBQUssQ0FBQzlCLEVBQUUsR0FBRztZQUMzQixNQUFNLElBQUlXLFVBQVUsMENBQTBDZixLQUFLTyxNQUFNLENBQUNILElBQUk4QixLQUFLLENBQUM5QixFQUFFO1FBQ3hGO0lBQ0Y7SUFDQSxNQUFNNkUsY0FBY0MsS0FBS0MsR0FBRyxDQUFDbEQsTUFBTVMsTUFBTSxFQUFFUixNQUFNUSxNQUFNO0lBQ3ZELE1BQU0wQyxXQUFXbkQsTUFBTXlDLEtBQUssQ0FBQyxHQUFHTztJQUNoQyxNQUFNSSxXQUFXbkQsTUFBTXdDLEtBQUssQ0FBQyxHQUFHTztJQUNoQyxPQUFPRCxnQkFBZ0JJLGFBQWFKLGdCQUFnQkssWUFBWUMsZUFBZUYsVUFBVUMsVUFBVXRELFNBQVMvQixNQUFNaUQsV0FBV3NDLGlCQUFpQkgsVUFBVUMsVUFBVXRELFNBQVMvQixNQUFNaUQ7QUFDbkw7QUFDQSxTQUFTc0MsaUJBQWlCdEQsS0FBSyxFQUFFQyxLQUFLLEVBQUVILE9BQU8sRUFBRS9CLElBQUksRUFBRWlELE9BQU87SUFDNUQsSUFBSyxJQUFJN0MsSUFBSSxHQUFHQSxJQUFJNkIsTUFBTVMsTUFBTSxFQUFFdEMsSUFBSztRQUNyQ3lDLFNBQVNaLEtBQUssQ0FBQzdCLEVBQUUsRUFBRXdFLGlCQUFpQjFDLEtBQUssQ0FBQzlCLEVBQUUsRUFBRUosTUFBTUksR0FBRzJCLFVBQVVBLFNBQVMvQixLQUFLTyxNQUFNLENBQUNILElBQUk2QztJQUM1RjtJQUNBLE9BQU9BO0FBQ1Q7QUFDQSxTQUFTcUMsZUFBZXJELEtBQUssRUFBRUMsS0FBSyxFQUFFSCxPQUFPLEVBQUUvQixJQUFJLEVBQUVpRCxPQUFPO0lBQzFELE1BQU11QyxTQUFTQyxXQUFXeEQ7SUFDMUIsTUFBTXlELFNBQVNELFdBQVd2RDtJQUMxQixJQUFJLENBQUN5RCxhQUFhSCxPQUFPekIsSUFBSSxFQUFFMkIsT0FBTzNCLElBQUksR0FBRztRQUMzQyxPQUFPd0IsaUJBQWlCdEQsT0FBT0MsT0FBT0gsU0FBUy9CLE1BQU1pRDtJQUN2RDtJQUNBLElBQUssSUFBSTdDLElBQUksR0FBR0EsSUFBSXNGLE9BQU8zQixJQUFJLENBQUNyQixNQUFNLEVBQUV0QyxJQUFLO1FBQzNDLE1BQU1nRSxNQUFNc0IsT0FBTzNCLElBQUksQ0FBQzNELEVBQUU7UUFDMUIsTUFBTXdGLFNBQVNKLE9BQU9LLEtBQUssQ0FBQ3pCLElBQUk7UUFDaEMsTUFBTTBCLFNBQVNsQixpQkFBaUJjLE9BQU9HLEtBQUssQ0FBQ3pCLElBQUksRUFBRXBFLE1BQU1JLEdBQUcyQjtRQUM1RGMsU0FBUytDLFFBQVFFLFFBQVEvRCxTQUFTL0IsS0FBS08sTUFBTSxDQUFDO1lBQzVDRyxNQUFNMEQ7UUFDUixJQUFJbkI7SUFDTjtJQUNBLE9BQU9BO0FBQ1Q7QUFDQSxTQUFTOEMsa0JBQWtCOUQsS0FBSyxFQUFFQyxLQUFLLEVBQUVILE9BQU8sRUFBRS9CLElBQUk7SUFDcEQsTUFBTSxFQUNKMkIsT0FBTyxFQUNQRSx1QkFBdUIsRUFDdkJELHVCQUF1QixFQUN4QixHQUFHRyxRQUFRbEMsY0FBYztJQUMxQixNQUFNTSxVQUFVSCxJQUFJLENBQUNBLEtBQUswQyxNQUFNLEdBQUcsRUFBRTtJQUNyQyxJQUFJLENBQUNmLFdBQ0wscUNBQXFDO0lBQ3JDLE9BQU9NLFVBQVUsWUFBWSxPQUFPQyxVQUFVLFlBQzlDLG1DQUFtQztJQUNuQyxPQUFPL0IsWUFBWSxZQUFZQSxPQUFPLENBQUMsRUFBRSxLQUFLLE9BQzlDLDZCQUE2QjtJQUM3QitCLE1BQU1RLE1BQU0sR0FBR2QseUJBQXlCO1FBQ3RDLE9BQU8sS0FBSztJQUNkO0lBQ0EsSUFBSW9FLFdBQVc7SUFDZixJQUFJO1FBQ0YsTUFBTUMsUUFBUXBHLGVBQWVxRyxRQUFRLENBQUNqRSxPQUFPQztRQUM3QyxNQUFNaUUsT0FBT3RHLGVBQWV1RyxpQkFBaUIsQ0FBQ0g7UUFDOUNELFdBQVduRyxlQUFld0csZ0JBQWdCLENBQUN4RyxlQUFleUcsV0FBVyxDQUFDSDtJQUN4RSxFQUFFLE9BQU9JLEtBQUs7UUFDWixPQUFPLEtBQUs7SUFDZDtJQUNBLE9BQU9QLFNBQVN0RCxNQUFNLEdBQUdSLE1BQU1RLE1BQU0sR0FBR2IsMEJBQTBCLEtBQUssSUFBSTtRQUN6RTBCLElBQUk7UUFDSnZEO1FBQ0FKLE9BQU9vRztJQUNUO0FBQ0Y7QUFDQSxTQUFTdEMsY0FBY3pCLEtBQUssRUFBRUMsS0FBSyxFQUFFSCxPQUFPLEVBQUUvQixJQUFJLEVBQUVpRCxPQUFPO0lBQ3pELE1BQU11RCxNQUFNVCxrQkFBa0I5RCxPQUFPQyxPQUFPSCxTQUFTL0I7SUFDckRpRCxRQUFRSyxJQUFJLENBQUNrRCxPQUFPO1FBQ2xCakQsSUFBSTtRQUNKdkQ7UUFDQUosT0FBT3NDO0lBQ1Q7SUFDQSxPQUFPZTtBQUNUO0FBQ0EsU0FBU2dCLGdCQUFnQkcsR0FBRztJQUMxQixPQUFPNUMsWUFBWWlGLE9BQU8sQ0FBQ3JDLFNBQVMsQ0FBQztBQUN2QztBQUNBLFNBQVN0QixpQkFBaUJHLE9BQU8sRUFBRWxCLE9BQU87SUFDeEMsSUFBSWtCLFFBQVFQLE1BQU0sS0FBSyxHQUFHO1FBQ3hCLE9BQU8sRUFBRTtJQUNYO0lBQ0EsTUFBTSxFQUNKTixFQUFFLEVBQ0ZHLFlBQVksRUFDYixHQUFHUjtJQUNKLE1BQU0yRSxNQUFNekQsUUFBUWUsTUFBTSxDQUFDaUMsQ0FBQUEsUUFBU0EsTUFBTTFDLEVBQUUsS0FBSztJQUNqRCxNQUFNb0QsUUFBUTFELFFBQVFlLE1BQU0sQ0FBQ2lDLENBQUFBLFFBQVNBLE1BQU0xQyxFQUFFLEtBQUs7SUFDbkQsTUFBTXFELFNBQVMzRCxRQUFRZSxNQUFNLENBQUNpQyxDQUFBQSxRQUFTQSxNQUFNMUMsRUFBRSxLQUFLO0lBQ3BELE1BQU1pRCxNQUFNdkQsUUFBUWUsTUFBTSxDQUFDaUMsQ0FBQUEsUUFBU0EsTUFBTTFDLEVBQUUsS0FBSztJQUNqRCxNQUFNc0QsVUFBVUgsSUFBSWhFLE1BQU0sR0FBRyxLQUFLZ0UsSUFBSXpHLE1BQU0sQ0FBQyxDQUFDZ0csT0FBT3RCO1FBQ25ELE1BQU0zRSxPQUFPRCxhQUFhNEUsS0FBSzNFLElBQUk7UUFDbkNpRyxNQUFNUyxHQUFHLENBQUMxRyxLQUFLLEdBQUcyRSxLQUFLL0UsS0FBSztRQUM1QixPQUFPcUc7SUFDVCxHQUFHO1FBQ0Q3RDtRQUNBc0UsS0FBSyxDQUFDO0lBQ1I7SUFDQSxNQUFNSSxZQUFZSCxNQUFNakUsTUFBTSxHQUFHLEtBQUtpRSxNQUFNMUcsTUFBTSxDQUFDLENBQUNnRyxPQUFPdEI7UUFDekQsTUFBTTNFLE9BQU9ELGFBQWE0RSxLQUFLM0UsSUFBSTtRQUNuQ2lHLE1BQU1VLEtBQUssQ0FBQ3JELElBQUksQ0FBQ3REO1FBQ2pCLE9BQU9pRztJQUNULEdBQUc7UUFDRDdEO1FBQ0F1RSxPQUFPLEVBQUU7SUFDWDtJQUNBLE1BQU1JLGFBQWFILE9BQU8zRyxNQUFNLENBQUMsQ0FBQytHLEtBQUtyQztRQUNyQyxNQUFNSCxRQUFRekUsYUFBYTRFLEtBQUtILEtBQUs7UUFDckMsT0FBT3dDLElBQUl6RyxNQUFNLENBQUM7WUFDaEI2QjtZQUNBd0UsUUFBUTtnQkFDTnBDO2dCQUNBQyxPQUFPRSxLQUFLRixLQUFLO1lBQ25CO1FBQ0Y7SUFDRixHQUFHLEVBQUU7SUFDTCxNQUFNd0MsVUFBVVQsSUFBSTlELE1BQU0sR0FBRyxLQUFLOEQsSUFBSXZHLE1BQU0sQ0FBQyxDQUFDZ0csT0FBT3RCO1FBQ25ELE1BQU0zRSxPQUFPRCxhQUFhNEUsS0FBSzNFLElBQUk7UUFDbkNpRyxNQUFNcEcsY0FBYyxDQUFDRyxLQUFLLEdBQUcyRSxLQUFLL0UsS0FBSztRQUN2QyxPQUFPcUc7SUFDVCxHQUFHO1FBQ0Q3RDtRQUNBdkMsZ0JBQWdCLENBQUM7SUFDbkI7SUFDQSxNQUFNcUgsV0FBVztRQUFDTDtRQUFTQztRQUFXRztXQUFZRjtLQUFXLENBQUMvQyxNQUFNLENBQUNXLENBQUFBLE9BQVFBLFNBQVM7SUFDdEYsT0FBT3VDLFNBQVMvQyxHQUFHLENBQUMsQ0FBQzhCLE9BQU83RixJQUFPO1lBQ2pDNkYsT0FBTzFELGdCQUFnQm5DLE1BQU0sSUFBSTtnQkFDL0IsR0FBRzZGLEtBQUs7Z0JBQ1IxRDtZQUNGLElBQUkwRDtRQUNOO0FBQ0Y7QUFDQSxTQUFTakIsZ0JBQWdCbUMsR0FBRztJQUMxQixNQUFNcEQsT0FBTyxFQUFFO0lBQ2YsSUFBSyxJQUFJM0QsSUFBSSxHQUFHQSxJQUFJK0csSUFBSXpFLE1BQU0sRUFBRXRDLElBQUs7UUFDbkMsTUFBTWdFLE1BQU1nRCxPQUFPRCxHQUFHLENBQUMvRyxFQUFFO1FBQ3pCLElBQUksQ0FBQ2dFLE9BQU9MLEtBQUswQyxPQUFPLENBQUNyQyxTQUFTLENBQUMsR0FBRztZQUNwQyxPQUFPO1FBQ1Q7UUFDQUwsS0FBS1QsSUFBSSxDQUFDYztJQUNaO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBU2dELE9BQU90RyxHQUFHO0lBQ2pCLE9BQU8sT0FBT0EsUUFBUSxZQUFZQSxRQUFRLFFBQVFBLElBQUlKLElBQUk7QUFDNUQ7QUFDQSxTQUFTK0UsV0FBVzBCLEdBQUc7SUFDckIsT0FBT0EsSUFBSWxILE1BQU0sQ0FBQyxDQUFDK0csS0FBS3JDO1FBQ3RCcUMsSUFBSWpELElBQUksQ0FBQ1QsSUFBSSxDQUFDcUIsS0FBS2pFLElBQUk7UUFDdkJzRyxJQUFJbkIsS0FBSyxDQUFDbEIsS0FBS2pFLElBQUksQ0FBQyxHQUFHaUU7UUFDdkIsT0FBT3FDO0lBQ1QsR0FBRztRQUNEakQsTUFBTSxFQUFFO1FBQ1I4QixPQUFPLENBQUM7SUFDVjtBQUNGO0FBQ0EsU0FBU0YsYUFBYTFELEtBQUssRUFBRUMsS0FBSztJQUNoQyxPQUFPRCxNQUFNUyxNQUFNLEtBQUtSLE1BQU1RLE1BQU0sSUFBSVQsTUFBTW9GLEtBQUssQ0FBQyxDQUFDMUMsTUFBTXZFLElBQU04QixLQUFLLENBQUM5QixFQUFFLEtBQUt1RTtBQUNoRjtBQUNBLFNBQVNDLGlCQUFpQkQsSUFBSSxFQUFFM0UsSUFBSSxFQUFFNkYsS0FBSyxFQUFFOUQsT0FBTztJQUNsRCxJQUFJLE9BQU80QyxTQUFTLGFBQWE7UUFDL0IsT0FBT0E7SUFDVDtJQUNBLElBQUksQ0FBQzVDLFFBQVFMLFlBQVksRUFBRTtRQUN6QixNQUFNUixpQkFBaUJuQixhQUFhQyxLQUFLTyxNQUFNLENBQUNzRjtRQUNoRHlCLFFBQVFDLElBQUksQ0FBQyxtREFBbURoSCxNQUFNLENBQUNXLGdCQUFnQjtJQUN6RjtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVM2RCxpQkFBaUJoRCxPQUFPO0lBQy9CLE9BQU95RixRQUFRekYsUUFBUVEsWUFBWTtBQUNyQztBQUNBLFNBQVMyQixJQUFJdUQsQ0FBQztJQUNaLE9BQU87QUFDVDtBQUNBOUgsaUJBQWlCLEdBQUdvQjtBQUNwQnBCLGdCQUFnQixHQUFHa0Q7QUFDbkJsRCxpQkFBaUIsR0FBR3FDLFdBQ3BCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcnkuaW5mby8uL25vZGVfbW9kdWxlcy9zYW5pdHktZGlmZi1wYXRjaC9kaXN0L2luZGV4LmNqcz8yY2Y1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgZGlmZk1hdGNoUGF0Y2ggPSByZXF1aXJlKCdAc2FuaXR5L2RpZmYtbWF0Y2gtcGF0Y2gnKTtcbmZ1bmN0aW9uIHBhdGhUb1N0cmluZyhwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlZHVjZSgodGFyZ2V0LCBzZWdtZW50LCBpKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2VnbWVudCkpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0YXJnZXQsIFwiW1wiKS5jb25jYXQoc2VnbWVudC5qb2luKFwiOlwiKSwgXCJdXCIpO1xuICAgIH1cbiAgICBpZiAoaXNLZXllZE9iamVjdChzZWdtZW50KSkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRhcmdldCwgXCJbX2tleT09XFxcIlwiKS5jb25jYXQoc2VnbWVudC5fa2V5LCBcIlxcXCJdXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0YXJnZXQsIFwiW1wiKS5jb25jYXQoc2VnbWVudCwgXCJdXCIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlZ21lbnQgPT09IFwic3RyaW5nXCIgJiYgL15cXGQrJC8udGVzdChzZWdtZW50KSkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRhcmdldCwgXCJbXFxcIlwiKS5jb25jYXQoc2VnbWVudCwgXCJcXFwiXVwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBzZXBhcmF0b3IgPSBpID09PSAwID8gXCJcIiA6IFwiLlwiO1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRhcmdldCkuY29uY2F0KHNlcGFyYXRvcikuY29uY2F0KHNlZ21lbnQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBwYXRoIHNlZ21lbnQgXFxcIlwiLmNvbmNhdChzZWdtZW50LCBcIlxcXCJcIikpO1xuICB9LCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGlzS2V5ZWRPYmplY3Qob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmouX2tleSA9PT0gXCJzdHJpbmdcIjtcbn1cbmNsYXNzIERpZmZFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgcGF0aCwgdmFsdWUpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkUGF0aCA9IHBhdGhUb1N0cmluZyhwYXRoKTtcbiAgICBzdXBlcihcIlwiLmNvbmNhdChtZXNzYWdlLCBcIiAoYXQgJ1wiKS5jb25jYXQoc2VyaWFsaXplZFBhdGgsIFwiJylcIikpO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5zZXJpYWxpemVkUGF0aCA9IHNlcmlhbGl6ZWRQYXRoO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxufVxuY29uc3QgaWRQYXR0ZXJuID0gL15bYS16MC05XVthLXowLTlfLi1dKyQvaTtcbmNvbnN0IHByb3BQYXR0ZXJuID0gL15bYS16QS1aX11bYS16QS1aMC05X10qJC87XG5jb25zdCBwcm9wU3RhcnRQYXR0ZXJuID0gL15bYS16X10vaTtcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkocHJvcGVydHksIHZhbHVlLCBwYXRoKSB7XG4gIGlmICghcHJvcFN0YXJ0UGF0dGVybi50ZXN0KHByb3BlcnR5KSkge1xuICAgIHRocm93IG5ldyBEaWZmRXJyb3IoXCJLZXlzIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlciAoYS16KVwiLCBwYXRoLmNvbmNhdChwcm9wZXJ0eSksIHZhbHVlKTtcbiAgfVxuICBpZiAoIXByb3BQYXR0ZXJuLnRlc3QocHJvcGVydHkpKSB7XG4gICAgdGhyb3cgbmV3IERpZmZFcnJvcihcIktleXMgY2FuIG9ubHkgY29udGFpbiBsZXR0ZXJzLCBudW1iZXJzIGFuZCB1bmRlcnNjb3Jlc1wiLCBwYXRoLmNvbmNhdChwcm9wZXJ0eSksIHZhbHVlKTtcbiAgfVxuICBpZiAocHJvcGVydHkgPT09IFwiX2tleVwiIHx8IHByb3BlcnR5ID09PSBcIl9yZWZcIiB8fCBwcm9wZXJ0eSA9PT0gXCJfdHlwZVwiKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IERpZmZFcnJvcihcIktleXMgbXVzdCBiZSBzdHJpbmdzXCIsIHBhdGguY29uY2F0KHByb3BlcnR5KSwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIWlkUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IERpZmZFcnJvcihcIkludmFsaWQga2V5IC0gdXNlIGxlc3MgZXhvdGljIGNoYXJhY3RlcnNcIiwgcGF0aC5jb25jYXQocHJvcGVydHkpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wZXJ0eTtcbn1cbmNvbnN0IGlnbm9yZWRLZXlzID0gW1wiX2lkXCIsIFwiX3R5cGVcIiwgXCJfY3JlYXRlZEF0XCIsIFwiX3VwZGF0ZWRBdFwiLCBcIl9yZXZcIl07XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgaGlkZVdhcm5pbmdzOiBmYWxzZSxcbiAgZGlmZk1hdGNoUGF0Y2g6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8vIE9ubHkgdXNlIGRpZmYtbWF0Y2gtcGF0Y2ggaWYgdGFyZ2V0IHN0cmluZyBpcyBsb25nZXIgdGhhbiB0aGlzIHRocmVzaG9sZFxuICAgIGxlbmd0aFRocmVzaG9sZEFic29sdXRlOiAzMCxcbiAgICAvLyBPbmx5IHVzZSBnZW5lcmF0ZWQgZGlmZi1tYXRjaC1wYXRjaCBpZiB0aGUgcGF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICAgIC8vICh0YXJnZXRTdHJpbmcgKiByZWxhdGl2ZSkuIEV4YW1wbGU6IEEgMTAwIGNoYXJhY3RlciB0YXJnZXQgd2l0aCBhIHJlbGF0aXZlIGZhY3RvclxuICAgIC8vIG9mIDEuMiB3aWxsIGFsbG93IGEgMTIwIGNoYXJhY3RlciBkaWZmLW1hdGNoLXBhdGNoLiBJZiBsYXJnZXIgdGhhbiB0aGlzIG51bWJlcixcbiAgICAvLyBpdCB3aWxsIGZhbGwgYmFjayB0byBhIHJlZ3VsYXIgYHNldGAgcGF0Y2guXG4gICAgbGVuZ3RoVGhyZXNob2xkUmVsYXRpdmU6IDEuMlxuICB9XG59O1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi5vcHRpb25zLFxuICAgIGRpZmZNYXRjaFBhdGNoOiB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucy5kaWZmTWF0Y2hQYXRjaCxcbiAgICAgIC4uLihvcHRpb25zLmRpZmZNYXRjaFBhdGNoIHx8IHt9KVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGRpZmZQYXRjaChpdGVtQSwgaXRlbUIsIG9wdHMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhvcHRzIHx8IHt9KTtcbiAgY29uc3QgaWQgPSBvcHRpb25zLmlkIHx8IGl0ZW1BLl9pZCA9PT0gaXRlbUIuX2lkICYmIGl0ZW1BLl9pZDtcbiAgY29uc3QgcmV2aXNpb25Mb2NrZWQgPSBvcHRpb25zLmlmUmV2aXNpb25JRDtcbiAgY29uc3QgaWZSZXZpc2lvbklEID0gdHlwZW9mIHJldmlzaW9uTG9ja2VkID09PSBcImJvb2xlYW5cIiA/IGl0ZW1BLl9yZXYgOiByZXZpc2lvbkxvY2tlZDtcbiAgY29uc3QgYmFzZVBhdGggPSBvcHRpb25zLmJhc2VQYXRoIHx8IFtdO1xuICBpZiAoIWlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiX2lkIG9uIGl0ZW1BIGFuZCBpdGVtQiBub3QgcHJlc2VudCBvciBkaWZmZXJzLCBzcGVjaWZ5IGRvY3VtZW50IGlkIHRoZSBtdXRhdGlvbnMgc2hvdWxkIGJlIGFwcGxpZWQgdG9cIik7XG4gIH1cbiAgaWYgKHJldmlzaW9uTG9ja2VkID09PSB0cnVlICYmICFpZlJldmlzaW9uSUQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgaWZSZXZpc2lvbklEYCBpcyBzZXQgdG8gYHRydWVgLCBidXQgbm8gYF9yZXZgIHdhcyBwYXNzZWQgaW4gaXRlbSBBLiBFaXRoZXIgZXhwbGljaXRseSBzZXQgYGlmUmV2aXNpb25JRGAgdG8gYSByZXZpc2lvbiwgb3IgcGFzcyBgX3JldmAgYXMgcGFydCBvZiBpdGVtIEEuXCIpO1xuICB9XG4gIGlmIChiYXNlUGF0aC5sZW5ndGggPT09IDAgJiYgaXRlbUEuX3R5cGUgIT09IGl0ZW1CLl90eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiX3R5cGUgaXMgaW1tdXRhYmxlIGFuZCBjYW5ub3QgYmUgY2hhbmdlZCAoXCIuY29uY2F0KGl0ZW1BLl90eXBlLCBcIiA9PiBcIikuY29uY2F0KGl0ZW1CLl90eXBlLCBcIilcIikpO1xuICB9XG4gIGNvbnN0IG9wZXJhdGlvbnMgPSBkaWZmSXRlbShpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIGJhc2VQYXRoLCBbXSk7XG4gIHJldHVybiBzZXJpYWxpemVQYXRjaGVzKG9wZXJhdGlvbnMsIHtcbiAgICBpZCxcbiAgICBpZlJldmlzaW9uSUQ6IHJldmlzaW9uTG9ja2VkID8gaWZSZXZpc2lvbklEIDogdm9pZCAwXG4gIH0pO1xufVxuZnVuY3Rpb24gZGlmZkl0ZW0oaXRlbUEsIGl0ZW1CKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBkZWZhdWx0T3B0aW9ucztcbiAgbGV0IHBhdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFtdO1xuICBsZXQgcGF0Y2hlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogW107XG4gIGlmIChpdGVtQSA9PT0gaXRlbUIpIHtcbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICBjb25zdCBhVHlwZSA9IEFycmF5LmlzQXJyYXkoaXRlbUEpID8gXCJhcnJheVwiIDogdHlwZW9mIGl0ZW1BO1xuICBjb25zdCBiVHlwZSA9IEFycmF5LmlzQXJyYXkoaXRlbUIpID8gXCJhcnJheVwiIDogdHlwZW9mIGl0ZW1CO1xuICBjb25zdCBhSXNVbmRlZmluZWQgPSBhVHlwZSA9PT0gXCJ1bmRlZmluZWRcIjtcbiAgY29uc3QgYklzVW5kZWZpbmVkID0gYlR5cGUgPT09IFwidW5kZWZpbmVkXCI7XG4gIGlmIChhSXNVbmRlZmluZWQgJiYgIWJJc1VuZGVmaW5lZCkge1xuICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogXCJzZXRcIixcbiAgICAgIHBhdGgsXG4gICAgICB2YWx1ZTogaXRlbUJcbiAgICB9KTtcbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICBpZiAoIWFJc1VuZGVmaW5lZCAmJiBiSXNVbmRlZmluZWQpIHtcbiAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgb3A6IFwidW5zZXRcIixcbiAgICAgIHBhdGhcbiAgICB9KTtcbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICBjb25zdCBvcHRpb25zID0gbWVyZ2VPcHRpb25zKG9wdHMpO1xuICBjb25zdCBkYXRhVHlwZSA9IGFJc1VuZGVmaW5lZCA/IGJUeXBlIDogYVR5cGU7XG4gIGNvbnN0IGlzQ29udGFpbmVyID0gZGF0YVR5cGUgPT09IFwib2JqZWN0XCIgfHwgZGF0YVR5cGUgPT09IFwiYXJyYXlcIjtcbiAgaWYgKCFpc0NvbnRhaW5lcikge1xuICAgIHJldHVybiBkaWZmUHJpbWl0aXZlKGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcyk7XG4gIH1cbiAgaWYgKGFUeXBlICE9PSBiVHlwZSkge1xuICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICBvcDogXCJzZXRcIixcbiAgICAgIHBhdGgsXG4gICAgICB2YWx1ZTogaXRlbUJcbiAgICB9KTtcbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgfVxuICByZXR1cm4gZGF0YVR5cGUgPT09IFwiYXJyYXlcIiA/IGRpZmZBcnJheShpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIDogZGlmZk9iamVjdChpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpO1xufVxuZnVuY3Rpb24gZGlmZk9iamVjdChpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIHtcbiAgY29uc3QgYXRSb290ID0gcGF0aC5sZW5ndGggPT09IDA7XG4gIGNvbnN0IGFLZXlzID0gT2JqZWN0LmtleXMoaXRlbUEpLmZpbHRlcihhdFJvb3QgPyBpc05vdElnbm9yZWRLZXkgOiB5ZXMpLm1hcChrZXkgPT4gdmFsaWRhdGVQcm9wZXJ0eShrZXksIGl0ZW1BW2tleV0sIHBhdGgpKTtcbiAgY29uc3QgYUtleXNMZW5ndGggPSBhS2V5cy5sZW5ndGg7XG4gIGNvbnN0IGJLZXlzID0gT2JqZWN0LmtleXMoaXRlbUIpLmZpbHRlcihhdFJvb3QgPyBpc05vdElnbm9yZWRLZXkgOiB5ZXMpLm1hcChrZXkgPT4gdmFsaWRhdGVQcm9wZXJ0eShrZXksIGl0ZW1CW2tleV0sIHBhdGgpKTtcbiAgY29uc3QgYktleXNMZW5ndGggPSBiS2V5cy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYUtleXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGFLZXlzW2ldO1xuICAgIGlmICghKGtleSBpbiBpdGVtQikpIHtcbiAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgIG9wOiBcInVuc2V0XCIsXG4gICAgICAgIHBhdGg6IHBhdGguY29uY2F0KGtleSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJLZXlzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBiS2V5c1tpXTtcbiAgICBkaWZmSXRlbShpdGVtQVtrZXldLCBpdGVtQltrZXldLCBvcHRpb25zLCBwYXRoLmNvbmNhdChba2V5XSksIHBhdGNoZXMpO1xuICB9XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gZGlmZkFycmF5KGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcykge1xuICBpZiAoaXRlbUIubGVuZ3RoID4gaXRlbUEubGVuZ3RoKSB7XG4gICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgIG9wOiBcImluc2VydFwiLFxuICAgICAgYWZ0ZXI6IHBhdGguY29uY2F0KFstMV0pLFxuICAgICAgaXRlbXM6IGl0ZW1CLnNsaWNlKGl0ZW1BLmxlbmd0aCkubWFwKChpdGVtLCBpKSA9PiBudWxsaWZ5VW5kZWZpbmVkKGl0ZW0sIHBhdGgsIGksIG9wdGlvbnMpKVxuICAgIH0pO1xuICB9XG4gIGlmIChpdGVtQi5sZW5ndGggPCBpdGVtQS5sZW5ndGgpIHtcbiAgICBjb25zdCBpc1NpbmdsZSA9IGl0ZW1BLmxlbmd0aCAtIGl0ZW1CLmxlbmd0aCA9PT0gMTtcbiAgICBjb25zdCB1bnNldEl0ZW1zID0gaXRlbUEuc2xpY2UoaXRlbUIubGVuZ3RoKTtcbiAgICBpZiAoaXNSZXZpc2lvbkxvY2tlZChvcHRpb25zKSB8fCAhaXNVbmlxdWVseUtleWVkKHVuc2V0SXRlbXMpKSB7XG4gICAgICBwYXRjaGVzLnB1c2goe1xuICAgICAgICBvcDogXCJ1bnNldFwiLFxuICAgICAgICBwYXRoOiBwYXRoLmNvbmNhdChbaXNTaW5nbGUgPyBpdGVtQi5sZW5ndGggOiBbaXRlbUIubGVuZ3RoLCBcIlwiXV0pXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0Y2hlcy5wdXNoKC4uLnVuc2V0SXRlbXMubWFwKGl0ZW0gPT4gKHtcbiAgICAgICAgb3A6IFwidW5zZXRcIixcbiAgICAgICAgcGF0aDogcGF0aC5jb25jYXQoe1xuICAgICAgICAgIF9rZXk6IGl0ZW0uX2tleVxuICAgICAgICB9KVxuICAgICAgfSkpKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtQi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1CW2ldKSkge1xuICAgICAgdGhyb3cgbmV3IERpZmZFcnJvcihcIk11bHRpLWRpbWVuc2lvbmFsIGFycmF5cyBub3Qgc3VwcG9ydGVkXCIsIHBhdGguY29uY2F0KGkpLCBpdGVtQltpXSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG92ZXJsYXBwaW5nID0gTWF0aC5taW4oaXRlbUEubGVuZ3RoLCBpdGVtQi5sZW5ndGgpO1xuICBjb25zdCBzZWdtZW50QSA9IGl0ZW1BLnNsaWNlKDAsIG92ZXJsYXBwaW5nKTtcbiAgY29uc3Qgc2VnbWVudEIgPSBpdGVtQi5zbGljZSgwLCBvdmVybGFwcGluZyk7XG4gIHJldHVybiBpc1VuaXF1ZWx5S2V5ZWQoc2VnbWVudEEpICYmIGlzVW5pcXVlbHlLZXllZChzZWdtZW50QikgPyBkaWZmQXJyYXlCeUtleShzZWdtZW50QSwgc2VnbWVudEIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIDogZGlmZkFycmF5QnlJbmRleChzZWdtZW50QSwgc2VnbWVudEIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpO1xufVxuZnVuY3Rpb24gZGlmZkFycmF5QnlJbmRleChpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtQS5sZW5ndGg7IGkrKykge1xuICAgIGRpZmZJdGVtKGl0ZW1BW2ldLCBudWxsaWZ5VW5kZWZpbmVkKGl0ZW1CW2ldLCBwYXRoLCBpLCBvcHRpb25zKSwgb3B0aW9ucywgcGF0aC5jb25jYXQoaSksIHBhdGNoZXMpO1xuICB9XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gZGlmZkFycmF5QnlLZXkoaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoLCBwYXRjaGVzKSB7XG4gIGNvbnN0IGtleWVkQSA9IGluZGV4QnlLZXkoaXRlbUEpO1xuICBjb25zdCBrZXllZEIgPSBpbmRleEJ5S2V5KGl0ZW1CKTtcbiAgaWYgKCFhcnJheUlzRXF1YWwoa2V5ZWRBLmtleXMsIGtleWVkQi5rZXlzKSkge1xuICAgIHJldHVybiBkaWZmQXJyYXlCeUluZGV4KGl0ZW1BLCBpdGVtQiwgb3B0aW9ucywgcGF0aCwgcGF0Y2hlcyk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXllZEIua2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleWVkQi5rZXlzW2ldO1xuICAgIGNvbnN0IHZhbHVlQSA9IGtleWVkQS5pbmRleFtrZXldO1xuICAgIGNvbnN0IHZhbHVlQiA9IG51bGxpZnlVbmRlZmluZWQoa2V5ZWRCLmluZGV4W2tleV0sIHBhdGgsIGksIG9wdGlvbnMpO1xuICAgIGRpZmZJdGVtKHZhbHVlQSwgdmFsdWVCLCBvcHRpb25zLCBwYXRoLmNvbmNhdCh7XG4gICAgICBfa2V5OiBrZXlcbiAgICB9KSwgcGF0Y2hlcyk7XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXM7XG59XG5mdW5jdGlvbiBnZXREaWZmTWF0Y2hQYXRjaChpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgpIHtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQsXG4gICAgbGVuZ3RoVGhyZXNob2xkUmVsYXRpdmUsXG4gICAgbGVuZ3RoVGhyZXNob2xkQWJzb2x1dGVcbiAgfSA9IG9wdGlvbnMuZGlmZk1hdGNoUGF0Y2g7XG4gIGNvbnN0IHNlZ21lbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIGlmICghZW5hYmxlZCB8fFxuICAvLyBEb24ndCB1c2UgZm9yIGFueXRoaW5nIGJ1dCBzdHJpbmdzXG4gIHR5cGVvZiBpdGVtQSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgaXRlbUIgIT09IFwic3RyaW5nXCIgfHxcbiAgLy8gRG9uJ3QgdXNlIGZvciBgX2tleWAsIGBfcmVmYCBldGNcbiAgdHlwZW9mIHNlZ21lbnQgPT09IFwic3RyaW5nXCIgJiYgc2VnbWVudFswXSA9PT0gXCJfXCIgfHxcbiAgLy8gRG9uJ3QgdXNlIG9uIHNob3J0IHN0cmluZ3NcbiAgaXRlbUIubGVuZ3RoIDwgbGVuZ3RoVGhyZXNob2xkQWJzb2x1dGUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCBzdHJQYXRjaCA9IFwiXCI7XG4gIHRyeSB7XG4gICAgY29uc3QgcGF0Y2ggPSBkaWZmTWF0Y2hQYXRjaC5tYWtlRGlmZihpdGVtQSwgaXRlbUIpO1xuICAgIGNvbnN0IGRpZmYgPSBkaWZmTWF0Y2hQYXRjaC5jbGVhbnVwRWZmaWNpZW5jeShwYXRjaCk7XG4gICAgc3RyUGF0Y2ggPSBkaWZmTWF0Y2hQYXRjaC5zdHJpbmdpZnlQYXRjaGVzKGRpZmZNYXRjaFBhdGNoLm1ha2VQYXRjaGVzKGRpZmYpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gc3RyUGF0Y2gubGVuZ3RoID4gaXRlbUIubGVuZ3RoICogbGVuZ3RoVGhyZXNob2xkUmVsYXRpdmUgPyB2b2lkIDAgOiB7XG4gICAgb3A6IFwiZGlmZk1hdGNoUGF0Y2hcIixcbiAgICBwYXRoLFxuICAgIHZhbHVlOiBzdHJQYXRjaFxuICB9O1xufVxuZnVuY3Rpb24gZGlmZlByaW1pdGl2ZShpdGVtQSwgaXRlbUIsIG9wdGlvbnMsIHBhdGgsIHBhdGNoZXMpIHtcbiAgY29uc3QgZG1wID0gZ2V0RGlmZk1hdGNoUGF0Y2goaXRlbUEsIGl0ZW1CLCBvcHRpb25zLCBwYXRoKTtcbiAgcGF0Y2hlcy5wdXNoKGRtcCB8fCB7XG4gICAgb3A6IFwic2V0XCIsXG4gICAgcGF0aCxcbiAgICB2YWx1ZTogaXRlbUJcbiAgfSk7XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gaXNOb3RJZ25vcmVkS2V5KGtleSkge1xuICByZXR1cm4gaWdub3JlZEtleXMuaW5kZXhPZihrZXkpID09PSAtMTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVBhdGNoZXMocGF0Y2hlcywgb3B0aW9ucykge1xuICBpZiAocGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3Qge1xuICAgIGlkLFxuICAgIGlmUmV2aXNpb25JRFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3Qgc2V0ID0gcGF0Y2hlcy5maWx0ZXIocGF0Y2ggPT4gcGF0Y2gub3AgPT09IFwic2V0XCIpO1xuICBjb25zdCB1bnNldCA9IHBhdGNoZXMuZmlsdGVyKHBhdGNoID0+IHBhdGNoLm9wID09PSBcInVuc2V0XCIpO1xuICBjb25zdCBpbnNlcnQgPSBwYXRjaGVzLmZpbHRlcihwYXRjaCA9PiBwYXRjaC5vcCA9PT0gXCJpbnNlcnRcIik7XG4gIGNvbnN0IGRtcCA9IHBhdGNoZXMuZmlsdGVyKHBhdGNoID0+IHBhdGNoLm9wID09PSBcImRpZmZNYXRjaFBhdGNoXCIpO1xuICBjb25zdCB3aXRoU2V0ID0gc2V0Lmxlbmd0aCA+IDAgJiYgc2V0LnJlZHVjZSgocGF0Y2gsIGl0ZW0pID0+IHtcbiAgICBjb25zdCBwYXRoID0gcGF0aFRvU3RyaW5nKGl0ZW0ucGF0aCk7XG4gICAgcGF0Y2guc2V0W3BhdGhdID0gaXRlbS52YWx1ZTtcbiAgICByZXR1cm4gcGF0Y2g7XG4gIH0sIHtcbiAgICBpZCxcbiAgICBzZXQ6IHt9XG4gIH0pO1xuICBjb25zdCB3aXRoVW5zZXQgPSB1bnNldC5sZW5ndGggPiAwICYmIHVuc2V0LnJlZHVjZSgocGF0Y2gsIGl0ZW0pID0+IHtcbiAgICBjb25zdCBwYXRoID0gcGF0aFRvU3RyaW5nKGl0ZW0ucGF0aCk7XG4gICAgcGF0Y2gudW5zZXQucHVzaChwYXRoKTtcbiAgICByZXR1cm4gcGF0Y2g7XG4gIH0sIHtcbiAgICBpZCxcbiAgICB1bnNldDogW11cbiAgfSk7XG4gIGNvbnN0IHdpdGhJbnNlcnQgPSBpbnNlcnQucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICBjb25zdCBhZnRlciA9IHBhdGhUb1N0cmluZyhpdGVtLmFmdGVyKTtcbiAgICByZXR1cm4gYWNjLmNvbmNhdCh7XG4gICAgICBpZCxcbiAgICAgIGluc2VydDoge1xuICAgICAgICBhZnRlcixcbiAgICAgICAgaXRlbXM6IGl0ZW0uaXRlbXNcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCB3aXRoRG1wID0gZG1wLmxlbmd0aCA+IDAgJiYgZG1wLnJlZHVjZSgocGF0Y2gsIGl0ZW0pID0+IHtcbiAgICBjb25zdCBwYXRoID0gcGF0aFRvU3RyaW5nKGl0ZW0ucGF0aCk7XG4gICAgcGF0Y2guZGlmZk1hdGNoUGF0Y2hbcGF0aF0gPSBpdGVtLnZhbHVlO1xuICAgIHJldHVybiBwYXRjaDtcbiAgfSwge1xuICAgIGlkLFxuICAgIGRpZmZNYXRjaFBhdGNoOiB7fVxuICB9KTtcbiAgY29uc3QgcGF0Y2hTZXQgPSBbd2l0aFNldCwgd2l0aFVuc2V0LCB3aXRoRG1wLCAuLi53aXRoSW5zZXJ0XS5maWx0ZXIoaXRlbSA9PiBpdGVtICE9PSBmYWxzZSk7XG4gIHJldHVybiBwYXRjaFNldC5tYXAoKHBhdGNoLCBpKSA9PiAoe1xuICAgIHBhdGNoOiBpZlJldmlzaW9uSUQgJiYgaSA9PT0gMCA/IHtcbiAgICAgIC4uLnBhdGNoLFxuICAgICAgaWZSZXZpc2lvbklEXG4gICAgfSA6IHBhdGNoXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGlzVW5pcXVlbHlLZXllZChhcnIpIHtcbiAgY29uc3Qga2V5cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGdldEtleShhcnJbaV0pO1xuICAgIGlmICgha2V5IHx8IGtleXMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldEtleShvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqICE9PSBudWxsICYmIG9iai5fa2V5O1xufVxuZnVuY3Rpb24gaW5kZXhCeUtleShhcnIpIHtcbiAgcmV0dXJuIGFyci5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgIGFjYy5rZXlzLnB1c2goaXRlbS5fa2V5KTtcbiAgICBhY2MuaW5kZXhbaXRlbS5fa2V5XSA9IGl0ZW07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge1xuICAgIGtleXM6IFtdLFxuICAgIGluZGV4OiB7fVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFycmF5SXNFcXVhbChpdGVtQSwgaXRlbUIpIHtcbiAgcmV0dXJuIGl0ZW1BLmxlbmd0aCA9PT0gaXRlbUIubGVuZ3RoICYmIGl0ZW1BLmV2ZXJ5KChpdGVtLCBpKSA9PiBpdGVtQltpXSA9PT0gaXRlbSk7XG59XG5mdW5jdGlvbiBudWxsaWZ5VW5kZWZpbmVkKGl0ZW0sIHBhdGgsIGluZGV4LCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgaXRlbSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBpdGVtO1xuICB9XG4gIGlmICghb3B0aW9ucy5oaWRlV2FybmluZ3MpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkUGF0aCA9IHBhdGhUb1N0cmluZyhwYXRoLmNvbmNhdChpbmRleCkpO1xuICAgIGNvbnNvbGUud2FybihcInVuZGVmaW5lZCB2YWx1ZSBpbiBhcnJheSBjb252ZXJ0ZWQgdG8gbnVsbCAoYXQgJ1wiLmNvbmNhdChzZXJpYWxpemVkUGF0aCwgXCInKVwiKSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc1JldmlzaW9uTG9ja2VkKG9wdGlvbnMpIHtcbiAgcmV0dXJuIEJvb2xlYW4ob3B0aW9ucy5pZlJldmlzaW9uSUQpO1xufVxuZnVuY3Rpb24geWVzKF8pIHtcbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLkRpZmZFcnJvciA9IERpZmZFcnJvcjtcbmV4cG9ydHMuZGlmZkl0ZW0gPSBkaWZmSXRlbTtcbmV4cG9ydHMuZGlmZlBhdGNoID0gZGlmZlBhdGNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguY2pzLm1hcFxuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGlmZk1hdGNoUGF0Y2giLCJyZXF1aXJlIiwicGF0aFRvU3RyaW5nIiwicGF0aCIsInJlZHVjZSIsInRhcmdldCIsInNlZ21lbnQiLCJpIiwiQXJyYXkiLCJpc0FycmF5IiwiY29uY2F0Iiwiam9pbiIsImlzS2V5ZWRPYmplY3QiLCJfa2V5IiwidGVzdCIsInNlcGFyYXRvciIsIkVycm9yIiwib2JqIiwiRGlmZkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwic2VyaWFsaXplZFBhdGgiLCJpZFBhdHRlcm4iLCJwcm9wUGF0dGVybiIsInByb3BTdGFydFBhdHRlcm4iLCJ2YWxpZGF0ZVByb3BlcnR5IiwicHJvcGVydHkiLCJpZ25vcmVkS2V5cyIsImRlZmF1bHRPcHRpb25zIiwiaGlkZVdhcm5pbmdzIiwiZW5hYmxlZCIsImxlbmd0aFRocmVzaG9sZEFic29sdXRlIiwibGVuZ3RoVGhyZXNob2xkUmVsYXRpdmUiLCJtZXJnZU9wdGlvbnMiLCJvcHRpb25zIiwiZGlmZlBhdGNoIiwiaXRlbUEiLCJpdGVtQiIsIm9wdHMiLCJpZCIsIl9pZCIsInJldmlzaW9uTG9ja2VkIiwiaWZSZXZpc2lvbklEIiwiX3JldiIsImJhc2VQYXRoIiwibGVuZ3RoIiwiX3R5cGUiLCJvcGVyYXRpb25zIiwiZGlmZkl0ZW0iLCJzZXJpYWxpemVQYXRjaGVzIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwicGF0Y2hlcyIsImFUeXBlIiwiYlR5cGUiLCJhSXNVbmRlZmluZWQiLCJiSXNVbmRlZmluZWQiLCJwdXNoIiwib3AiLCJkYXRhVHlwZSIsImlzQ29udGFpbmVyIiwiZGlmZlByaW1pdGl2ZSIsImRpZmZBcnJheSIsImRpZmZPYmplY3QiLCJhdFJvb3QiLCJhS2V5cyIsImtleXMiLCJmaWx0ZXIiLCJpc05vdElnbm9yZWRLZXkiLCJ5ZXMiLCJtYXAiLCJrZXkiLCJhS2V5c0xlbmd0aCIsImJLZXlzIiwiYktleXNMZW5ndGgiLCJhZnRlciIsIml0ZW1zIiwic2xpY2UiLCJpdGVtIiwibnVsbGlmeVVuZGVmaW5lZCIsImlzU2luZ2xlIiwidW5zZXRJdGVtcyIsImlzUmV2aXNpb25Mb2NrZWQiLCJpc1VuaXF1ZWx5S2V5ZWQiLCJvdmVybGFwcGluZyIsIk1hdGgiLCJtaW4iLCJzZWdtZW50QSIsInNlZ21lbnRCIiwiZGlmZkFycmF5QnlLZXkiLCJkaWZmQXJyYXlCeUluZGV4Iiwia2V5ZWRBIiwiaW5kZXhCeUtleSIsImtleWVkQiIsImFycmF5SXNFcXVhbCIsInZhbHVlQSIsImluZGV4IiwidmFsdWVCIiwiZ2V0RGlmZk1hdGNoUGF0Y2giLCJzdHJQYXRjaCIsInBhdGNoIiwibWFrZURpZmYiLCJkaWZmIiwiY2xlYW51cEVmZmljaWVuY3kiLCJzdHJpbmdpZnlQYXRjaGVzIiwibWFrZVBhdGNoZXMiLCJlcnIiLCJkbXAiLCJpbmRleE9mIiwic2V0IiwidW5zZXQiLCJpbnNlcnQiLCJ3aXRoU2V0Iiwid2l0aFVuc2V0Iiwid2l0aEluc2VydCIsImFjYyIsIndpdGhEbXAiLCJwYXRjaFNldCIsImFyciIsImdldEtleSIsImV2ZXJ5IiwiY29uc29sZSIsIndhcm4iLCJCb29sZWFuIiwiXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sanity-diff-patch/dist/index.cjs\n");

/***/ })

};
;