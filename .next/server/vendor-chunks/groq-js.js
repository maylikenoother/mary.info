"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/groq-js";
exports.ids = ["vendor-chunks/groq-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/groq-js/dist/1.js":
/*!****************************************!*\
  !*** ./node_modules/groq-js/dist/1.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar __defProp$5 = Object.defineProperty;\nvar __defNormalProp$5 = (obj, key, value)=>key in obj ? __defProp$5(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField$5 = (obj, key, value)=>{\n    __defNormalProp$5(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nfunction escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction pathRegExp(pattern) {\n    const re = [];\n    for (const part of pattern.split(\".\")){\n        if (part === \"*\") {\n            re.push(\"[^.]+\");\n        } else if (part === \"**\") {\n            re.push(\".*\");\n        } else {\n            re.push(escapeRegExp(part));\n        }\n    }\n    return new RegExp(\"^\".concat(re.join(\".\"), \"$\"));\n}\nclass Path {\n    constructor(pattern){\n        __publicField$5(this, \"pattern\");\n        __publicField$5(this, \"patternRe\");\n        this.pattern = pattern;\n        this.patternRe = pathRegExp(pattern);\n    }\n    matches(str) {\n        return this.patternRe.test(str);\n    }\n    toJSON() {\n        return this.pattern;\n    }\n}\nvar __defProp$4 = Object.defineProperty;\nvar __defNormalProp$4 = (obj, key, value)=>key in obj ? __defProp$4(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField$4 = (obj, key, value)=>{\n    __defNormalProp$4(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nclass StreamValue {\n    constructor(generator){\n        __publicField$4(this, \"type\", \"stream\");\n        __publicField$4(this, \"generator\");\n        __publicField$4(this, \"ticker\");\n        __publicField$4(this, \"isDone\");\n        __publicField$4(this, \"data\");\n        this.generator = generator;\n        this.ticker = null;\n        this.isDone = false;\n        this.data = [];\n    }\n    // eslint-disable-next-line class-methods-use-this\n    isArray() {\n        return true;\n    }\n    async get() {\n        const result = [];\n        for await (const value of this){\n            result.push(await value.get());\n        }\n        return result;\n    }\n    async *[Symbol.asyncIterator]() {\n        let i = 0;\n        while(true){\n            for(; i < this.data.length; i++){\n                yield this.data[i];\n            }\n            if (this.isDone) {\n                return;\n            }\n            await this._nextTick();\n        }\n    }\n    _nextTick() {\n        if (this.ticker) {\n            return this.ticker;\n        }\n        let currentResolver;\n        const setupTicker = ()=>{\n            this.ticker = new Promise((resolve)=>{\n                currentResolver = resolve;\n            });\n        };\n        const tick = ()=>{\n            currentResolver();\n            setupTicker();\n        };\n        const fetch = async ()=>{\n            for await (const value of this.generator()){\n                this.data.push(value);\n                tick();\n            }\n            this.isDone = true;\n            tick();\n        };\n        setupTicker();\n        fetch();\n        return this.ticker;\n    }\n}\nconst RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n    if (RFC3339_REGEX.test(str)) {\n        return new Date(str);\n    }\n    return null;\n}\nfunction formatRFC3339(d) {\n    const year = addLeadingZero(d.getUTCFullYear(), 4);\n    const month = addLeadingZero(d.getUTCMonth() + 1, 2);\n    const day = addLeadingZero(d.getUTCDate(), 2);\n    const hour = addLeadingZero(d.getUTCHours(), 2);\n    const minute = addLeadingZero(d.getUTCMinutes(), 2);\n    const second = addLeadingZero(d.getUTCSeconds(), 2);\n    let fractionalSecond = \"\";\n    const millis = d.getMilliseconds();\n    if (millis != 0) {\n        fractionalSecond = \".\".concat(addLeadingZero(millis, 3));\n    }\n    return \"\".concat(year, \"-\").concat(month, \"-\").concat(day, \"T\").concat(hour, \":\").concat(minute, \":\").concat(second).concat(fractionalSecond, \"Z\");\n}\nfunction addLeadingZero(num, targetLength) {\n    let str = num.toString();\n    while(str.length < targetLength){\n        str = \"0\".concat(str);\n    }\n    return str;\n}\nvar __defProp$3 = Object.defineProperty;\nvar __defNormalProp$3 = (obj, key, value)=>key in obj ? __defProp$3(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField$3 = (obj, key, value)=>{\n    __defNormalProp$3(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nclass StaticValue {\n    constructor(data, type){\n        __publicField$3(this, \"data\");\n        __publicField$3(this, \"type\");\n        this.data = data;\n        this.type = type;\n    }\n    isArray() {\n        return this.type === \"array\";\n    }\n    // eslint-disable-next-line require-await\n    async get() {\n        return this.data;\n    }\n    [Symbol.asyncIterator]() {\n        if (Array.isArray(this.data)) {\n            return function*(data) {\n                for (const element of data){\n                    yield fromJS(element);\n                }\n            }(this.data);\n        }\n        throw new Error(\"Cannot iterate over: \".concat(this.type));\n    }\n}\nconst NULL_VALUE = new StaticValue(null, \"null\");\nconst TRUE_VALUE = new StaticValue(true, \"boolean\");\nconst FALSE_VALUE = new StaticValue(false, \"boolean\");\nclass DateTime {\n    constructor(date){\n        __publicField$3(this, \"date\");\n        this.date = date;\n    }\n    static parseToValue(str) {\n        const date = parseRFC3339(str);\n        if (date) {\n            return new StaticValue(new DateTime(date), \"datetime\");\n        }\n        return NULL_VALUE;\n    }\n    equals(other) {\n        return this.date.getTime() == other.date.getTime();\n    }\n    add(secs) {\n        const copy = new Date(this.date.getTime());\n        copy.setTime(copy.getTime() + secs * 1e3);\n        return new DateTime(copy);\n    }\n    difference(other) {\n        return (this.date.getTime() - other.date.getTime()) / 1e3;\n    }\n    compareTo(other) {\n        return this.date.getTime() - other.date.getTime();\n    }\n    toString() {\n        return formatRFC3339(this.date);\n    }\n    toJSON() {\n        return this.toString();\n    }\n}\nfunction fromNumber(num) {\n    if (Number.isFinite(num)) {\n        return new StaticValue(num, \"number\");\n    }\n    return NULL_VALUE;\n}\nfunction fromString(str) {\n    return new StaticValue(str, \"string\");\n}\nfunction fromDateTime(dt) {\n    return new StaticValue(dt, \"datetime\");\n}\nfunction fromPath(path) {\n    return new StaticValue(path, \"path\");\n}\nfunction isIterator(obj) {\n    return obj && typeof obj.next === \"function\";\n}\nfunction fromJS(val) {\n    if (isIterator(val)) {\n        return new StreamValue(async function*() {\n            for await (const value of val){\n                yield fromJS(value);\n            }\n        });\n    } else if (val === null || val === void 0) {\n        return NULL_VALUE;\n    }\n    return new StaticValue(val, getType(val));\n}\nfunction getType(data) {\n    if (data === null || typeof data === \"undefined\") {\n        return \"null\";\n    }\n    if (Array.isArray(data)) {\n        return \"array\";\n    }\n    if (data instanceof Path) {\n        return \"path\";\n    }\n    if (data instanceof DateTime) {\n        return \"datetime\";\n    }\n    return typeof data;\n}\nfunction isEqual(a, b) {\n    if (a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\") {\n        return a.data === b.data;\n    }\n    if (a.type === \"datetime\" && b.type === \"datetime\") {\n        return a.data.equals(b.data);\n    }\n    return false;\n}\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nconst MAX_TERM_LENGTH = 1024;\nfunction matchText(tokens, patterns) {\n    if (tokens.length === 0 || patterns.length === 0) {\n        return false;\n    }\n    return patterns.every((pattern)=>pattern(tokens));\n}\nfunction matchTokenize(text) {\n    return text.replace(EDGE_CHARS, \"\").match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text) {\n    const termsRe = matchPatternRegex(text);\n    return termsRe.map((re)=>(tokens)=>tokens.some((token)=>re.test(token)));\n}\nfunction matchPatternRegex(text) {\n    const terms = text.replace(EDGE_CHARS, \"\").match(CHARS_WITH_WILDCARD) || [];\n    return terms.map((term)=>new RegExp(\"^\".concat(term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, \".*\"), \"$\"), \"i\"));\n}\nasync function gatherText(value, cb) {\n    if (value.type === \"string\") {\n        cb(value.data);\n        return true;\n    }\n    if (value.isArray()) {\n        let success = true;\n        for await (const part of value){\n            if (part.type === \"string\") {\n                cb(part.data);\n            } else {\n                success = false;\n            }\n        }\n        return success;\n    }\n    return false;\n}\nconst TYPE_ORDER = {\n    datetime: 1,\n    number: 2,\n    string: 3,\n    boolean: 4\n};\nfunction partialCompare(a, b) {\n    const aType = getType(a);\n    const bType = getType(b);\n    if (aType !== bType) {\n        return null;\n    }\n    switch(aType){\n        case \"number\":\n        case \"boolean\":\n            return a - b;\n        case \"string\":\n            if (a < b) return -1;\n            if (a > b) return 1;\n            return 0;\n        case \"datetime\":\n            return a.compareTo(b);\n        default:\n            return null;\n    }\n}\nfunction totalCompare(a, b) {\n    const aType = getType(a);\n    const bType = getType(b);\n    const aTypeOrder = TYPE_ORDER[aType] || 100;\n    const bTypeOrder = TYPE_ORDER[bType] || 100;\n    if (aTypeOrder !== bTypeOrder) {\n        return aTypeOrder - bTypeOrder;\n    }\n    let result = partialCompare(a, b);\n    if (result === null) {\n        result = 0;\n    }\n    return result;\n}\nconst operators = {\n    \"==\": function eq(left, right) {\n        return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"!=\": function neq(left, right) {\n        return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n    },\n    \">\": function gt(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result > 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \">=\": function gte(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"<\": function lt(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result < 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"<=\": function lte(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    // eslint-disable-next-line func-name-matching\n    in: async function inop(left, right) {\n        if (right.type === \"path\") {\n            if (left.type !== \"string\") {\n                return NULL_VALUE;\n            }\n            return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;\n        }\n        if (right.isArray()) {\n            for await (const b of right){\n                if (isEqual(left, b)) {\n                    return TRUE_VALUE;\n                }\n            }\n            return FALSE_VALUE;\n        }\n        return NULL_VALUE;\n    },\n    match: async function match(left, right) {\n        let tokens = [];\n        let patterns = [];\n        await gatherText(left, (part)=>{\n            tokens = tokens.concat(matchTokenize(part));\n        });\n        const didSucceed = await gatherText(right, (part)=>{\n            patterns = patterns.concat(matchAnalyzePattern(part));\n        });\n        if (!didSucceed) {\n            return FALSE_VALUE;\n        }\n        const matched = matchText(tokens, patterns);\n        return matched ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"+\": function plus(left, right) {\n        if (left.type === \"datetime\" && right.type === \"number\") {\n            return fromDateTime(left.data.add(right.data));\n        }\n        if (left.type === \"number\" && right.type === \"number\") {\n            return fromNumber(left.data + right.data);\n        }\n        if (left.type === \"string\" && right.type === \"string\") {\n            return fromString(left.data + right.data);\n        }\n        if (left.type === \"object\" && right.type === \"object\") {\n            return fromJS({\n                ...left.data,\n                ...right.data\n            });\n        }\n        if (left.type === \"array\" && right.type === \"array\") {\n            return fromJS(left.data.concat(right.data));\n        }\n        if (left.isArray() && right.isArray()) {\n            return new StreamValue(async function*() {\n                for await (const val of left){\n                    yield val;\n                }\n                for await (const val of right){\n                    yield val;\n                }\n            });\n        }\n        return NULL_VALUE;\n    },\n    \"-\": function minus(left, right) {\n        if (left.type === \"datetime\" && right.type === \"number\") {\n            return fromDateTime(left.data.add(-right.data));\n        }\n        if (left.type === \"datetime\" && right.type === \"datetime\") {\n            return fromNumber(left.data.difference(right.data));\n        }\n        if (left.type === \"number\" && right.type === \"number\") {\n            return fromNumber(left.data - right.data);\n        }\n        return NULL_VALUE;\n    },\n    \"*\": numericOperator((a, b)=>a * b),\n    \"/\": numericOperator((a, b)=>a / b),\n    \"%\": numericOperator((a, b)=>a % b),\n    \"**\": numericOperator((a, b)=>Math.pow(a, b))\n};\nfunction numericOperator(impl) {\n    return function(left, right) {\n        if (left.type === \"number\" && right.type === \"number\") {\n            const result = impl(left.data, right.data);\n            return fromNumber(result);\n        }\n        return NULL_VALUE;\n    };\n}\nvar __defProp$2 = Object.defineProperty;\nvar __defNormalProp$2 = (obj, key, value)=>key in obj ? __defProp$2(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField$2 = (obj, key, value)=>{\n    __defNormalProp$2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nclass Scope {\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    constructor(params, source, value, context, parent){\n        __publicField$2(this, \"params\");\n        __publicField$2(this, \"source\");\n        __publicField$2(this, \"value\");\n        __publicField$2(this, \"parent\");\n        __publicField$2(this, \"context\");\n        __publicField$2(this, \"isHidden\", false);\n        this.params = params;\n        this.source = source;\n        this.value = value;\n        this.context = context;\n        this.parent = parent;\n    }\n    createNested(value) {\n        if (this.isHidden) {\n            return new Scope(this.params, this.source, value, this.context, this.parent);\n        }\n        return new Scope(this.params, this.source, value, this.context, this);\n    }\n    createHidden(value) {\n        const result = this.createNested(value);\n        result.isHidden = true;\n        return result;\n    }\n}\nfunction evaluate(node, scope) {\n    let execute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : evaluate;\n    const func = EXECUTORS[node.type];\n    return func(node, scope, execute);\n}\nfunction promiselessApply(value, cb) {\n    if (\"then\" in value) {\n        return value.then(cb);\n    }\n    return cb(value);\n}\nconst EXECUTORS = {\n    This (_, scope) {\n        return scope.value;\n    },\n    Selector () {\n        throw new Error(\"Selectors can not be evaluated\");\n    },\n    Everything (_, scope) {\n        return scope.source;\n    },\n    Parameter (_ref, scope) {\n        let { name } = _ref;\n        return fromJS(scope.params[name]);\n    },\n    Context (_ref2, scope) {\n        let { key } = _ref2;\n        if (key === \"before\" || key === \"after\") {\n            const value = scope.context[key];\n            return value || NULL_VALUE;\n        }\n        throw new Error(\"unknown context key: \".concat(key));\n    },\n    Parent (_ref3, scope) {\n        let { n } = _ref3;\n        let current = scope;\n        for(let i = 0; i < n; i++){\n            if (!current.parent) {\n                return NULL_VALUE;\n            }\n            current = current.parent;\n        }\n        return current.value;\n    },\n    OpCall (_ref4, scope, execute) {\n        let { op, left, right } = _ref4;\n        const func = operators[op];\n        if (!func) {\n            throw new Error(\"Unknown operator: \".concat(op));\n        }\n        const leftValue = execute(left, scope);\n        const rightValue = execute(right, scope);\n        if (\"then\" in leftValue || \"then\" in rightValue) {\n            return (async ()=>func(await leftValue, await rightValue))();\n        }\n        return func(leftValue, rightValue);\n    },\n    async Select (_ref5, scope, execute) {\n        let { alternatives, fallback } = _ref5;\n        for (const alt of alternatives){\n            const altCond = await execute(alt.condition, scope);\n            if (altCond.type === \"boolean\" && altCond.data === true) {\n                return execute(alt.value, scope);\n            }\n        }\n        if (fallback) {\n            return execute(fallback, scope);\n        }\n        return NULL_VALUE;\n    },\n    async InRange (_ref6, scope, execute) {\n        let { base, left, right, isInclusive } = _ref6;\n        const value = await execute(base, scope);\n        const leftValue = await execute(left, scope);\n        const rightValue = await execute(right, scope);\n        const leftCmp = partialCompare(await value.get(), await leftValue.get());\n        if (leftCmp === null) {\n            return NULL_VALUE;\n        }\n        const rightCmp = partialCompare(await value.get(), await rightValue.get());\n        if (rightCmp === null) {\n            return NULL_VALUE;\n        }\n        if (isInclusive) {\n            return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE;\n        }\n        return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    async Filter (_ref7, scope, execute) {\n        let { base, expr } = _ref7;\n        const baseValue = await execute(base, scope);\n        if (!baseValue.isArray()) {\n            return NULL_VALUE;\n        }\n        return new StreamValue(async function*() {\n            for await (const elem of baseValue){\n                const newScope = scope.createNested(elem);\n                const exprValue = await execute(expr, newScope);\n                if (exprValue.type === \"boolean\" && exprValue.data === true) {\n                    yield elem;\n                }\n            }\n        });\n    },\n    async Projection (_ref8, scope, execute) {\n        let { base, expr } = _ref8;\n        const baseValue = await execute(base, scope);\n        if (baseValue.type !== \"object\") {\n            return NULL_VALUE;\n        }\n        const newScope = scope.createNested(baseValue);\n        return execute(expr, newScope);\n    },\n    FuncCall (_ref9, scope, execute) {\n        let { func, args } = _ref9;\n        return func(args, scope, execute);\n    },\n    async PipeFuncCall (_ref10, scope, execute) {\n        let { func, base, args } = _ref10;\n        const baseValue = await execute(base, scope);\n        return func(baseValue, args, scope, execute);\n    },\n    async AccessAttribute (_ref11, scope, execute) {\n        let { base, name } = _ref11;\n        let value = scope.value;\n        if (base) {\n            value = await execute(base, scope);\n        }\n        if (value.type === \"object\") {\n            if (value.data.hasOwnProperty(name)) {\n                return fromJS(value.data[name]);\n            }\n        }\n        return NULL_VALUE;\n    },\n    async AccessElement (_ref12, scope, execute) {\n        let { base, index } = _ref12;\n        const baseValue = await execute(base, scope);\n        if (!baseValue.isArray()) {\n            return NULL_VALUE;\n        }\n        const data = await baseValue.get();\n        const finalIndex = index < 0 ? index + data.length : index;\n        return fromJS(data[finalIndex]);\n    },\n    async Slice (_ref13, scope, execute) {\n        let { base, left, right, isInclusive } = _ref13;\n        const baseValue = await execute(base, scope);\n        if (!baseValue.isArray()) {\n            return NULL_VALUE;\n        }\n        const array = await baseValue.get();\n        let leftIdx = left;\n        let rightIdx = right;\n        if (leftIdx < 0) {\n            leftIdx = array.length + leftIdx;\n        }\n        if (rightIdx < 0) {\n            rightIdx = array.length + rightIdx;\n        }\n        if (isInclusive) {\n            rightIdx++;\n        }\n        if (leftIdx < 0) {\n            leftIdx = 0;\n        }\n        if (rightIdx < 0) {\n            rightIdx = 0;\n        }\n        return fromJS(array.slice(leftIdx, rightIdx));\n    },\n    async Deref (_ref14, scope, execute) {\n        let { base } = _ref14;\n        const value = await execute(base, scope);\n        if (!scope.source.isArray()) {\n            return NULL_VALUE;\n        }\n        if (value.type !== \"object\") {\n            return NULL_VALUE;\n        }\n        const id = value.data._ref;\n        if (typeof id !== \"string\") {\n            return NULL_VALUE;\n        }\n        if (scope.context.dereference) {\n            return fromJS(await scope.context.dereference({\n                _ref: id\n            }));\n        }\n        for await (const doc of scope.source){\n            if (doc.type === \"object\" && id === doc.data._id) {\n                return doc;\n            }\n        }\n        return NULL_VALUE;\n    },\n    Value (_ref15) {\n        let { value } = _ref15;\n        return fromJS(value);\n    },\n    Group (_ref16, scope, execute) {\n        let { base } = _ref16;\n        return execute(base, scope);\n    },\n    async Object (_ref17, scope, execute) {\n        let { attributes } = _ref17;\n        const result = {};\n        for (const attr of attributes){\n            const attrType = attr.type;\n            switch(attr.type){\n                case \"ObjectAttributeValue\":\n                    {\n                        const value = await execute(attr.value, scope);\n                        result[attr.name] = await value.get();\n                        break;\n                    }\n                case \"ObjectConditionalSplat\":\n                    {\n                        const cond = await execute(attr.condition, scope);\n                        if (cond.type !== \"boolean\" || cond.data === false) {\n                            continue;\n                        }\n                        const value = await execute(attr.value, scope);\n                        if (value.type === \"object\") {\n                            Object.assign(result, value.data);\n                        }\n                        break;\n                    }\n                case \"ObjectSplat\":\n                    {\n                        const value = await execute(attr.value, scope);\n                        if (value.type === \"object\") {\n                            Object.assign(result, value.data);\n                        }\n                        break;\n                    }\n                default:\n                    throw new Error(\"Unknown node type: \".concat(attrType));\n            }\n        }\n        return fromJS(result);\n    },\n    Array (_ref18, scope, execute) {\n        let { elements } = _ref18;\n        return new StreamValue(async function*() {\n            for (const element of elements){\n                const value = await execute(element.value, scope);\n                if (element.isSplat) {\n                    if (value.isArray()) {\n                        for await (const v of value){\n                            yield v;\n                        }\n                    }\n                } else {\n                    yield value;\n                }\n            }\n        });\n    },\n    Tuple () {\n        throw new Error(\"tuples can not be evaluated\");\n    },\n    async Or (_ref19, scope, execute) {\n        let { left, right } = _ref19;\n        const leftValue = await execute(left, scope);\n        const rightValue = await execute(right, scope);\n        if (leftValue.type === \"boolean\") {\n            if (leftValue.data === true) {\n                return TRUE_VALUE;\n            }\n        }\n        if (rightValue.type === \"boolean\") {\n            if (rightValue.data === true) {\n                return TRUE_VALUE;\n            }\n        }\n        if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\n            return NULL_VALUE;\n        }\n        return FALSE_VALUE;\n    },\n    async And (_ref20, scope, execute) {\n        let { left, right } = _ref20;\n        const leftValue = await execute(left, scope);\n        const rightValue = await execute(right, scope);\n        if (leftValue.type === \"boolean\") {\n            if (leftValue.data === false) {\n                return FALSE_VALUE;\n            }\n        }\n        if (rightValue.type === \"boolean\") {\n            if (rightValue.data === false) {\n                return FALSE_VALUE;\n            }\n        }\n        if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\n            return NULL_VALUE;\n        }\n        return TRUE_VALUE;\n    },\n    async Not (_ref21, scope, execute) {\n        let { base } = _ref21;\n        const value = await execute(base, scope);\n        if (value.type !== \"boolean\") {\n            return NULL_VALUE;\n        }\n        return value.data ? FALSE_VALUE : TRUE_VALUE;\n    },\n    Neg (_ref22, scope, execute) {\n        let { base } = _ref22;\n        return promiselessApply(execute(base, scope), (value)=>{\n            if (value.type !== \"number\") {\n                return NULL_VALUE;\n            }\n            return fromNumber(-value.data);\n        });\n    },\n    Pos (_ref23, scope, execute) {\n        let { base } = _ref23;\n        return promiselessApply(execute(base, scope), (value)=>{\n            if (value.type !== \"number\") {\n                return NULL_VALUE;\n            }\n            return fromNumber(value.data);\n        });\n    },\n    Asc () {\n        return NULL_VALUE;\n    },\n    Desc () {\n        return NULL_VALUE;\n    },\n    async ArrayCoerce (_ref24, scope, execute) {\n        let { base } = _ref24;\n        const value = await execute(base, scope);\n        return value.isArray() ? value : NULL_VALUE;\n    },\n    async Map (_ref25, scope, execute) {\n        let { base, expr } = _ref25;\n        const value = await execute(base, scope);\n        if (!value.isArray()) {\n            return NULL_VALUE;\n        }\n        return new StreamValue(async function*() {\n            for await (const elem of value){\n                const newScope = scope.createHidden(elem);\n                yield await execute(expr, newScope);\n            }\n        });\n    },\n    async FlatMap (_ref26, scope, execute) {\n        let { base, expr } = _ref26;\n        const value = await execute(base, scope);\n        if (!value.isArray()) {\n            return NULL_VALUE;\n        }\n        return new StreamValue(async function*() {\n            for await (const elem of value){\n                const newScope = scope.createHidden(elem);\n                const innerValue = await execute(expr, newScope);\n                if (innerValue.isArray()) {\n                    for await (const inner of innerValue){\n                        yield inner;\n                    }\n                } else {\n                    yield innerValue;\n                }\n            }\n        });\n    }\n};\nfunction evaluateQuery(tree) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const root = fromJS(options.root);\n    const dataset = fromJS(options.dataset);\n    const params = {\n        ...options.params\n    };\n    const scope = new Scope(params, dataset, root, {\n        timestamp: options.timestamp || /* @__PURE__ */ new Date(),\n        identity: options.identity === void 0 ? \"me\" : options.identity,\n        sanity: options.sanity,\n        after: options.after ? fromJS(options.after) : null,\n        before: options.before ? fromJS(options.before) : null,\n        dereference: options.dereference\n    }, null);\n    return evaluate(tree, scope);\n}\nfunction canConstantEvaluate(node) {\n    switch(node.type){\n        case \"Group\":\n            return canConstantEvaluate(node.base);\n        case \"Value\":\n        case \"Parameter\":\n            return true;\n        case \"Pos\":\n        case \"Neg\":\n            return canConstantEvaluate(node.base);\n        case \"OpCall\":\n            switch(node.op){\n                case \"+\":\n                case \"-\":\n                case \"*\":\n                case \"/\":\n                case \"%\":\n                case \"**\":\n                    return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n                default:\n                    return false;\n            }\n        default:\n            return false;\n    }\n}\nconst DUMMY_SCOPE = new Scope({}, NULL_VALUE, NULL_VALUE, {\n    timestamp: /* @__PURE__ */ new Date(0),\n    identity: \"me\",\n    before: null,\n    after: null\n}, null);\nfunction tryConstantEvaluate(node) {\n    if (!canConstantEvaluate(node)) {\n        return null;\n    }\n    return constantEvaluate(node);\n}\nfunction constantEvaluate(node) {\n    const value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\n    if (\"then\" in value) {\n        throw new Error(\"BUG: constant evaluate should never return a promise\");\n    }\n    return value;\n}\nasync function portableTextContent(value) {\n    if (value.type === \"object\") {\n        return blockText(value.data);\n    } else if (value.isArray()) {\n        const texts = await arrayText(value);\n        if (texts.length > 0) {\n            return texts.join(\"\\n\\n\");\n        }\n    }\n    return null;\n}\nasync function arrayText(value) {\n    let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    for await (const block of value){\n        if (block.type === \"object\") {\n            const text = blockText(block.data);\n            if (text !== null) result.push(text);\n        } else if (block.isArray()) {\n            await arrayText(block, result);\n        }\n    }\n    return result;\n}\nfunction blockText(obj) {\n    if (typeof obj._type !== \"string\") return null;\n    const children = obj.children;\n    if (!Array.isArray(children)) return null;\n    let result = \"\";\n    for (const child of children){\n        if (child && typeof child === \"object\" && typeof child._type === \"string\" && child._type === \"span\" && typeof child.text === \"string\") {\n            result += child.text;\n        }\n    }\n    return result;\n}\nconst BM25k = 1.2;\nasync function evaluateScore(node, scope, execute) {\n    if (node.type === \"OpCall\" && node.op === \"match\") {\n        return evaluateMatchScore(node.left, node.right, scope, execute);\n    }\n    if (node.type === \"FuncCall\" && node.name === \"boost\") {\n        const innerScore = await evaluateScore(node.args[0], scope, execute);\n        const boost = await execute(node.args[1], scope);\n        if (boost.type === \"number\" && innerScore > 0) {\n            return innerScore + boost.data;\n        }\n        return 0;\n    }\n    switch(node.type){\n        case \"Or\":\n            {\n                const leftScore = await evaluateScore(node.left, scope, execute);\n                const rightScore = await evaluateScore(node.right, scope, execute);\n                return leftScore + rightScore;\n            }\n        case \"And\":\n            {\n                const leftScore = await evaluateScore(node.left, scope, execute);\n                const rightScore = await evaluateScore(node.right, scope, execute);\n                if (leftScore === 0 || rightScore === 0) return 0;\n                return leftScore + rightScore;\n            }\n        default:\n            {\n                const res = await execute(node, scope);\n                return res.type === \"boolean\" && res.data === true ? 1 : 0;\n            }\n    }\n}\nasync function evaluateMatchScore(left, right, scope, execute) {\n    const text = await execute(left, scope);\n    const pattern = await execute(right, scope);\n    let tokens = [];\n    let terms = [];\n    await gatherText(text, (part)=>{\n        tokens = tokens.concat(matchTokenize(part));\n    });\n    const didSucceed = await gatherText(pattern, (part)=>{\n        terms = terms.concat(matchPatternRegex(part));\n    });\n    if (!didSucceed) {\n        return 0;\n    }\n    if (tokens.length === 0 || terms.length === 0) {\n        return 0;\n    }\n    let score = 0;\n    for (const re of terms){\n        const freq = tokens.reduce((c, token)=>c + (re.test(token) ? 1 : 0), 0);\n        score += freq * (BM25k + 1) / (freq + BM25k);\n    }\n    return score;\n}\nfunction hasReference(value, pathSet) {\n    switch(getType(value)){\n        case \"array\":\n            for (const v of value){\n                if (hasReference(v, pathSet)) {\n                    return true;\n                }\n            }\n            break;\n        case \"object\":\n            if (value._ref) {\n                return pathSet.has(value._ref);\n            }\n            for (const v of Object.values(value)){\n                if (hasReference(v, pathSet)) {\n                    return true;\n                }\n            }\n            break;\n    }\n    return false;\n}\nfunction countUTF8(str) {\n    let count2 = 0;\n    for(let i = 0; i < str.length; i++){\n        const code = str.charCodeAt(i);\n        if (code >= 55296 && code <= 56319) {\n            continue;\n        }\n        count2++;\n    }\n    return count2;\n}\nconst _global = {};\n_global.anywhere = async function anywhere() {\n    throw new Error(\"not implemented\");\n};\n_global.anywhere.arity = 1;\n_global.coalesce = async function coalesce(args, scope, execute) {\n    for (const arg of args){\n        const value = await execute(arg, scope);\n        if (value.type !== \"null\") {\n            return value;\n        }\n    }\n    return NULL_VALUE;\n};\n_global.count = async function count(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    if (!inner.isArray()) {\n        return NULL_VALUE;\n    }\n    let num = 0;\n    for await (const _ of inner){\n        num++;\n    }\n    return fromNumber(num);\n};\n_global.count.arity = 1;\n_global.dateTime = async function dateTime(args, scope, execute) {\n    const val = await execute(args[0], scope);\n    if (val.type === \"datetime\") {\n        return val;\n    }\n    if (val.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    return DateTime.parseToValue(val.data);\n};\n_global.dateTime.arity = 1;\n_global.defined = async function defined(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    return inner.type === \"null\" ? FALSE_VALUE : TRUE_VALUE;\n};\n_global.defined.arity = 1;\n_global.identity = async function identity(args, scope) {\n    return fromString(scope.context.identity);\n};\n_global.identity.arity = 0;\n_global.length = async function length(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    if (inner.type === \"string\") {\n        return fromNumber(countUTF8(inner.data));\n    }\n    if (inner.isArray()) {\n        let num = 0;\n        for await (const _ of inner){\n            num++;\n        }\n        return fromNumber(num);\n    }\n    return NULL_VALUE;\n};\n_global.length.arity = 1;\n_global.path = async function path(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    if (inner.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    return fromPath(new Path(inner.data));\n};\n_global.path.arity = 1;\n_global.string = async function string(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    switch(value.type){\n        case \"number\":\n        case \"string\":\n        case \"boolean\":\n        case \"datetime\":\n            return fromString(\"\".concat(value.data));\n        default:\n            return NULL_VALUE;\n    }\n};\n_global.string.arity = 1;\n_global.references = async function references(args, scope, execute) {\n    const pathSet = /* @__PURE__ */ new Set();\n    for (const arg of args){\n        const path2 = await execute(arg, scope);\n        if (path2.type === \"string\") {\n            pathSet.add(path2.data);\n        } else if (path2.isArray()) {\n            for await (const elem of path2){\n                if (elem.type === \"string\") {\n                    pathSet.add(elem.data);\n                }\n            }\n        }\n    }\n    if (pathSet.size === 0) {\n        return FALSE_VALUE;\n    }\n    const scopeValue = await scope.value.get();\n    return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;\n};\n_global.references.arity = (c)=>c >= 1;\n_global.round = async function round(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    if (value.type !== \"number\") {\n        return NULL_VALUE;\n    }\n    const num = value.data;\n    let prec = 0;\n    if (args.length === 2) {\n        const precValue = await execute(args[1], scope);\n        if (precValue.type !== \"number\" || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n            return NULL_VALUE;\n        }\n        prec = precValue.data;\n    }\n    if (prec === 0) {\n        if (num < 0) {\n            return fromNumber(-Math.round(-num));\n        }\n        return fromNumber(Math.round(num));\n    }\n    return fromNumber(Number(num.toFixed(prec)));\n};\n_global.round.arity = (count2)=>count2 >= 1 && count2 <= 2;\n_global.now = async function now(args, scope) {\n    return fromString(scope.context.timestamp.toISOString());\n};\n_global.now.arity = 0;\n_global.boost = async function boost() {\n    throw new Error(\"unexpected boost call\");\n};\n_global.boost.arity = 2;\nconst string2 = {};\nstring2.lower = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    if (value.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    return fromString(value.data.toLowerCase());\n};\nstring2.lower.arity = 1;\nstring2.upper = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    if (value.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    return fromString(value.data.toUpperCase());\n};\nstring2.upper.arity = 1;\nstring2.split = async function(args, scope, execute) {\n    const str = await execute(args[0], scope);\n    if (str.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    const sep = await execute(args[1], scope);\n    if (sep.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    if (str.data.length === 0) {\n        return fromJS([]);\n    }\n    if (sep.data.length === 0) {\n        return fromJS(Array.from(str.data));\n    }\n    return fromJS(str.data.split(sep.data));\n};\nstring2.split.arity = 2;\n_global.lower = string2.lower;\n_global.upper = string2.upper;\nstring2.startsWith = async function(args, scope, execute) {\n    const str = await execute(args[0], scope);\n    if (str.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    const prefix = await execute(args[1], scope);\n    if (prefix.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    return str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE;\n};\nstring2.startsWith.arity = 2;\nconst array = {};\narray.join = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    const sep = await execute(args[1], scope);\n    if (sep.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    let buf = \"\";\n    let needSep = false;\n    for await (const elem of arr){\n        if (needSep) {\n            buf += sep.data;\n        }\n        switch(elem.type){\n            case \"number\":\n            case \"string\":\n            case \"boolean\":\n            case \"datetime\":\n                buf += \"\".concat(elem.data);\n                break;\n            default:\n                return NULL_VALUE;\n        }\n        needSep = true;\n    }\n    return fromJS(buf);\n};\narray.join.arity = 2;\narray.compact = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    return new StreamValue(async function*() {\n        for await (const elem of arr){\n            if (elem.type !== \"null\") {\n                yield elem;\n            }\n        }\n    });\n};\narray.compact.arity = 1;\narray.unique = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    if (!value.isArray()) {\n        return NULL_VALUE;\n    }\n    return new StreamValue(async function*() {\n        const added = /* @__PURE__ */ new Set();\n        for await (const iter of value){\n            switch(iter.type){\n                case \"number\":\n                case \"string\":\n                case \"boolean\":\n                case \"datetime\":\n                    if (!added.has(iter.data)) {\n                        added.add(iter.data);\n                        yield iter;\n                    }\n                    break;\n                default:\n                    yield iter;\n            }\n        }\n    });\n};\narray.unique.arity = 1;\nconst pt = {};\npt.text = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    const text = await portableTextContent(value);\n    if (text === null) {\n        return NULL_VALUE;\n    }\n    return fromString(text);\n};\npt.text.arity = 1;\nconst sanity = {};\nsanity.projectId = async function(args, scope) {\n    if (scope.context.sanity) {\n        return fromString(scope.context.sanity.projectId);\n    }\n    return NULL_VALUE;\n};\nsanity.dataset = async function(args, scope) {\n    if (scope.context.sanity) {\n        return fromString(scope.context.sanity.dataset);\n    }\n    return NULL_VALUE;\n};\nconst pipeFunctions = {};\npipeFunctions.order = async function order(base, args, scope, execute) {\n    await true;\n    if (!base.isArray()) {\n        return NULL_VALUE;\n    }\n    const mappers = [];\n    const directions = [];\n    let n = 0;\n    for (let mapper of args){\n        let direction = \"asc\";\n        if (mapper.type === \"Desc\") {\n            direction = \"desc\";\n            mapper = mapper.base;\n        } else if (mapper.type === \"Asc\") {\n            mapper = mapper.base;\n        }\n        mappers.push(mapper);\n        directions.push(direction);\n        n++;\n    }\n    const aux = [];\n    let idx = 0;\n    for await (const value of base){\n        const newScope = scope.createNested(value);\n        const tuple = [\n            await value.get(),\n            idx\n        ];\n        for(let i = 0; i < n; i++){\n            const result = await execute(mappers[i], newScope);\n            tuple.push(await result.get());\n        }\n        aux.push(tuple);\n        idx++;\n    }\n    aux.sort((aTuple, bTuple)=>{\n        for(let i = 0; i < n; i++){\n            let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n            if (directions[i] === \"desc\") {\n                c = -c;\n            }\n            if (c !== 0) {\n                return c;\n            }\n        }\n        return aTuple[1] - bTuple[1];\n    });\n    return fromJS(aux.map((v)=>v[0]));\n};\npipeFunctions.order.arity = (count2)=>count2 >= 1;\npipeFunctions.score = async function score(base, args, scope, execute) {\n    if (!base.isArray()) return NULL_VALUE;\n    const unknown = [];\n    const scored = [];\n    for await (const value of base){\n        if (value.type !== \"object\") {\n            unknown.push(await value.get());\n            continue;\n        }\n        const newScope = scope.createNested(value);\n        let valueScore = typeof value.data._score === \"number\" ? value.data._score : 0;\n        for (const arg of args){\n            valueScore += await evaluateScore(arg, newScope, execute);\n        }\n        const newObject = Object.assign({}, value.data, {\n            _score: valueScore\n        });\n        scored.push(newObject);\n    }\n    scored.sort((a, b)=>b._score - a._score);\n    return fromJS(scored);\n};\npipeFunctions.score.arity = (count2)=>count2 >= 1;\nconst delta = {};\ndelta.operation = async function(args, scope) {\n    const hasBefore = scope.context.before !== null;\n    const hasAfter = scope.context.after !== null;\n    if (hasBefore && hasAfter) {\n        return fromString(\"update\");\n    }\n    if (hasAfter) {\n        return fromString(\"create\");\n    }\n    if (hasBefore) {\n        return fromString(\"delete\");\n    }\n    return NULL_VALUE;\n};\ndelta.changedAny = ()=>{\n    throw new Error(\"not implemented\");\n};\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = \"delta\";\ndelta.changedOnly = ()=>{\n    throw new Error(\"not implemented\");\n};\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = \"delta\";\nconst diff = {};\ndiff.changedAny = ()=>{\n    throw new Error(\"not implemented\");\n};\ndiff.changedAny.arity = 3;\ndiff.changedOnly = ()=>{\n    throw new Error(\"not implemented\");\n};\ndiff.changedOnly.arity = 3;\nconst math = {};\nmath.min = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    let n;\n    for await (const elem of arr){\n        if (elem.type === \"null\") continue;\n        if (elem.type !== \"number\") {\n            return NULL_VALUE;\n        }\n        if (n === void 0 || elem.data < n) {\n            n = elem.data;\n        }\n    }\n    return fromJS(n);\n};\nmath.min.arity = 1;\nmath.max = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    let n;\n    for await (const elem of arr){\n        if (elem.type === \"null\") continue;\n        if (elem.type !== \"number\") {\n            return NULL_VALUE;\n        }\n        if (n === void 0 || elem.data > n) {\n            n = elem.data;\n        }\n    }\n    return fromJS(n);\n};\nmath.max.arity = 1;\nmath.sum = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    let n = 0;\n    for await (const elem of arr){\n        if (elem.type === \"null\") continue;\n        if (elem.type !== \"number\") {\n            return NULL_VALUE;\n        }\n        n += elem.data;\n    }\n    return fromJS(n);\n};\nmath.sum.arity = 1;\nmath.avg = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    let n = 0;\n    let c = 0;\n    for await (const elem of arr){\n        if (elem.type === \"null\") continue;\n        if (elem.type !== \"number\") {\n            return NULL_VALUE;\n        }\n        n += elem.data;\n        c++;\n    }\n    if (c === 0) {\n        return NULL_VALUE;\n    }\n    return fromJS(n / c);\n};\nmath.avg.arity = 1;\nconst dateTime2 = {};\ndateTime2.now = async function now2(args, scope, execute) {\n    return fromDateTime(new DateTime(scope.context.timestamp));\n};\ndateTime2.now.arity = 0;\nconst namespaces = {\n    global: _global,\n    string: string2,\n    array,\n    pt,\n    delta,\n    diff,\n    sanity,\n    math,\n    dateTime: dateTime2\n};\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value)=>key in obj ? __defProp$1(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value)=>{\n    __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nclass MarkProcessor {\n    constructor(string, marks, parseOptions){\n        __publicField$1(this, \"string\");\n        __publicField$1(this, \"marks\");\n        __publicField$1(this, \"index\");\n        __publicField$1(this, \"parseOptions\");\n        __publicField$1(this, \"allowBoost\", false);\n        this.string = string;\n        this.marks = marks;\n        this.index = 0;\n        this.parseOptions = parseOptions;\n    }\n    hasMark() {\n        let pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        return this.index + pos < this.marks.length;\n    }\n    getMark() {\n        let pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        return this.marks[this.index + pos];\n    }\n    shift() {\n        this.index += 1;\n    }\n    process(visitor) {\n        const mark = this.marks[this.index];\n        this.shift();\n        const func = visitor[mark.name];\n        if (!func) {\n            throw new Error(\"Unknown handler: \".concat(mark.name));\n        }\n        return func.call(visitor, this, mark);\n    }\n    processString() {\n        this.shift();\n        return this.processStringEnd();\n    }\n    processStringEnd() {\n        const prev = this.marks[this.index - 1];\n        const curr = this.marks[this.index];\n        this.shift();\n        return this.string.slice(prev.position, curr.position);\n    }\n    slice(len) {\n        const pos = this.marks[this.index].position;\n        return this.string.slice(pos, pos + len);\n    }\n}\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/;\nconst NUM = /^\\d+/;\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\nconst PREC_PAIR = 1;\nconst PREC_OR = 2;\nconst PREC_AND = 3;\nconst PREC_COMP = 4;\nconst PREC_ORDER = 4;\nconst PREC_ADD = 6;\nconst PREC_SUB = 6;\nconst PREC_MUL = 7;\nconst PREC_DIV = 7;\nconst PREC_MOD = 7;\nconst PREC_POW = 8;\nconst PREC_POS = 10;\nconst PREC_NOT = 10;\nconst PREC_NEG = 8;\nfunction parse$1(str) {\n    let pos = 0;\n    pos = skipWS(str, pos);\n    let result = parseExpr(str, pos, 0);\n    if (result.type === \"error\") return result;\n    pos = skipWS(str, result.position);\n    if (pos !== str.length) {\n        if (result.failPosition) {\n            pos = result.failPosition - 1;\n        }\n        return {\n            type: \"error\",\n            position: pos\n        };\n    }\n    delete result.position;\n    delete result.failPosition;\n    return result;\n}\nfunction parseExpr(str, pos, level) {\n    let startPos = pos;\n    let token = str[pos];\n    let marks;\n    switch(token){\n        case \"+\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"pos\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks);\n                pos = rhs.position;\n                break;\n            }\n        case \"-\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"neg\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks);\n                pos = rhs.position;\n                break;\n            }\n        case \"(\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n                if (rhs.type === \"error\") return rhs;\n                pos = skipWS(str, rhs.position);\n                switch(str[pos]){\n                    case \",\":\n                        {\n                            marks = [\n                                {\n                                    name: \"tuple\",\n                                    position: startPos\n                                }\n                            ].concat(rhs.marks);\n                            pos = skipWS(str, pos + 1);\n                            while(true){\n                                rhs = parseExpr(str, pos, 0);\n                                if (rhs.type === \"error\") return rhs;\n                                pos = skipWS(str, rhs.position);\n                                if (str[pos] !== \",\") break;\n                                pos = skipWS(str, pos + 1);\n                            }\n                            if (str[pos] !== \")\") return {\n                                type: \"error\",\n                                position: pos\n                            };\n                            pos++;\n                            marks.push({\n                                name: \"tuple_end\",\n                                position: pos\n                            });\n                            break;\n                        }\n                    case \")\":\n                        {\n                            pos++;\n                            marks = [\n                                {\n                                    name: \"group\",\n                                    position: startPos\n                                }\n                            ].concat(rhs.marks);\n                            break;\n                        }\n                    default:\n                        return {\n                            type: \"error\",\n                            position: pos\n                        };\n                }\n                break;\n            }\n        case \"!\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"not\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks);\n                pos = rhs.position;\n                break;\n            }\n        case \"{\":\n            {\n                let result = parseObject(str, pos);\n                if (result.type === \"error\") return result;\n                marks = result.marks;\n                pos = result.position;\n                break;\n            }\n        case \"[\":\n            marks = [\n                {\n                    name: \"array\",\n                    position: pos\n                }\n            ];\n            pos = skipWS(str, pos + 1);\n            if (str[pos] !== \"]\") {\n                while(true){\n                    if (str.slice(pos, pos + 3) === \"...\") {\n                        marks.push({\n                            name: \"array_splat\",\n                            position: pos\n                        });\n                        pos = skipWS(str, pos + 3);\n                    }\n                    let res = parseExpr(str, pos, 0);\n                    if (res.type === \"error\") return res;\n                    marks = marks.concat(res.marks);\n                    pos = res.position;\n                    pos = skipWS(str, pos);\n                    if (str[pos] !== \",\") break;\n                    pos = skipWS(str, pos + 1);\n                    if (str[pos] === \"]\") break;\n                }\n            }\n            if (str[pos] === \"]\") {\n                pos++;\n                marks.push({\n                    name: \"array_end\",\n                    position: pos\n                });\n            } else {\n                return {\n                    type: \"error\",\n                    position: pos\n                };\n            }\n            break;\n        case \"'\":\n        case '\"':\n            {\n                let result = parseString(str, pos);\n                if (result.type === \"error\") return result;\n                marks = result.marks;\n                pos = result.position;\n                break;\n            }\n        case \"^\":\n            {\n                pos++;\n                marks = [];\n                while(str[pos] === \".\" && str[pos + 1] === \"^\"){\n                    marks.push({\n                        name: \"dblparent\",\n                        position: startPos\n                    });\n                    pos += 2;\n                }\n                marks.push({\n                    name: \"parent\",\n                    position: startPos\n                });\n                break;\n            }\n        case \"@\":\n            marks = [\n                {\n                    name: \"this\",\n                    position: startPos\n                }\n            ];\n            pos++;\n            break;\n        case \"*\":\n            marks = [\n                {\n                    name: \"everything\",\n                    position: startPos\n                }\n            ];\n            pos++;\n            break;\n        case \"$\":\n            {\n                let identLen = parseRegex(str, pos + 1, IDENT);\n                if (identLen) {\n                    pos += 1 + identLen;\n                    marks = [\n                        {\n                            name: \"param\",\n                            position: startPos\n                        },\n                        {\n                            name: \"ident\",\n                            position: startPos + 1\n                        },\n                        {\n                            name: \"ident_end\",\n                            position: pos\n                        }\n                    ];\n                }\n                break;\n            }\n        default:\n            {\n                let numLen = parseRegex(str, pos, NUM);\n                if (numLen) {\n                    pos += numLen;\n                    let name = \"integer\";\n                    if (str[pos] === \".\") {\n                        let fracLen = parseRegex(str, pos + 1, NUM);\n                        if (fracLen) {\n                            name = \"float\";\n                            pos += 1 + fracLen;\n                        }\n                    }\n                    if (str[pos] === \"e\" || str[pos] === \"E\") {\n                        name = \"sci\";\n                        pos++;\n                        if (str[pos] === \"+\" || str[pos] === \"-\") {\n                            pos++;\n                        }\n                        let expLen = parseRegex(str, pos, NUM);\n                        if (!expLen) return {\n                            type: \"error\",\n                            position: pos\n                        };\n                        pos += expLen;\n                    }\n                    marks = [\n                        {\n                            name,\n                            position: startPos\n                        },\n                        {\n                            name: name + \"_end\",\n                            position: pos\n                        }\n                    ];\n                    break;\n                }\n                let identLen = parseRegex(str, pos, IDENT);\n                if (identLen) {\n                    pos += identLen;\n                    switch(str[pos]){\n                        case \":\":\n                        case \"(\":\n                            {\n                                let result = parseFuncCall(str, startPos, pos);\n                                if (result.type === \"error\") return result;\n                                marks = result.marks;\n                                pos = result.position;\n                                break;\n                            }\n                        default:\n                            {\n                                marks = [\n                                    {\n                                        name: \"this_attr\",\n                                        position: startPos\n                                    },\n                                    {\n                                        name: \"ident\",\n                                        position: startPos\n                                    },\n                                    {\n                                        name: \"ident_end\",\n                                        position: pos\n                                    }\n                                ];\n                            }\n                    }\n                    break;\n                }\n            }\n    }\n    if (!marks) {\n        return {\n            type: \"error\",\n            position: pos\n        };\n    }\n    let lhsLevel = 12;\n    let trav;\n    loop: while(true){\n        let innerPos = skipWS(str, pos);\n        if (innerPos === str.length) {\n            pos = innerPos;\n            break;\n        }\n        trav = parseTraversal(str, innerPos);\n        if (trav.type === \"success\") {\n            marks.unshift({\n                name: \"traverse\",\n                position: startPos\n            });\n            while(trav.type === \"success\"){\n                marks = marks.concat(trav.marks);\n                pos = trav.position;\n                trav = parseTraversal(str, skipWS(str, pos));\n            }\n            marks.push({\n                name: \"traversal_end\",\n                position: pos\n            });\n            continue;\n        }\n        let token2 = str[innerPos];\n        switch(token2){\n            case \"=\":\n                {\n                    let nextToken = str[innerPos + 1];\n                    switch(nextToken){\n                        case \">\":\n                            {\n                                if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop;\n                                let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR);\n                                if (rhs.type === \"error\") return rhs;\n                                marks = marks.concat(rhs.marks);\n                                marks.unshift({\n                                    name: \"pair\",\n                                    position: startPos\n                                });\n                                pos = rhs.position;\n                                lhsLevel = PREC_PAIR;\n                                break;\n                            }\n                        case \"=\":\n                            {\n                                if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                                let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\n                                if (rhs.type === \"error\") return rhs;\n                                marks.unshift({\n                                    name: \"comp\",\n                                    position: startPos\n                                });\n                                marks.push({\n                                    name: \"op\",\n                                    position: innerPos\n                                }, {\n                                    name: \"op_end\",\n                                    position: innerPos + 2\n                                });\n                                marks = marks.concat(rhs.marks);\n                                pos = rhs.position;\n                                lhsLevel = PREC_COMP;\n                                break;\n                            }\n                        default:\n                            break loop;\n                    }\n                    break;\n                }\n            case \"+\":\n                {\n                    if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"add\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_ADD;\n                    break;\n                }\n            case \"-\":\n                {\n                    if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"sub\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_SUB;\n                    break;\n                }\n            case \"*\":\n                {\n                    if (str[innerPos + 1] === \"*\") {\n                        if (level > PREC_POW || lhsLevel <= PREC_POW) break loop;\n                        let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW);\n                        if (rhs2.type === \"error\") return rhs2;\n                        marks = marks.concat(rhs2.marks);\n                        marks.unshift({\n                            name: \"pow\",\n                            position: startPos\n                        });\n                        pos = rhs2.position;\n                        lhsLevel = PREC_POW;\n                        break;\n                    }\n                    if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"mul\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_MUL;\n                    break;\n                }\n            case \"/\":\n                {\n                    if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"div\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_DIV;\n                    break;\n                }\n            case \"%\":\n                {\n                    if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"mod\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_MOD;\n                    break;\n                }\n            case \"<\":\n            case \">\":\n                {\n                    if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                    let nextPos = innerPos + 1;\n                    if (str[nextPos] === \"=\") {\n                        nextPos++;\n                    }\n                    let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks.unshift({\n                        name: \"comp\",\n                        position: startPos\n                    });\n                    marks.push({\n                        name: \"op\",\n                        position: innerPos\n                    }, {\n                        name: \"op_end\",\n                        position: nextPos\n                    });\n                    marks = marks.concat(rhs.marks);\n                    pos = rhs.position;\n                    lhsLevel = PREC_COMP;\n                    break;\n                }\n            case \"|\":\n                {\n                    if (str[innerPos + 1] === \"|\") {\n                        if (level > PREC_OR || lhsLevel < PREC_OR) break loop;\n                        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1);\n                        if (rhs.type === \"error\") return rhs;\n                        marks = marks.concat(rhs.marks);\n                        marks.unshift({\n                            name: \"or\",\n                            position: startPos\n                        });\n                        pos = rhs.position;\n                        lhsLevel = PREC_OR;\n                    } else {\n                        if (level > 11 || lhsLevel < 11) break loop;\n                        let identPos = skipWS(str, innerPos + 1);\n                        let identLen = parseRegex(str, identPos, IDENT);\n                        if (!identLen) return {\n                            type: \"error\",\n                            position: identPos\n                        };\n                        pos = identPos + identLen;\n                        if (str[pos] === \"(\" || str[pos] === \":\") {\n                            let result = parseFuncCall(str, identPos, pos);\n                            if (result.type === \"error\") return result;\n                            marks = marks.concat(result.marks);\n                            marks.unshift({\n                                name: \"pipecall\",\n                                position: startPos\n                            });\n                            pos = result.position;\n                            lhsLevel = 11;\n                        }\n                    }\n                    break;\n                }\n            case \"&\":\n                {\n                    if (str[innerPos + 1] != \"&\") break loop;\n                    if (level > PREC_AND || lhsLevel < PREC_AND) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"and\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_AND;\n                    break;\n                }\n            case \"!\":\n                {\n                    if (str[innerPos + 1] !== \"=\") break loop;\n                    if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks.unshift({\n                        name: \"comp\",\n                        position: startPos\n                    });\n                    marks.push({\n                        name: \"op\",\n                        position: innerPos\n                    }, {\n                        name: \"op_end\",\n                        position: innerPos + 2\n                    });\n                    marks = marks.concat(rhs.marks);\n                    pos = rhs.position;\n                    lhsLevel = PREC_COMP;\n                    break;\n                }\n            case \"d\":\n                {\n                    if (str.slice(innerPos, innerPos + 4) !== \"desc\") break loop;\n                    if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop;\n                    marks.unshift({\n                        name: \"desc\",\n                        position: startPos\n                    });\n                    pos = innerPos + 4;\n                    lhsLevel = PREC_ORDER;\n                    break;\n                }\n            case \"a\":\n                {\n                    if (str.slice(innerPos, innerPos + 3) !== \"asc\") break loop;\n                    if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop;\n                    marks.unshift({\n                        name: \"asc\",\n                        position: startPos\n                    });\n                    pos = innerPos + 3;\n                    lhsLevel = PREC_ORDER;\n                    break;\n                }\n            default:\n                {\n                    let ident = parseRegexStr(str, innerPos, IDENT);\n                    switch(ident){\n                        case \"in\":\n                            {\n                                if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                                pos = skipWS(str, innerPos + 2);\n                                let isGroup = false;\n                                if (str[pos] === \"(\") {\n                                    isGroup = true;\n                                    pos = skipWS(str, pos + 1);\n                                }\n                                let rangePos = pos;\n                                let result = parseExpr(str, pos, PREC_COMP + 1);\n                                if (result.type === \"error\") return result;\n                                pos = skipWS(str, result.position);\n                                if (str[pos] === \".\" && str[pos + 1] === \".\") {\n                                    let type = \"inc_range\";\n                                    if (str[pos + 2] === \".\") {\n                                        type = \"exc_range\";\n                                        pos = skipWS(str, pos + 3);\n                                    } else {\n                                        pos = skipWS(str, pos + 2);\n                                    }\n                                    let rhs = parseExpr(str, pos, PREC_COMP + 1);\n                                    if (rhs.type === \"error\") return rhs;\n                                    marks.unshift({\n                                        name: \"in_range\",\n                                        position: startPos\n                                    });\n                                    marks = marks.concat({\n                                        name: type,\n                                        position: rangePos\n                                    }, result.marks, rhs.marks);\n                                    pos = rhs.position;\n                                } else {\n                                    marks.unshift({\n                                        name: \"comp\",\n                                        position: startPos\n                                    });\n                                    marks.push({\n                                        name: \"op\",\n                                        position: innerPos\n                                    }, {\n                                        name: \"op_end\",\n                                        position: innerPos + 2\n                                    });\n                                    marks = marks.concat(result.marks);\n                                }\n                                if (isGroup) {\n                                    pos = skipWS(str, pos);\n                                    if (str[pos] !== \")\") return {\n                                        type: \"error\",\n                                        position: pos\n                                    };\n                                    pos++;\n                                }\n                                lhsLevel = PREC_COMP;\n                                break;\n                            }\n                        case \"match\":\n                            {\n                                if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                                let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1);\n                                if (rhs.type === \"error\") return rhs;\n                                marks.unshift({\n                                    name: \"comp\",\n                                    position: startPos\n                                });\n                                marks.push({\n                                    name: \"op\",\n                                    position: innerPos\n                                }, {\n                                    name: \"op_end\",\n                                    position: innerPos + 5\n                                });\n                                marks = marks.concat(rhs.marks);\n                                pos = rhs.position;\n                                lhsLevel = 4;\n                                break;\n                            }\n                        default:\n                            {\n                                break loop;\n                            }\n                    }\n                }\n        }\n    }\n    let failPosition = (trav == null ? void 0 : trav.type) === \"error\" && trav.position;\n    return {\n        type: \"success\",\n        marks,\n        position: pos,\n        failPosition\n    };\n}\nfunction parseTraversal(str, pos) {\n    let startPos = pos;\n    switch(str[pos]){\n        case \".\":\n            {\n                pos = skipWS(str, pos + 1);\n                let identStart = pos;\n                let identLen2 = parseRegex(str, pos, IDENT);\n                if (!identLen2) return {\n                    type: \"error\",\n                    position: pos\n                };\n                pos += identLen2;\n                return {\n                    type: \"success\",\n                    marks: [\n                        {\n                            name: \"attr_access\",\n                            position: startPos\n                        },\n                        {\n                            name: \"ident\",\n                            position: identStart\n                        },\n                        {\n                            name: \"ident_end\",\n                            position: pos\n                        }\n                    ],\n                    position: pos\n                };\n            }\n        case \"-\":\n            if (str[pos + 1] !== \">\") return {\n                type: \"error\",\n                position: pos\n            };\n            let marks = [\n                {\n                    name: \"deref\",\n                    position: startPos\n                }\n            ];\n            pos += 2;\n            let identPos = skipWS(str, pos);\n            let identLen = parseRegex(str, identPos, IDENT);\n            if (identLen) {\n                pos = identPos + identLen;\n                marks.push({\n                    name: \"deref_attr\",\n                    position: identPos\n                }, {\n                    name: \"ident\",\n                    position: identPos\n                }, {\n                    name: \"ident_end\",\n                    position: pos\n                });\n            }\n            return {\n                type: \"success\",\n                marks,\n                position: pos\n            };\n        case \"[\":\n            {\n                pos = skipWS(str, pos + 1);\n                if (str[pos] === \"]\") {\n                    return {\n                        type: \"success\",\n                        marks: [\n                            {\n                                name: \"array_postfix\",\n                                position: startPos\n                            }\n                        ],\n                        position: pos + 1\n                    };\n                }\n                let rangePos = pos;\n                let result = parseExpr(str, pos, 0);\n                if (result.type === \"error\") return result;\n                pos = skipWS(str, result.position);\n                if (str[pos] === \".\" && str[pos + 1] === \".\") {\n                    let type = \"inc_range\";\n                    if (str[pos + 2] === \".\") {\n                        type = \"exc_range\";\n                        pos += 3;\n                    } else {\n                        pos += 2;\n                    }\n                    pos = skipWS(str, pos);\n                    let rhs = parseExpr(str, pos, 0);\n                    if (rhs.type === \"error\") return rhs;\n                    pos = skipWS(str, rhs.position);\n                    if (str[pos] !== \"]\") return {\n                        type: \"error\",\n                        position: pos\n                    };\n                    return {\n                        type: \"success\",\n                        marks: [\n                            {\n                                name: \"slice\",\n                                position: startPos\n                            },\n                            {\n                                name: type,\n                                position: rangePos\n                            }\n                        ].concat(result.marks, rhs.marks),\n                        position: pos + 1\n                    };\n                }\n                if (str[pos] !== \"]\") return {\n                    type: \"error\",\n                    position: pos\n                };\n                return {\n                    type: \"success\",\n                    marks: [\n                        {\n                            name: \"square_bracket\",\n                            position: startPos\n                        }\n                    ].concat(result.marks),\n                    position: pos + 1\n                };\n            }\n        case \"|\":\n            {\n                pos = skipWS(str, pos + 1);\n                if (str[pos] === \"{\") {\n                    let result = parseObject(str, pos);\n                    if (result.type === \"error\") return result;\n                    result.marks.unshift({\n                        name: \"projection\",\n                        position: startPos\n                    });\n                    return result;\n                }\n                break;\n            }\n        case \"{\":\n            {\n                let result = parseObject(str, pos);\n                if (result.type === \"error\") return result;\n                result.marks.unshift({\n                    name: \"projection\",\n                    position: startPos\n                });\n                return result;\n            }\n    }\n    return {\n        type: \"error\",\n        position: pos\n    };\n}\nfunction parseFuncCall(str, startPos, pos) {\n    let marks = [];\n    marks.push({\n        name: \"func_call\",\n        position: startPos\n    });\n    if (str[pos] === \":\" && str[pos + 1] === \":\") {\n        marks.push({\n            name: \"namespace\",\n            position: startPos\n        });\n        marks.push({\n            name: \"ident\",\n            position: startPos\n        }, {\n            name: \"ident_end\",\n            position: pos\n        });\n        pos = skipWS(str, pos + 2);\n        let nameLen = parseRegex(str, pos, IDENT);\n        if (!nameLen) return {\n            type: \"error\",\n            position: pos\n        };\n        marks.push({\n            name: \"ident\",\n            position: pos\n        }, {\n            name: \"ident_end\",\n            position: pos + nameLen\n        });\n        pos = skipWS(str, pos + nameLen);\n        if (str[pos] !== \"(\") return {\n            type: \"error\",\n            position: pos\n        };\n        pos++;\n        pos = skipWS(str, pos);\n    } else {\n        marks.push({\n            name: \"ident\",\n            position: startPos\n        }, {\n            name: \"ident_end\",\n            position: pos\n        });\n        pos = skipWS(str, pos + 1);\n    }\n    let lastPos = pos;\n    if (str[pos] !== \")\") {\n        while(true){\n            let result = parseExpr(str, pos, 0);\n            if (result.type === \"error\") return result;\n            marks = marks.concat(result.marks);\n            lastPos = result.position;\n            pos = skipWS(str, result.position);\n            if (str[pos] !== \",\") break;\n            pos = skipWS(str, pos + 1);\n            if (str[pos] === \")\") break;\n        }\n    }\n    if (str[pos] !== \")\") {\n        return {\n            type: \"error\",\n            position: pos\n        };\n    }\n    marks.push({\n        name: \"func_args_end\",\n        position: lastPos\n    });\n    return {\n        type: \"success\",\n        marks,\n        position: pos + 1\n    };\n}\nfunction parseObject(str, pos) {\n    let marks = [\n        {\n            name: \"object\",\n            position: pos\n        }\n    ];\n    pos = skipWS(str, pos + 1);\n    while(str[pos] !== \"}\"){\n        let pairPos = pos;\n        if (str.slice(pos, pos + 3) === \"...\") {\n            pos = skipWS(str, pos + 3);\n            if (str[pos] !== \"}\" && str[pos] !== \",\") {\n                let expr = parseExpr(str, pos, 0);\n                if (expr.type === \"error\") return expr;\n                marks.push({\n                    name: \"object_splat\",\n                    position: pairPos\n                });\n                marks = marks.concat(expr.marks);\n                pos = expr.position;\n            } else {\n                marks.push({\n                    name: \"object_splat_this\",\n                    position: pairPos\n                });\n            }\n        } else {\n            let expr = parseExpr(str, pos, 0);\n            if (expr.type === \"error\") return expr;\n            let nextPos = skipWS(str, expr.position);\n            if (expr.marks[0].name === \"str\" && str[nextPos] === \":\") {\n                let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n                if (value.type === \"error\") return value;\n                marks.push({\n                    name: \"object_pair\",\n                    position: pairPos\n                });\n                marks = marks.concat(expr.marks, value.marks);\n                pos = value.position;\n            } else {\n                marks = marks.concat({\n                    name: \"object_expr\",\n                    position: pos\n                }, expr.marks);\n                pos = expr.position;\n            }\n        }\n        pos = skipWS(str, pos);\n        if (str[pos] !== \",\") break;\n        pos = skipWS(str, pos + 1);\n    }\n    if (str[pos] !== \"}\") {\n        return {\n            type: \"error\",\n            position: pos\n        };\n    }\n    pos++;\n    marks.push({\n        name: \"object_end\",\n        position: pos\n    });\n    return {\n        type: \"success\",\n        marks,\n        position: pos\n    };\n}\nfunction parseString(str, pos) {\n    let token = str[pos];\n    pos = pos + 1;\n    const marks = [\n        {\n            name: \"str\",\n            position: pos\n        }\n    ];\n    str: for(;; pos++){\n        if (pos > str.length) return {\n            type: \"error\",\n            position: pos\n        };\n        switch(str[pos]){\n            case token:\n                {\n                    marks.push({\n                        name: \"str_end\",\n                        position: pos\n                    });\n                    pos++;\n                    break str;\n                }\n            case \"\\\\\":\n                {\n                    marks.push({\n                        name: \"str_pause\",\n                        position: pos\n                    });\n                    if (str[pos + 1] === \"u\") {\n                        if (str[pos + 2] === \"{\") {\n                            marks.push({\n                                name: \"unicode_hex\",\n                                position: pos + 3\n                            });\n                            pos = str.indexOf(\"}\", pos + 3);\n                            marks.push({\n                                name: \"unicode_hex_end\",\n                                position: pos\n                            });\n                        } else {\n                            marks.push({\n                                name: \"unicode_hex\",\n                                position: pos + 2\n                            });\n                            marks.push({\n                                name: \"unicode_hex_end\",\n                                position: pos + 6\n                            });\n                            pos += 5;\n                        }\n                    } else {\n                        marks.push({\n                            name: \"single_escape\",\n                            position: pos + 1\n                        });\n                        pos += 1;\n                    }\n                    marks.push({\n                        name: \"str_start\",\n                        position: pos + 1\n                    });\n                }\n        }\n    }\n    return {\n        type: \"success\",\n        marks,\n        position: pos\n    };\n}\nfunction skipWS(str, pos) {\n    return pos + parseRegex(str, pos, WS);\n}\nfunction parseRegex(str, pos, re) {\n    let m = re.exec(str.slice(pos));\n    return m ? m[0].length : 0;\n}\nfunction parseRegexStr(str, pos, re) {\n    let m = re.exec(str.slice(pos));\n    return m ? m[0] : null;\n}\nfunction join(a, b) {\n    return (base)=>b(a(base));\n}\nfunction map(inner) {\n    return (base)=>({\n            type: \"Map\",\n            base,\n            expr: inner({\n                type: \"This\"\n            })\n        });\n}\nfunction flatMap(inner) {\n    return (base)=>({\n            type: \"FlatMap\",\n            base,\n            expr: inner({\n                type: \"This\"\n            })\n        });\n}\nfunction traverseArray(build, right) {\n    if (!right) {\n        return {\n            type: \"a-a\",\n            build\n        };\n    }\n    switch(right.type){\n        case \"a-a\":\n            return {\n                type: \"a-a\",\n                build: join(build, right.build)\n            };\n        case \"a-b\":\n            return {\n                type: \"a-b\",\n                build: join(build, right.build)\n            };\n        case \"b-b\":\n            return {\n                type: \"a-a\",\n                build: join(build, map(right.build))\n            };\n        case \"b-a\":\n            return {\n                type: \"a-a\",\n                build: join(build, flatMap(right.build))\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traversePlain(mapper, right) {\n    if (!right) {\n        return {\n            type: \"b-b\",\n            build: mapper\n        };\n    }\n    switch(right.type){\n        case \"a-a\":\n        case \"b-a\":\n            return {\n                type: \"b-a\",\n                build: join(mapper, right.build)\n            };\n        case \"a-b\":\n        case \"b-b\":\n            return {\n                type: \"b-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traverseElement(mapper, right) {\n    if (!right) {\n        return {\n            type: \"a-b\",\n            build: mapper\n        };\n    }\n    switch(right.type){\n        case \"a-a\":\n        case \"b-a\":\n            return {\n                type: \"a-a\",\n                build: join(mapper, right.build)\n            };\n        case \"a-b\":\n        case \"b-b\":\n            return {\n                type: \"a-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traverseProjection(mapper, right) {\n    if (!right) {\n        return {\n            type: \"b-b\",\n            build: mapper\n        };\n    }\n    switch(right.type){\n        case \"a-a\":\n            return {\n                type: \"a-a\",\n                build: join(map(mapper), right.build)\n            };\n        case \"a-b\":\n            return {\n                type: \"a-b\",\n                build: join(map(mapper), right.build)\n            };\n        case \"b-a\":\n            return {\n                type: \"b-a\",\n                build: join(mapper, right.build)\n            };\n        case \"b-b\":\n            return {\n                type: \"b-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>{\n    __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nconst ESCAPE_SEQUENCE = {\n    \"'\": \"'\",\n    '\"': '\"',\n    \"\\\\\": \"\\\\\",\n    \"/\": \"/\",\n    b: \"\\b\",\n    f: \"\\f\",\n    n: \"\\n\",\n    r: \"\\r\",\n    t: \"\t\"\n};\nfunction expandHex(str) {\n    const charCode = parseInt(str, 16);\n    return String.fromCharCode(charCode);\n}\nclass GroqQueryError extends Error {\n    constructor(){\n        super(...arguments);\n        __publicField(this, \"name\", \"GroqQueryError\");\n    }\n}\nconst EXPR_BUILDER = {\n    group (p) {\n        const inner = p.process(EXPR_BUILDER);\n        return {\n            type: \"Group\",\n            base: inner\n        };\n    },\n    everything () {\n        return {\n            type: \"Everything\"\n        };\n    },\n    this () {\n        return {\n            type: \"This\"\n        };\n    },\n    parent () {\n        return {\n            type: \"Parent\",\n            n: 1\n        };\n    },\n    dblparent (p) {\n        const next = p.process(EXPR_BUILDER);\n        return {\n            type: \"Parent\",\n            n: next.n + 1\n        };\n    },\n    traverse (p) {\n        const base = p.process(EXPR_BUILDER);\n        const traversalList = [];\n        while(p.getMark().name !== \"traversal_end\"){\n            traversalList.push(p.process(TRAVERSE_BUILDER));\n        }\n        p.shift();\n        let traversal = null;\n        for(let i = traversalList.length - 1; i >= 0; i--){\n            traversal = traversalList[i](traversal);\n        }\n        if (base.type === \"Everything\" || base.type === \"Array\" || base.type === \"PipeFuncCall\") {\n            traversal = traverseArray((val)=>val, traversal);\n        }\n        if (traversal === null) throw new Error(\"BUG: unexpected empty traversal\");\n        return traversal.build(base);\n    },\n    this_attr (p) {\n        const name = p.processString();\n        if (name === \"null\") {\n            return {\n                type: \"Value\",\n                value: null\n            };\n        }\n        if (name === \"true\") {\n            return {\n                type: \"Value\",\n                value: true\n            };\n        }\n        if (name === \"false\") {\n            return {\n                type: \"Value\",\n                value: false\n            };\n        }\n        return {\n            type: \"AccessAttribute\",\n            name\n        };\n    },\n    neg (p) {\n        const base = p.process(EXPR_BUILDER);\n        return {\n            type: \"Neg\",\n            base\n        };\n    },\n    pos (p) {\n        const base = p.process(EXPR_BUILDER);\n        return {\n            type: \"Pos\",\n            base\n        };\n    },\n    add (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"+\",\n            left,\n            right\n        };\n    },\n    sub (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"-\",\n            left,\n            right\n        };\n    },\n    mul (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"*\",\n            left,\n            right\n        };\n    },\n    div (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"/\",\n            left,\n            right\n        };\n    },\n    mod (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"%\",\n            left,\n            right\n        };\n    },\n    pow (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"**\",\n            left,\n            right\n        };\n    },\n    comp (p) {\n        const left = p.process(EXPR_BUILDER);\n        const op = p.processString();\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op,\n            left,\n            right\n        };\n    },\n    in_range (p) {\n        const base = p.process(EXPR_BUILDER);\n        const isInclusive = p.getMark().name === \"inc_range\";\n        p.shift();\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"InRange\",\n            base,\n            left,\n            right,\n            isInclusive\n        };\n    },\n    str (p) {\n        let value = \"\";\n        loop: while(p.hasMark()){\n            const mark = p.getMark();\n            switch(mark.name){\n                case \"str_end\":\n                    value += p.processStringEnd();\n                    break loop;\n                case \"str_pause\":\n                    value += p.processStringEnd();\n                    break;\n                case \"str_start\":\n                    p.shift();\n                    break;\n                case \"single_escape\":\n                    {\n                        const char = p.slice(1);\n                        p.shift();\n                        value += ESCAPE_SEQUENCE[char];\n                        break;\n                    }\n                case \"unicode_hex\":\n                    p.shift();\n                    value += expandHex(p.processStringEnd());\n                    break;\n                default:\n                    throw new Error(\"unexpected mark: \".concat(mark.name));\n            }\n        }\n        return {\n            type: \"Value\",\n            value\n        };\n    },\n    integer (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    float (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    sci (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    object (p) {\n        const attributes = [];\n        while(p.getMark().name !== \"object_end\"){\n            attributes.push(p.process(OBJECT_BUILDER));\n        }\n        p.shift();\n        return {\n            type: \"Object\",\n            attributes\n        };\n    },\n    array (p) {\n        const elements = [];\n        while(p.getMark().name !== \"array_end\"){\n            let isSplat = false;\n            if (p.getMark().name === \"array_splat\") {\n                isSplat = true;\n                p.shift();\n            }\n            const value = p.process(EXPR_BUILDER);\n            elements.push({\n                type: \"ArrayElement\",\n                value,\n                isSplat\n            });\n        }\n        p.shift();\n        return {\n            type: \"Array\",\n            elements\n        };\n    },\n    tuple (p) {\n        const members = [];\n        while(p.getMark().name !== \"tuple_end\"){\n            members.push(p.process(EXPR_BUILDER));\n        }\n        p.shift();\n        return {\n            type: \"Tuple\",\n            members\n        };\n    },\n    func_call (p) {\n        let namespace = \"global\";\n        if (p.getMark().name === \"namespace\") {\n            p.shift();\n            namespace = p.processString();\n        }\n        const name = p.processString();\n        if (namespace === \"global\" && name === \"select\") {\n            const result = {\n                type: \"Select\",\n                alternatives: []\n            };\n            while(p.getMark().name !== \"func_args_end\"){\n                if (p.getMark().name === \"pair\") {\n                    if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n                    p.shift();\n                    const condition = p.process(EXPR_BUILDER);\n                    const value = p.process(EXPR_BUILDER);\n                    result.alternatives.push({\n                        type: \"SelectAlternative\",\n                        condition,\n                        value\n                    });\n                } else {\n                    if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n                    const value = p.process(EXPR_BUILDER);\n                    result.fallback = value;\n                }\n            }\n            p.shift();\n            return result;\n        }\n        const args = [];\n        while(p.getMark().name !== \"func_args_end\"){\n            if (argumentShouldBeSelector(namespace, name, args.length)) {\n                p.process(SELECTOR_BUILDER);\n                args.push({\n                    type: \"Selector\"\n                });\n            } else {\n                args.push(p.process(EXPR_BUILDER));\n            }\n        }\n        p.shift();\n        if (namespace === \"global\" && (name === \"before\" || name === \"after\")) {\n            if (p.parseOptions.mode === \"delta\") {\n                return {\n                    type: \"Context\",\n                    key: name\n                };\n            }\n        }\n        if (namespace === \"global\" && name === \"boost\" && !p.allowBoost) throw new GroqQueryError(\"unexpected boost\");\n        const funcs = namespaces[namespace];\n        if (!funcs) {\n            throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n        }\n        const func = funcs[name];\n        if (!func) {\n            throw new GroqQueryError(\"Undefined function: \".concat(name));\n        }\n        if (func.arity !== void 0) {\n            validateArity(name, func.arity, args.length);\n        }\n        if (func.mode !== void 0 && func.mode !== p.parseOptions.mode) {\n            throw new GroqQueryError(\"Undefined function: \".concat(name));\n        }\n        return {\n            type: \"FuncCall\",\n            func,\n            namespace,\n            name,\n            args\n        };\n    },\n    pipecall (p) {\n        const base = p.process(EXPR_BUILDER);\n        p.shift();\n        let namespace = \"global\";\n        if (p.getMark().name === \"namespace\") {\n            p.shift();\n            namespace = p.processString();\n        }\n        if (namespace !== \"global\") {\n            throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n        }\n        const name = p.processString();\n        const args = [];\n        const oldAllowBoost = p.allowBoost;\n        if (name === \"score\") {\n            p.allowBoost = true;\n        }\n        for(;;){\n            const markName = p.getMark().name;\n            if (markName === \"func_args_end\") {\n                break;\n            }\n            if (name === \"order\") {\n                if (markName === \"asc\") {\n                    p.shift();\n                    args.push({\n                        type: \"Asc\",\n                        base: p.process(EXPR_BUILDER)\n                    });\n                    continue;\n                } else if (markName === \"desc\") {\n                    p.shift();\n                    args.push({\n                        type: \"Desc\",\n                        base: p.process(EXPR_BUILDER)\n                    });\n                    continue;\n                }\n            }\n            args.push(p.process(EXPR_BUILDER));\n        }\n        p.shift();\n        p.allowBoost = oldAllowBoost;\n        const func = pipeFunctions[name];\n        if (!func) {\n            throw new GroqQueryError(\"Undefined pipe function: \".concat(name));\n        }\n        if (func.arity) {\n            validateArity(name, func.arity, args.length);\n        }\n        return {\n            type: \"PipeFuncCall\",\n            func,\n            base,\n            name,\n            args\n        };\n    },\n    pair (p) {\n        throw new GroqQueryError(\"unexpected =>\");\n    },\n    and (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"And\",\n            left,\n            right\n        };\n    },\n    or (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"Or\",\n            left,\n            right\n        };\n    },\n    not (p) {\n        const base = p.process(EXPR_BUILDER);\n        return {\n            type: \"Not\",\n            base\n        };\n    },\n    asc (p) {\n        throw new GroqQueryError(\"unexpected asc\");\n    },\n    desc (p) {\n        throw new GroqQueryError(\"unexpected desc\");\n    },\n    param (p) {\n        const name = p.processString();\n        if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n            return {\n                type: \"Value\",\n                value: p.parseOptions.params[name]\n            };\n        }\n        return {\n            type: \"Parameter\",\n            name\n        };\n    }\n};\nconst OBJECT_BUILDER = {\n    object_expr (p) {\n        if (p.getMark().name === \"pair\") {\n            p.shift();\n            const condition = p.process(EXPR_BUILDER);\n            const value2 = p.process(EXPR_BUILDER);\n            return {\n                type: \"ObjectConditionalSplat\",\n                condition,\n                value: value2\n            };\n        }\n        const value = p.process(EXPR_BUILDER);\n        return {\n            type: \"ObjectAttributeValue\",\n            name: extractPropertyKey(value),\n            value\n        };\n    },\n    object_pair (p) {\n        const name = p.process(EXPR_BUILDER);\n        if (name.type !== \"Value\") throw new Error(\"name must be string\");\n        const value = p.process(EXPR_BUILDER);\n        return {\n            type: \"ObjectAttributeValue\",\n            name: name.value,\n            value\n        };\n    },\n    object_splat (p) {\n        const value = p.process(EXPR_BUILDER);\n        return {\n            type: \"ObjectSplat\",\n            value\n        };\n    },\n    object_splat_this () {\n        return {\n            type: \"ObjectSplat\",\n            value: {\n                type: \"This\"\n            }\n        };\n    }\n};\nconst TRAVERSE_BUILDER = {\n    square_bracket (p) {\n        const expr = p.process(EXPR_BUILDER);\n        const value = tryConstantEvaluate(expr);\n        if (value && value.type === \"number\") {\n            return (right)=>traverseElement((base)=>({\n                        type: \"AccessElement\",\n                        base,\n                        index: value.data\n                    }), right);\n        }\n        if (value && value.type === \"string\") {\n            return (right)=>traversePlain((base)=>({\n                        type: \"AccessAttribute\",\n                        base,\n                        name: value.data\n                    }), right);\n        }\n        return (right)=>traverseArray((base)=>({\n                    type: \"Filter\",\n                    base,\n                    expr\n                }), right);\n    },\n    slice (p) {\n        const isInclusive = p.getMark().name === \"inc_range\";\n        p.shift();\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        const leftValue = tryConstantEvaluate(left);\n        const rightValue = tryConstantEvaluate(right);\n        if (!leftValue || !rightValue || leftValue.type !== \"number\" || rightValue.type !== \"number\") {\n            throw new GroqQueryError(\"slicing must use constant numbers\");\n        }\n        return (rhs)=>traverseArray((base)=>({\n                    type: \"Slice\",\n                    base,\n                    left: leftValue.data,\n                    right: rightValue.data,\n                    isInclusive\n                }), rhs);\n    },\n    projection (p) {\n        const obj = p.process(EXPR_BUILDER);\n        return (right)=>traverseProjection((base)=>({\n                    type: \"Projection\",\n                    base,\n                    expr: obj\n                }), right);\n    },\n    attr_access (p) {\n        const name = p.processString();\n        return (right)=>traversePlain((base)=>({\n                    type: \"AccessAttribute\",\n                    base,\n                    name\n                }), right);\n    },\n    deref (p) {\n        let attr = null;\n        if (p.getMark().name === \"deref_attr\") {\n            p.shift();\n            attr = p.processString();\n        }\n        const wrap = (base)=>attr ? {\n                type: \"AccessAttribute\",\n                base,\n                name: attr\n            } : base;\n        return (right)=>traversePlain((base)=>wrap({\n                    type: \"Deref\",\n                    base\n                }), right);\n    },\n    array_postfix (p) {\n        return (right)=>traverseArray((base)=>({\n                    type: \"ArrayCoerce\",\n                    base\n                }), right);\n    }\n};\nconst SELECTOR_BUILDER = {\n    group (p) {\n        p.process(SELECTOR_BUILDER);\n        return null;\n    },\n    everything () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    this () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    parent () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    dblparent (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    traverse (p) {\n        p.process(SELECTOR_BUILDER);\n        while(p.getMark().name !== \"traversal_end\"){\n            p.process(TRAVERSE_BUILDER);\n        }\n        p.shift();\n        return null;\n    },\n    this_attr (p) {\n        p.processString();\n        return null;\n    },\n    neg (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pos (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    add (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    sub (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    mul (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    div (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    mod (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pow (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    comp (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    in_range (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    str (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    integer (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    float (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    sci (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    object (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    array (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    tuple (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    func_call (p, mark) {\n        const func = EXPR_BUILDER.func_call(p, mark);\n        if (func.name === \"anywhere\" && func.args.length === 1) return null;\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pipecall (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pair (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    and (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    or (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    not (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    asc (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    desc (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    param (p) {\n        throw new Error(\"Invalid selector syntax\");\n    }\n};\nfunction extractPropertyKey(node) {\n    if (node.type === \"AccessAttribute\" && !node.base) {\n        return node.name;\n    }\n    if (node.type === \"Deref\" || node.type === \"Map\" || node.type === \"Projection\" || node.type === \"Slice\" || node.type === \"Filter\" || node.type === \"AccessElement\" || node.type === \"ArrayCoerce\") {\n        return extractPropertyKey(node.base);\n    }\n    throw new GroqQueryError(\"Cannot determine property key for type: \".concat(node.type));\n}\nfunction validateArity(name, arity, count) {\n    if (typeof arity === \"number\") {\n        if (count !== arity) {\n            throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"(). Expected \").concat(arity, \", got \").concat(count, \".\"));\n        }\n    } else if (arity) {\n        if (!arity(count)) {\n            throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"().\"));\n        }\n    }\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n    const functionsRequiringSelectors = [\n        \"changedAny\",\n        \"changedOnly\"\n    ];\n    return namespace == \"diff\" && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nclass GroqSyntaxError extends Error {\n    constructor(position){\n        super(\"Syntax error in GROQ query at position \".concat(position));\n        __publicField(this, \"position\");\n        __publicField(this, \"name\", \"GroqSyntaxError\");\n        this.position = position;\n    }\n}\nfunction parse(input) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const result = parse$1(input);\n    if (result.type === \"error\") {\n        throw new GroqSyntaxError(result.position);\n    }\n    const processor = new MarkProcessor(input, result.marks, options);\n    return processor.process(EXPR_BUILDER);\n}\nexports.DateTime = DateTime;\nexports.evaluate = evaluateQuery;\nexports.parse = parse; //# sourceMappingURL=1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0EsTUFBTUksd0JBQXdCcmQ7SUFDNUI1RCxZQUFZMFksUUFBUSxDQUFFO1FBQ3BCLEtBQUssQ0FBQywwQ0FBMEM3WSxNQUFNLENBQUM2WTtRQUN2RGlFLGNBQWMsSUFBSSxFQUFFO1FBQ3BCQSxjQUFjLElBQUksRUFBRSxRQUFRO1FBQzVCLElBQUksQ0FBQ2pFLFFBQVEsR0FBR0E7SUFDbEI7QUFDRjtBQUNBLFNBQVN3SSxNQUFNQyxLQUFLO0lBQ2xCLElBQUkzUSxVQUFVMUcsVUFBVTFJLE1BQU0sR0FBRyxLQUFLMEksU0FBUyxDQUFDLEVBQUUsS0FBS0MsWUFBWUQsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO0lBQ25GLE1BQU05SSxTQUFTNlksUUFBUXNIO0lBQ3ZCLElBQUluZ0IsT0FBT3dDLElBQUksS0FBSyxTQUFTO1FBQzNCLE1BQU0sSUFBSXlkLGdCQUFnQmpnQixPQUFPMFgsUUFBUTtJQUMzQztJQUNBLE1BQU0wSSxZQUFZLElBQUl6SixjQUFjd0osT0FBT25nQixPQUFPNFcsS0FBSyxFQUFFcEg7SUFDekQsT0FBTzRRLFVBQVVsSixPQUFPLENBQUNvRjtBQUMzQjtBQUNBN2UsZ0JBQWdCLEdBQUd1RjtBQUNuQnZGLGdCQUFnQixHQUFHNlI7QUFDbkI3UixhQUFhLEdBQUd5aUIsT0FDaEIsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFyeS5pbmZvLy4vbm9kZV9tb2R1bGVzL2dyb3EtanMvZGlzdC8xLmpzPzNmMzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBfX2RlZlByb3AkNSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkNSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkNShvYmosIGtleSwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZVxufSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkNSA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDUob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cbmZ1bmN0aW9uIHBhdGhSZWdFeHAocGF0dGVybikge1xuICBjb25zdCByZSA9IFtdO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGF0dGVybi5zcGxpdChcIi5cIikpIHtcbiAgICBpZiAocGFydCA9PT0gXCIqXCIpIHtcbiAgICAgIHJlLnB1c2goXCJbXi5dK1wiKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09IFwiKipcIikge1xuICAgICAgcmUucHVzaChcIi4qXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZS5wdXNoKGVzY2FwZVJlZ0V4cChwYXJ0KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdChyZS5qb2luKFwiLlwiKSwgXCIkXCIpKTtcbn1cbmNsYXNzIFBhdGgge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgX19wdWJsaWNGaWVsZCQ1KHRoaXMsIFwicGF0dGVyblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDUodGhpcywgXCJwYXR0ZXJuUmVcIik7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICB0aGlzLnBhdHRlcm5SZSA9IHBhdGhSZWdFeHAocGF0dGVybik7XG4gIH1cbiAgbWF0Y2hlcyhzdHIpIHtcbiAgICByZXR1cm4gdGhpcy5wYXR0ZXJuUmUudGVzdChzdHIpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXR0ZXJuO1xuICB9XG59XG52YXIgX19kZWZQcm9wJDQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDQob2JqLCBrZXksIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWVcbn0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkJDQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcCQ0KG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIFN0cmVhbVZhbHVlIHtcbiAgY29uc3RydWN0b3IoZ2VuZXJhdG9yKSB7XG4gICAgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwidHlwZVwiLCBcInN0cmVhbVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDQodGhpcywgXCJnZW5lcmF0b3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwidGlja2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQkNCh0aGlzLCBcImlzRG9uZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDQodGhpcywgXCJkYXRhXCIpO1xuICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgIHRoaXMudGlja2VyID0gbnVsbDtcbiAgICB0aGlzLmlzRG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIGlzQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgYXN5bmMgZ2V0KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcykge1xuICAgICAgcmVzdWx0LnB1c2goYXdhaXQgdmFsdWUuZ2V0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgZm9yICg7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeWllbGQgdGhpcy5kYXRhW2ldO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNEb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuX25leHRUaWNrKCk7XG4gICAgfVxuICB9XG4gIF9uZXh0VGljaygpIHtcbiAgICBpZiAodGhpcy50aWNrZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpY2tlcjtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRSZXNvbHZlcjtcbiAgICBjb25zdCBzZXR1cFRpY2tlciA9ICgpID0+IHtcbiAgICAgIHRoaXMudGlja2VyID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGN1cnJlbnRSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHRpY2sgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50UmVzb2x2ZXIoKTtcbiAgICAgIHNldHVwVGlja2VyKCk7XG4gICAgfTtcbiAgICBjb25zdCBmZXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcy5nZW5lcmF0b3IoKSkge1xuICAgICAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRpY2soKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNEb25lID0gdHJ1ZTtcbiAgICAgIHRpY2soKTtcbiAgICB9O1xuICAgIHNldHVwVGlja2VyKCk7XG4gICAgZmV0Y2goKTtcbiAgICByZXR1cm4gdGhpcy50aWNrZXI7XG4gIH1cbn1cbmNvbnN0IFJGQzMzMzlfUkVHRVggPSAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9VFxcZHsyfTpcXGR7Mn06XFxkezJ9KFxcLlxcZCspPyhafChbLStdXFxkezJ9OlxcZHsyfSkpJC87XG5mdW5jdGlvbiBwYXJzZVJGQzMzMzkoc3RyKSB7XG4gIGlmIChSRkMzMzM5X1JFR0VYLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShzdHIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZm9ybWF0UkZDMzMzOShkKSB7XG4gIGNvbnN0IHllYXIgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0Z1bGxZZWFyKCksIDQpO1xuICBjb25zdCBtb250aCA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDTW9udGgoKSArIDEsIDIpO1xuICBjb25zdCBkYXkgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0RhdGUoKSwgMik7XG4gIGNvbnN0IGhvdXIgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0hvdXJzKCksIDIpO1xuICBjb25zdCBtaW51dGUgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ01pbnV0ZXMoKSwgMik7XG4gIGNvbnN0IHNlY29uZCA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDU2Vjb25kcygpLCAyKTtcbiAgbGV0IGZyYWN0aW9uYWxTZWNvbmQgPSBcIlwiO1xuICBjb25zdCBtaWxsaXMgPSBkLmdldE1pbGxpc2Vjb25kcygpO1xuICBpZiAobWlsbGlzICE9IDApIHtcbiAgICBmcmFjdGlvbmFsU2Vjb25kID0gXCIuXCIuY29uY2F0KGFkZExlYWRpbmdaZXJvKG1pbGxpcywgMykpO1xuICB9XG4gIHJldHVybiBcIlwiLmNvbmNhdCh5ZWFyLCBcIi1cIikuY29uY2F0KG1vbnRoLCBcIi1cIikuY29uY2F0KGRheSwgXCJUXCIpLmNvbmNhdChob3VyLCBcIjpcIikuY29uY2F0KG1pbnV0ZSwgXCI6XCIpLmNvbmNhdChzZWNvbmQpLmNvbmNhdChmcmFjdGlvbmFsU2Vjb25kLCBcIlpcIik7XG59XG5mdW5jdGlvbiBhZGRMZWFkaW5nWmVybyhudW0sIHRhcmdldExlbmd0aCkge1xuICBsZXQgc3RyID0gbnVtLnRvU3RyaW5nKCk7XG4gIHdoaWxlIChzdHIubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgc3RyID0gXCIwXCIuY29uY2F0KHN0cik7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbnZhciBfX2RlZlByb3AkMyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMyA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMyhvYmosIGtleSwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZVxufSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkMyA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDMob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgU3RhdGljVmFsdWUge1xuICBjb25zdHJ1Y3RvcihkYXRhLCB0eXBlKSB7XG4gICAgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwiZGF0YVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJ0eXBlXCIpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuICBpc0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFwiYXJyYXlcIjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuICBhc3luYyBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZGF0YSkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKGRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGRhdGEpIHtcbiAgICAgICAgICB5aWVsZCBmcm9tSlMoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0odGhpcy5kYXRhKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGl0ZXJhdGUgb3ZlcjogXCIuY29uY2F0KHRoaXMudHlwZSkpO1xuICB9XG59XG5jb25zdCBOVUxMX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKG51bGwsIFwibnVsbFwiKTtcbmNvbnN0IFRSVUVfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUodHJ1ZSwgXCJib29sZWFuXCIpO1xuY29uc3QgRkFMU0VfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUoZmFsc2UsIFwiYm9vbGVhblwiKTtcbmNsYXNzIERhdGVUaW1lIHtcbiAgY29uc3RydWN0b3IoZGF0ZSkge1xuICAgIF9fcHVibGljRmllbGQkMyh0aGlzLCBcImRhdGVcIik7XG4gICAgdGhpcy5kYXRlID0gZGF0ZTtcbiAgfVxuICBzdGF0aWMgcGFyc2VUb1ZhbHVlKHN0cikge1xuICAgIGNvbnN0IGRhdGUgPSBwYXJzZVJGQzMzMzkoc3RyKTtcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShuZXcgRGF0ZVRpbWUoZGF0ZSksIFwiZGF0ZXRpbWVcIik7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpID09IG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICB9XG4gIGFkZChzZWNzKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRUaW1lKCkpO1xuICAgIGNvcHkuc2V0VGltZShjb3B5LmdldFRpbWUoKSArIHNlY3MgKiAxZTMpO1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoY29weSk7XG4gIH1cbiAgZGlmZmVyZW5jZShvdGhlcikge1xuICAgIHJldHVybiAodGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpKSAvIDFlMztcbiAgfVxuICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBmb3JtYXRSRkMzMzM5KHRoaXMuZGF0ZSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZyb21OdW1iZXIobnVtKSB7XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUobnVtKSkge1xuICAgIHJldHVybiBuZXcgU3RhdGljVmFsdWUobnVtLCBcIm51bWJlclwiKTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn1cbmZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyKSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUoc3RyLCBcInN0cmluZ1wiKTtcbn1cbmZ1bmN0aW9uIGZyb21EYXRlVGltZShkdCkge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKGR0LCBcImRhdGV0aW1lXCIpO1xufVxuZnVuY3Rpb24gZnJvbVBhdGgocGF0aCkge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHBhdGgsIFwicGF0aFwiKTtcbn1cbmZ1bmN0aW9uIGlzSXRlcmF0b3Iob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIG9iai5uZXh0ID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBmcm9tSlModmFsKSB7XG4gIGlmIChpc0l0ZXJhdG9yKHZhbCkpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHZhbCkge1xuICAgICAgICB5aWVsZCBmcm9tSlModmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUodmFsLCBnZXRUeXBlKHZhbCkpO1xufVxuZnVuY3Rpb24gZ2V0VHlwZShkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgfVxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFBhdGgpIHtcbiAgICByZXR1cm4gXCJwYXRoXCI7XG4gIH1cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRlVGltZSkge1xuICAgIHJldHVybiBcImRhdGV0aW1lXCI7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBkYXRhO1xufVxuZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIGlmIChhLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgYi50eXBlID09PSBcInN0cmluZ1wiIHx8IGEudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgYi50eXBlID09PSBcImJvb2xlYW5cIiB8fCBhLnR5cGUgPT09IFwibnVsbFwiICYmIGIudHlwZSA9PT0gXCJudWxsXCIgfHwgYS50eXBlID09PSBcIm51bWJlclwiICYmIGIudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBhLmRhdGEgPT09IGIuZGF0YTtcbiAgfVxuICBpZiAoYS50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgYi50eXBlID09PSBcImRhdGV0aW1lXCIpIHtcbiAgICByZXR1cm4gYS5kYXRhLmVxdWFscyhiLmRhdGEpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IENIQVJTID0gLyhbXiFAIyQlXiYqKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2c7XG5jb25zdCBDSEFSU19XSVRIX1dJTERDQVJEID0gLyhbXiFAIyQlXiYoKSxcXFxcLz9cIjs6e318W1xcXSs8Plxccy1dKSsvZztcbmNvbnN0IEVER0VfQ0hBUlMgPSAvKFxcYlxcLit8XFwuK1xcYikvZztcbmNvbnN0IE1BWF9URVJNX0xFTkdUSCA9IDEwMjQ7XG5mdW5jdGlvbiBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucykge1xuICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCBwYXR0ZXJucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHBhdHRlcm5zLmV2ZXJ5KHBhdHRlcm4gPT4gcGF0dGVybih0b2tlbnMpKTtcbn1cbmZ1bmN0aW9uIG1hdGNoVG9rZW5pemUodGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKEVER0VfQ0hBUlMsIFwiXCIpLm1hdGNoKENIQVJTKSB8fCBbXTtcbn1cbmZ1bmN0aW9uIG1hdGNoQW5hbHl6ZVBhdHRlcm4odGV4dCkge1xuICBjb25zdCB0ZXJtc1JlID0gbWF0Y2hQYXR0ZXJuUmVnZXgodGV4dCk7XG4gIHJldHVybiB0ZXJtc1JlLm1hcChyZSA9PiB0b2tlbnMgPT4gdG9rZW5zLnNvbWUodG9rZW4gPT4gcmUudGVzdCh0b2tlbikpKTtcbn1cbmZ1bmN0aW9uIG1hdGNoUGF0dGVyblJlZ2V4KHRleHQpIHtcbiAgY29uc3QgdGVybXMgPSB0ZXh0LnJlcGxhY2UoRURHRV9DSEFSUywgXCJcIikubWF0Y2goQ0hBUlNfV0lUSF9XSUxEQ0FSRCkgfHwgW107XG4gIHJldHVybiB0ZXJtcy5tYXAodGVybSA9PiBuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdCh0ZXJtLnNsaWNlKDAsIE1BWF9URVJNX0xFTkdUSCkucmVwbGFjZSgvXFwqL2csIFwiLipcIiksIFwiJFwiKSwgXCJpXCIpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdhdGhlclRleHQodmFsdWUsIGNiKSB7XG4gIGlmICh2YWx1ZS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgY2IodmFsdWUuZGF0YSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlLmlzQXJyYXkoKSkge1xuICAgIGxldCBzdWNjZXNzID0gdHJ1ZTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2YgdmFsdWUpIHtcbiAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY2IocGFydC5kYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgVFlQRV9PUkRFUiA9IHtcbiAgZGF0ZXRpbWU6IDEsXG4gIG51bWJlcjogMixcbiAgc3RyaW5nOiAzLFxuICBib29sZWFuOiA0XG59O1xuZnVuY3Rpb24gcGFydGlhbENvbXBhcmUoYSwgYikge1xuICBjb25zdCBhVHlwZSA9IGdldFR5cGUoYSk7XG4gIGNvbnN0IGJUeXBlID0gZ2V0VHlwZShiKTtcbiAgaWYgKGFUeXBlICE9PSBiVHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN3aXRjaCAoYVR5cGUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgIHJldHVybiBhLmNvbXBhcmVUbyhiKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvdGFsQ29tcGFyZShhLCBiKSB7XG4gIGNvbnN0IGFUeXBlID0gZ2V0VHlwZShhKTtcbiAgY29uc3QgYlR5cGUgPSBnZXRUeXBlKGIpO1xuICBjb25zdCBhVHlwZU9yZGVyID0gVFlQRV9PUkRFUlthVHlwZV0gfHwgMTAwO1xuICBjb25zdCBiVHlwZU9yZGVyID0gVFlQRV9PUkRFUltiVHlwZV0gfHwgMTAwO1xuICBpZiAoYVR5cGVPcmRlciAhPT0gYlR5cGVPcmRlcikge1xuICAgIHJldHVybiBhVHlwZU9yZGVyIC0gYlR5cGVPcmRlcjtcbiAgfVxuICBsZXQgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUoYSwgYik7XG4gIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICByZXN1bHQgPSAwO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBvcGVyYXRvcnMgPSB7XG4gIFwiPT1cIjogZnVuY3Rpb24gZXEobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiIT1cIjogZnVuY3Rpb24gbmVxKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGlzRXF1YWwobGVmdCwgcmlnaHQpID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xuICB9LFxuICBcIj5cIjogZnVuY3Rpb24gZ3QobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgPiAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIj49XCI6IGZ1bmN0aW9uIGd0ZShsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCA+PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIjxcIjogZnVuY3Rpb24gbHQobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIjw9XCI6IGZ1bmN0aW9uIGx0ZShsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gIGluOiBhc3luYyBmdW5jdGlvbiBpbm9wKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKHJpZ2h0LnR5cGUgPT09IFwicGF0aFwiKSB7XG4gICAgICBpZiAobGVmdC50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJpZ2h0LmRhdGEubWF0Y2hlcyhsZWZ0LmRhdGEpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICAgIH1cbiAgICBpZiAocmlnaHQuaXNBcnJheSgpKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGIgb2YgcmlnaHQpIHtcbiAgICAgICAgaWYgKGlzRXF1YWwobGVmdCwgYikpIHtcbiAgICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgbWF0Y2g6IGFzeW5jIGZ1bmN0aW9uIG1hdGNoKGxlZnQsIHJpZ2h0KSB7XG4gICAgbGV0IHRva2VucyA9IFtdO1xuICAgIGxldCBwYXR0ZXJucyA9IFtdO1xuICAgIGF3YWl0IGdhdGhlclRleHQobGVmdCwgcGFydCA9PiB7XG4gICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGRpZFN1Y2NlZWQgPSBhd2FpdCBnYXRoZXJUZXh0KHJpZ2h0LCBwYXJ0ID0+IHtcbiAgICAgIHBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KG1hdGNoQW5hbHl6ZVBhdHRlcm4ocGFydCkpO1xuICAgIH0pO1xuICAgIGlmICghZGlkU3VjY2VlZCkge1xuICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVkID0gbWF0Y2hUZXh0KHRva2VucywgcGF0dGVybnMpO1xuICAgIHJldHVybiBtYXRjaGVkID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIitcIjogZnVuY3Rpb24gcGx1cyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQocmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmluZ1wiICYmIHJpZ2h0LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcIm9iamVjdFwiICYmIHJpZ2h0LnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBmcm9tSlMoe1xuICAgICAgICAuLi5sZWZ0LmRhdGEsXG4gICAgICAgIC4uLnJpZ2h0LmRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcImFycmF5XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICByZXR1cm4gZnJvbUpTKGxlZnQuZGF0YS5jb25jYXQocmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC5pc0FycmF5KCkgJiYgcmlnaHQuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIGxlZnQpIHtcbiAgICAgICAgICB5aWVsZCB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgcmlnaHQpIHtcbiAgICAgICAgICB5aWVsZCB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgXCItXCI6IGZ1bmN0aW9uIG1pbnVzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZCgtcmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgICByZXR1cm4gZnJvbU51bWJlcihsZWZ0LmRhdGEuZGlmZmVyZW5jZShyaWdodC5kYXRhKSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIobGVmdC5kYXRhIC0gcmlnaHQuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBcIipcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhICogYiksXG4gIFwiL1wiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgLyBiKSxcbiAgXCIlXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAlIGIpLFxuICBcIioqXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gTWF0aC5wb3coYSwgYikpXG59O1xuZnVuY3Rpb24gbnVtZXJpY09wZXJhdG9yKGltcGwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gaW1wbChsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH07XG59XG52YXIgX19kZWZQcm9wJDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDIgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDIob2JqLCBrZXksIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWVcbn0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkJDIgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcCQyKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIFNjb3BlIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgY29uc3RydWN0b3IocGFyYW1zLCBzb3VyY2UsIHZhbHVlLCBjb250ZXh0LCBwYXJlbnQpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJwYXJhbXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwic291cmNlXCIpO1xuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcInZhbHVlXCIpO1xuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcInBhcmVudFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJjb250ZXh0XCIpO1xuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcImlzSGlkZGVuXCIsIGZhbHNlKTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfVxuICBjcmVhdGVOZXN0ZWQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc0hpZGRlbikge1xuICAgICAgcmV0dXJuIG5ldyBTY29wZSh0aGlzLnBhcmFtcywgdGhpcy5zb3VyY2UsIHZhbHVlLCB0aGlzLmNvbnRleHQsIHRoaXMucGFyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTY29wZSh0aGlzLnBhcmFtcywgdGhpcy5zb3VyY2UsIHZhbHVlLCB0aGlzLmNvbnRleHQsIHRoaXMpO1xuICB9XG4gIGNyZWF0ZUhpZGRlbih2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICByZXN1bHQuaXNIaWRkZW4gPSB0cnVlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGV2YWx1YXRlKG5vZGUsIHNjb3BlKSB7XG4gIGxldCBleGVjdXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBldmFsdWF0ZTtcbiAgY29uc3QgZnVuYyA9IEVYRUNVVE9SU1tub2RlLnR5cGVdO1xuICByZXR1cm4gZnVuYyhub2RlLCBzY29wZSwgZXhlY3V0ZSk7XG59XG5mdW5jdGlvbiBwcm9taXNlbGVzc0FwcGx5KHZhbHVlLCBjYikge1xuICBpZiAoXCJ0aGVuXCIgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUudGhlbihjYik7XG4gIH1cbiAgcmV0dXJuIGNiKHZhbHVlKTtcbn1cbmNvbnN0IEVYRUNVVE9SUyA9IHtcbiAgVGhpcyhfLCBzY29wZSkge1xuICAgIHJldHVybiBzY29wZS52YWx1ZTtcbiAgfSxcbiAgU2VsZWN0b3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VsZWN0b3JzIGNhbiBub3QgYmUgZXZhbHVhdGVkXCIpO1xuICB9LFxuICBFdmVyeXRoaW5nKF8sIHNjb3BlKSB7XG4gICAgcmV0dXJuIHNjb3BlLnNvdXJjZTtcbiAgfSxcbiAgUGFyYW1ldGVyKF9yZWYsIHNjb3BlKSB7XG4gICAgbGV0IHtcbiAgICAgIG5hbWVcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gZnJvbUpTKHNjb3BlLnBhcmFtc1tuYW1lXSk7XG4gIH0sXG4gIENvbnRleHQoX3JlZjIsIHNjb3BlKSB7XG4gICAgbGV0IHtcbiAgICAgIGtleVxuICAgIH0gPSBfcmVmMjtcbiAgICBpZiAoa2V5ID09PSBcImJlZm9yZVwiIHx8IGtleSA9PT0gXCJhZnRlclwiKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHNjb3BlLmNvbnRleHRba2V5XTtcbiAgICAgIHJldHVybiB2YWx1ZSB8fCBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGNvbnRleHQga2V5OiBcIi5jb25jYXQoa2V5KSk7XG4gIH0sXG4gIFBhcmVudChfcmVmMywgc2NvcGUpIHtcbiAgICBsZXQge1xuICAgICAgblxuICAgIH0gPSBfcmVmMztcbiAgICBsZXQgY3VycmVudCA9IHNjb3BlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBpZiAoIWN1cnJlbnQucGFyZW50KSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgfSxcbiAgT3BDYWxsKF9yZWY0LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBvcCxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH0gPSBfcmVmNDtcbiAgICBjb25zdCBmdW5jID0gb3BlcmF0b3JzW29wXTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3I6IFwiLmNvbmNhdChvcCkpO1xuICAgIH1cbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgICBjb25zdCByaWdodFZhbHVlID0gZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgIGlmIChcInRoZW5cIiBpbiBsZWZ0VmFsdWUgfHwgXCJ0aGVuXCIgaW4gcmlnaHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIChhc3luYyAoKSA9PiBmdW5jKGF3YWl0IGxlZnRWYWx1ZSwgYXdhaXQgcmlnaHRWYWx1ZSkpKCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jKGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSk7XG4gIH0sXG4gIGFzeW5jIFNlbGVjdChfcmVmNSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYWx0ZXJuYXRpdmVzLFxuICAgICAgZmFsbGJhY2tcbiAgICB9ID0gX3JlZjU7XG4gICAgZm9yIChjb25zdCBhbHQgb2YgYWx0ZXJuYXRpdmVzKSB7XG4gICAgICBjb25zdCBhbHRDb25kID0gYXdhaXQgZXhlY3V0ZShhbHQuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICBpZiAoYWx0Q29uZC50eXBlID09PSBcImJvb2xlYW5cIiAmJiBhbHRDb25kLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGUoYWx0LnZhbHVlLCBzY29wZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGV4ZWN1dGUoZmFsbGJhY2ssIHNjb3BlKTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEluUmFuZ2UoX3JlZjYsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2UsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICBpc0luY2x1c2l2ZVxuICAgIH0gPSBfcmVmNjtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpO1xuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgY29uc3QgbGVmdENtcCA9IHBhcnRpYWxDb21wYXJlKGF3YWl0IHZhbHVlLmdldCgpLCBhd2FpdCBsZWZ0VmFsdWUuZ2V0KCkpO1xuICAgIGlmIChsZWZ0Q21wID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgcmlnaHRDbXAgPSBwYXJ0aWFsQ29tcGFyZShhd2FpdCB2YWx1ZS5nZXQoKSwgYXdhaXQgcmlnaHRWYWx1ZS5nZXQoKSk7XG4gICAgaWYgKHJpZ2h0Q21wID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKGlzSW5jbHVzaXZlKSB7XG4gICAgICByZXR1cm4gbGVmdENtcCA+PSAwICYmIHJpZ2h0Q21wIDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBhc3luYyBGaWx0ZXIoX3JlZjcsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2UsXG4gICAgICBleHByXG4gICAgfSA9IF9yZWY3O1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBiYXNlVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoZWxlbSk7XG4gICAgICAgIGNvbnN0IGV4cHJWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICAgICAgICBpZiAoZXhwclZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGV4cHJWYWx1ZS5kYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgeWllbGQgZWxlbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBhc3luYyBQcm9qZWN0aW9uKF9yZWY4LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlLFxuICAgICAgZXhwclxuICAgIH0gPSBfcmVmODtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoYmFzZVZhbHVlLnR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChiYXNlVmFsdWUpO1xuICAgIHJldHVybiBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcbiAgfSxcbiAgRnVuY0NhbGwoX3JlZjksIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGZ1bmMsXG4gICAgICBhcmdzXG4gICAgfSA9IF9yZWY5O1xuICAgIHJldHVybiBmdW5jKGFyZ3MsIHNjb3BlLCBleGVjdXRlKTtcbiAgfSxcbiAgYXN5bmMgUGlwZUZ1bmNDYWxsKF9yZWYxMCwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgZnVuYyxcbiAgICAgIGJhc2UsXG4gICAgICBhcmdzXG4gICAgfSA9IF9yZWYxMDtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICByZXR1cm4gZnVuYyhiYXNlVmFsdWUsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKTtcbiAgfSxcbiAgYXN5bmMgQWNjZXNzQXR0cmlidXRlKF9yZWYxMSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZSxcbiAgICAgIG5hbWVcbiAgICB9ID0gX3JlZjExO1xuICAgIGxldCB2YWx1ZSA9IHNjb3BlLnZhbHVlO1xuICAgIGlmIChiYXNlKSB7XG4gICAgICB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKHZhbHVlLmRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZyb21KUyh2YWx1ZS5kYXRhW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEFjY2Vzc0VsZW1lbnQoX3JlZjEyLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlLFxuICAgICAgaW5kZXhcbiAgICB9ID0gX3JlZjEyO1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBiYXNlVmFsdWUuZ2V0KCk7XG4gICAgY29uc3QgZmluYWxJbmRleCA9IGluZGV4IDwgMCA/IGluZGV4ICsgZGF0YS5sZW5ndGggOiBpbmRleDtcbiAgICByZXR1cm4gZnJvbUpTKGRhdGFbZmluYWxJbmRleF0pO1xuICB9LFxuICBhc3luYyBTbGljZShfcmVmMTMsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2UsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICBpc0luY2x1c2l2ZVxuICAgIH0gPSBfcmVmMTM7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgYXJyYXkgPSBhd2FpdCBiYXNlVmFsdWUuZ2V0KCk7XG4gICAgbGV0IGxlZnRJZHggPSBsZWZ0O1xuICAgIGxldCByaWdodElkeCA9IHJpZ2h0O1xuICAgIGlmIChsZWZ0SWR4IDwgMCkge1xuICAgICAgbGVmdElkeCA9IGFycmF5Lmxlbmd0aCArIGxlZnRJZHg7XG4gICAgfVxuICAgIGlmIChyaWdodElkeCA8IDApIHtcbiAgICAgIHJpZ2h0SWR4ID0gYXJyYXkubGVuZ3RoICsgcmlnaHRJZHg7XG4gICAgfVxuICAgIGlmIChpc0luY2x1c2l2ZSkge1xuICAgICAgcmlnaHRJZHgrKztcbiAgICB9XG4gICAgaWYgKGxlZnRJZHggPCAwKSB7XG4gICAgICBsZWZ0SWR4ID0gMDtcbiAgICB9XG4gICAgaWYgKHJpZ2h0SWR4IDwgMCkge1xuICAgICAgcmlnaHRJZHggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbUpTKGFycmF5LnNsaWNlKGxlZnRJZHgsIHJpZ2h0SWR4KSk7XG4gIH0sXG4gIGFzeW5jIERlcmVmKF9yZWYxNCwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZVxuICAgIH0gPSBfcmVmMTQ7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIXNjb3BlLnNvdXJjZS5pc0FycmF5KCkpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gdmFsdWUuZGF0YS5fcmVmO1xuICAgIGlmICh0eXBlb2YgaWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBpZiAoc2NvcGUuY29udGV4dC5kZXJlZmVyZW5jZSkge1xuICAgICAgcmV0dXJuIGZyb21KUyhhd2FpdCBzY29wZS5jb250ZXh0LmRlcmVmZXJlbmNlKHtcbiAgICAgICAgX3JlZjogaWRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgZm9yIGF3YWl0IChjb25zdCBkb2Mgb2Ygc2NvcGUuc291cmNlKSB7XG4gICAgICBpZiAoZG9jLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgaWQgPT09IGRvYy5kYXRhLl9pZCkge1xuICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgVmFsdWUoX3JlZjE1KSB7XG4gICAgbGV0IHtcbiAgICAgIHZhbHVlXG4gICAgfSA9IF9yZWYxNTtcbiAgICByZXR1cm4gZnJvbUpTKHZhbHVlKTtcbiAgfSxcbiAgR3JvdXAoX3JlZjE2LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlXG4gICAgfSA9IF9yZWYxNjtcbiAgICByZXR1cm4gZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gIH0sXG4gIGFzeW5jIE9iamVjdChfcmVmMTcsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9ID0gX3JlZjE3O1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0ciBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyVHlwZSA9IGF0dHIudHlwZTtcbiAgICAgIHN3aXRjaCAoYXR0ci50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgICByZXN1bHRbYXR0ci5uYW1lXSA9IGF3YWl0IHZhbHVlLmdldCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiT2JqZWN0Q29uZGl0aW9uYWxTcGxhdFwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmQgPSBhd2FpdCBleGVjdXRlKGF0dHIuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICAgICAgICBpZiAoY29uZC50eXBlICE9PSBcImJvb2xlYW5cIiB8fCBjb25kLmRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk9iamVjdFNwbGF0XCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIuY29uY2F0KGF0dHJUeXBlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcm9tSlMocmVzdWx0KTtcbiAgfSxcbiAgQXJyYXkoX3JlZjE4LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBlbGVtZW50c1xuICAgIH0gPSBfcmVmMTg7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShlbGVtZW50LnZhbHVlLCBzY29wZSk7XG4gICAgICAgIGlmIChlbGVtZW50LmlzU3BsYXQpIHtcbiAgICAgICAgICBpZiAodmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgeWllbGQgdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgVHVwbGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHVwbGVzIGNhbiBub3QgYmUgZXZhbHVhdGVkXCIpO1xuICB9LFxuICBhc3luYyBPcihfcmVmMTksIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH0gPSBfcmVmMTk7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSk7XG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBpZiAobGVmdFZhbHVlLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyaWdodFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBpZiAocmlnaHRWYWx1ZS5kYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBUUlVFX1ZBTFVFO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEFuZChfcmVmMjAsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH0gPSBfcmVmMjA7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSk7XG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBpZiAobGVmdFZhbHVlLmRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJpZ2h0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGlmIChyaWdodFZhbHVlLmRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlZnRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIE5vdChfcmVmMjEsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2VcbiAgICB9ID0gX3JlZjIxO1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmRhdGEgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG4gIH0sXG4gIE5lZyhfcmVmMjIsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2VcbiAgICB9ID0gX3JlZjIyO1xuICAgIHJldHVybiBwcm9taXNlbGVzc0FwcGx5KGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCB2YWx1ZSA9PiB7XG4gICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZS5kYXRhKTtcbiAgICB9KTtcbiAgfSxcbiAgUG9zKF9yZWYyMywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZVxuICAgIH0gPSBfcmVmMjM7XG4gICAgcmV0dXJuIHByb21pc2VsZXNzQXBwbHkoZXhlY3V0ZShiYXNlLCBzY29wZSksIHZhbHVlID0+IHtcbiAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsdWUuZGF0YSk7XG4gICAgfSk7XG4gIH0sXG4gIEFzYygpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgRGVzYygpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgQXJyYXlDb2VyY2UoX3JlZjI0LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlXG4gICAgfSA9IF9yZWYyNDtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiB2YWx1ZS5pc0FycmF5KCkgPyB2YWx1ZSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIE1hcChfcmVmMjUsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2UsXG4gICAgICBleHByXG4gICAgfSA9IF9yZWYyNTtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGVsZW0pO1xuICAgICAgICB5aWVsZCBhd2FpdCBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgYXN5bmMgRmxhdE1hcChfcmVmMjYsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2UsXG4gICAgICBleHByXG4gICAgfSA9IF9yZWYyNjtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGVsZW0pO1xuICAgICAgICBjb25zdCBpbm5lclZhbHVlID0gYXdhaXQgZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gICAgICAgIGlmIChpbm5lclZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgaW5uZXIgb2YgaW5uZXJWYWx1ZSkge1xuICAgICAgICAgICAgeWllbGQgaW5uZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIGlubmVyVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGV2YWx1YXRlUXVlcnkodHJlZSkge1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGNvbnN0IHJvb3QgPSBmcm9tSlMob3B0aW9ucy5yb290KTtcbiAgY29uc3QgZGF0YXNldCA9IGZyb21KUyhvcHRpb25zLmRhdGFzZXQpO1xuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgLi4ub3B0aW9ucy5wYXJhbXNcbiAgfTtcbiAgY29uc3Qgc2NvcGUgPSBuZXcgU2NvcGUocGFyYW1zLCBkYXRhc2V0LCByb290LCB7XG4gICAgdGltZXN0YW1wOiBvcHRpb25zLnRpbWVzdGFtcCB8fCAvKiBAX19QVVJFX18gKi9uZXcgRGF0ZSgpLFxuICAgIGlkZW50aXR5OiBvcHRpb25zLmlkZW50aXR5ID09PSB2b2lkIDAgPyBcIm1lXCIgOiBvcHRpb25zLmlkZW50aXR5LFxuICAgIHNhbml0eTogb3B0aW9ucy5zYW5pdHksXG4gICAgYWZ0ZXI6IG9wdGlvbnMuYWZ0ZXIgPyBmcm9tSlMob3B0aW9ucy5hZnRlcikgOiBudWxsLFxuICAgIGJlZm9yZTogb3B0aW9ucy5iZWZvcmUgPyBmcm9tSlMob3B0aW9ucy5iZWZvcmUpIDogbnVsbCxcbiAgICBkZXJlZmVyZW5jZTogb3B0aW9ucy5kZXJlZmVyZW5jZVxuICB9LCBudWxsKTtcbiAgcmV0dXJuIGV2YWx1YXRlKHRyZWUsIHNjb3BlKTtcbn1cbmZ1bmN0aW9uIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJHcm91cFwiOlxuICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5iYXNlKTtcbiAgICBjYXNlIFwiVmFsdWVcIjpcbiAgICBjYXNlIFwiUGFyYW1ldGVyXCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlIFwiUG9zXCI6XG4gICAgY2FzZSBcIk5lZ1wiOlxuICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5iYXNlKTtcbiAgICBjYXNlIFwiT3BDYWxsXCI6XG4gICAgICBzd2l0Y2ggKG5vZGUub3ApIHtcbiAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgY2FzZSBcIioqXCI6XG4gICAgICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5sZWZ0KSAmJiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUucmlnaHQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jb25zdCBEVU1NWV9TQ09QRSA9IG5ldyBTY29wZSh7fSwgTlVMTF9WQUxVRSwgTlVMTF9WQUxVRSwge1xuICB0aW1lc3RhbXA6IC8qIEBfX1BVUkVfXyAqL25ldyBEYXRlKDApLFxuICBpZGVudGl0eTogXCJtZVwiLFxuICBiZWZvcmU6IG51bGwsXG4gIGFmdGVyOiBudWxsXG59LCBudWxsKTtcbmZ1bmN0aW9uIHRyeUNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICBpZiAoIWNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY29uc3RhbnRFdmFsdWF0ZShub2RlKTtcbn1cbmZ1bmN0aW9uIGNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICBjb25zdCB2YWx1ZSA9IGV2YWx1YXRlKG5vZGUsIERVTU1ZX1NDT1BFLCBjb25zdGFudEV2YWx1YXRlKTtcbiAgaWYgKFwidGhlblwiIGluIHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiBjb25zdGFudCBldmFsdWF0ZSBzaG91bGQgbmV2ZXIgcmV0dXJuIGEgcHJvbWlzZVwiKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5hc3luYyBmdW5jdGlvbiBwb3J0YWJsZVRleHRDb250ZW50KHZhbHVlKSB7XG4gIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGJsb2NrVGV4dCh2YWx1ZS5kYXRhKTtcbiAgfSBlbHNlIGlmICh2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICBjb25zdCB0ZXh0cyA9IGF3YWl0IGFycmF5VGV4dCh2YWx1ZSk7XG4gICAgaWYgKHRleHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0ZXh0cy5qb2luKFwiXFxuXFxuXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFycmF5VGV4dCh2YWx1ZSkge1xuICBsZXQgcmVzdWx0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgZm9yIGF3YWl0IChjb25zdCBibG9jayBvZiB2YWx1ZSkge1xuICAgIGlmIChibG9jay50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYmxvY2tUZXh0KGJsb2NrLmRhdGEpO1xuICAgICAgaWYgKHRleHQgIT09IG51bGwpIHJlc3VsdC5wdXNoKHRleHQpO1xuICAgIH0gZWxzZSBpZiAoYmxvY2suaXNBcnJheSgpKSB7XG4gICAgICBhd2FpdCBhcnJheVRleHQoYmxvY2ssIHJlc3VsdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBibG9ja1RleHQob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqLl90eXBlICE9PSBcInN0cmluZ1wiKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgY2hpbGRyZW4gPSBvYmouY2hpbGRyZW47XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHJldHVybiBudWxsO1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgIGlmIChjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNoaWxkLl90eXBlID09PSBcInN0cmluZ1wiICYmIGNoaWxkLl90eXBlID09PSBcInNwYW5cIiAmJiB0eXBlb2YgY2hpbGQudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVzdWx0ICs9IGNoaWxkLnRleHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBCTTI1ayA9IDEuMjtcbmFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRlU2NvcmUobm9kZSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcENhbGxcIiAmJiBub2RlLm9wID09PSBcIm1hdGNoXCIpIHtcbiAgICByZXR1cm4gZXZhbHVhdGVNYXRjaFNjb3JlKG5vZGUubGVmdCwgbm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IFwiRnVuY0NhbGxcIiAmJiBub2RlLm5hbWUgPT09IFwiYm9vc3RcIikge1xuICAgIGNvbnN0IGlubmVyU2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUuYXJnc1swXSwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgIGNvbnN0IGJvb3N0ID0gYXdhaXQgZXhlY3V0ZShub2RlLmFyZ3NbMV0sIHNjb3BlKTtcbiAgICBpZiAoYm9vc3QudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpbm5lclNjb3JlID4gMCkge1xuICAgICAgcmV0dXJuIGlubmVyU2NvcmUgKyBib29zdC5kYXRhO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJPclwiOlxuICAgICAge1xuICAgICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgICAgICBjb25zdCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICAgIHJldHVybiBsZWZ0U2NvcmUgKyByaWdodFNjb3JlO1xuICAgICAgfVxuICAgIGNhc2UgXCJBbmRcIjpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgbGVmdFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLmxlZnQsIHNjb3BlLCBleGVjdXRlKTtcbiAgICAgICAgY29uc3QgcmlnaHRTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgICAgICBpZiAobGVmdFNjb3JlID09PSAwIHx8IHJpZ2h0U2NvcmUgPT09IDApIHJldHVybiAwO1xuICAgICAgICByZXR1cm4gbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBleGVjdXRlKG5vZGUsIHNjb3BlKTtcbiAgICAgICAgcmV0dXJuIHJlcy50eXBlID09PSBcImJvb2xlYW5cIiAmJiByZXMuZGF0YSA9PT0gdHJ1ZSA/IDEgOiAwO1xuICAgICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBldmFsdWF0ZU1hdGNoU2NvcmUobGVmdCwgcmlnaHQsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHRleHQgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgY29uc3QgcGF0dGVybiA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgbGV0IHRva2VucyA9IFtdO1xuICBsZXQgdGVybXMgPSBbXTtcbiAgYXdhaXQgZ2F0aGVyVGV4dCh0ZXh0LCBwYXJ0ID0+IHtcbiAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xuICB9KTtcbiAgY29uc3QgZGlkU3VjY2VlZCA9IGF3YWl0IGdhdGhlclRleHQocGF0dGVybiwgcGFydCA9PiB7XG4gICAgdGVybXMgPSB0ZXJtcy5jb25jYXQobWF0Y2hQYXR0ZXJuUmVnZXgocGFydCkpO1xuICB9KTtcbiAgaWYgKCFkaWRTdWNjZWVkKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgdGVybXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbGV0IHNjb3JlID0gMDtcbiAgZm9yIChjb25zdCByZSBvZiB0ZXJtcykge1xuICAgIGNvbnN0IGZyZXEgPSB0b2tlbnMucmVkdWNlKChjLCB0b2tlbikgPT4gYyArIChyZS50ZXN0KHRva2VuKSA/IDEgOiAwKSwgMCk7XG4gICAgc2NvcmUgKz0gZnJlcSAqIChCTTI1ayArIDEpIC8gKGZyZXEgKyBCTTI1ayk7XG4gIH1cbiAgcmV0dXJuIHNjb3JlO1xufVxuZnVuY3Rpb24gaGFzUmVmZXJlbmNlKHZhbHVlLCBwYXRoU2V0KSB7XG4gIHN3aXRjaCAoZ2V0VHlwZSh2YWx1ZSkpIHtcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICBpZiAoaGFzUmVmZXJlbmNlKHYsIHBhdGhTZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmICh2YWx1ZS5fcmVmKSB7XG4gICAgICAgIHJldHVybiBwYXRoU2V0Lmhhcyh2YWx1ZS5fcmVmKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdiBvZiBPYmplY3QudmFsdWVzKHZhbHVlKSkge1xuICAgICAgICBpZiAoaGFzUmVmZXJlbmNlKHYsIHBhdGhTZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvdW50VVRGOChzdHIpIHtcbiAgbGV0IGNvdW50MiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID49IDU1Mjk2ICYmIGNvZGUgPD0gNTYzMTkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb3VudDIrKztcbiAgfVxuICByZXR1cm4gY291bnQyO1xufVxuY29uc3QgX2dsb2JhbCA9IHt9O1xuX2dsb2JhbC5hbnl3aGVyZSA9IGFzeW5jIGZ1bmN0aW9uIGFueXdoZXJlKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuX2dsb2JhbC5hbnl3aGVyZS5hcml0eSA9IDE7XG5fZ2xvYmFsLmNvYWxlc2NlID0gYXN5bmMgZnVuY3Rpb24gY29hbGVzY2UoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmcsIHNjb3BlKTtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuX2dsb2JhbC5jb3VudCA9IGFzeW5jIGZ1bmN0aW9uIGNvdW50KGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGlubmVyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghaW5uZXIuaXNBcnJheSgpKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgbGV0IG51bSA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgXyBvZiBpbm5lcikge1xuICAgIG51bSsrO1xuICB9XG4gIHJldHVybiBmcm9tTnVtYmVyKG51bSk7XG59O1xuX2dsb2JhbC5jb3VudC5hcml0eSA9IDE7XG5fZ2xvYmFsLmRhdGVUaW1lID0gYXN5bmMgZnVuY3Rpb24gZGF0ZVRpbWUoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWwudHlwZSA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodmFsLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gRGF0ZVRpbWUucGFyc2VUb1ZhbHVlKHZhbC5kYXRhKTtcbn07XG5fZ2xvYmFsLmRhdGVUaW1lLmFyaXR5ID0gMTtcbl9nbG9iYWwuZGVmaW5lZCA9IGFzeW5jIGZ1bmN0aW9uIGRlZmluZWQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgcmV0dXJuIGlubmVyLnR5cGUgPT09IFwibnVsbFwiID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xufTtcbl9nbG9iYWwuZGVmaW5lZC5hcml0eSA9IDE7XG5fZ2xvYmFsLmlkZW50aXR5ID0gYXN5bmMgZnVuY3Rpb24gaWRlbnRpdHkoYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5pZGVudGl0eSk7XG59O1xuX2dsb2JhbC5pZGVudGl0eS5hcml0eSA9IDA7XG5fZ2xvYmFsLmxlbmd0aCA9IGFzeW5jIGZ1bmN0aW9uIGxlbmd0aChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoaW5uZXIudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmcm9tTnVtYmVyKGNvdW50VVRGOChpbm5lci5kYXRhKSk7XG4gIH1cbiAgaWYgKGlubmVyLmlzQXJyYXkoKSkge1xuICAgIGxldCBudW0gPSAwO1xuICAgIGZvciBhd2FpdCAoY29uc3QgXyBvZiBpbm5lcikge1xuICAgICAgbnVtKys7XG4gICAgfVxuICAgIHJldHVybiBmcm9tTnVtYmVyKG51bSk7XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuX2dsb2JhbC5sZW5ndGguYXJpdHkgPSAxO1xuX2dsb2JhbC5wYXRoID0gYXN5bmMgZnVuY3Rpb24gcGF0aChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoaW5uZXIudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBmcm9tUGF0aChuZXcgUGF0aChpbm5lci5kYXRhKSk7XG59O1xuX2dsb2JhbC5wYXRoLmFyaXR5ID0gMTtcbl9nbG9iYWwuc3RyaW5nID0gYXN5bmMgZnVuY3Rpb24gc3RyaW5nKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwiXCIuY29uY2F0KHZhbHVlLmRhdGEpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbn07XG5fZ2xvYmFsLnN0cmluZy5hcml0eSA9IDE7XG5fZ2xvYmFsLnJlZmVyZW5jZXMgPSBhc3luYyBmdW5jdGlvbiByZWZlcmVuY2VzKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHBhdGhTZXQgPSAvKiBAX19QVVJFX18gKi9uZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICBjb25zdCBwYXRoMiA9IGF3YWl0IGV4ZWN1dGUoYXJnLCBzY29wZSk7XG4gICAgaWYgKHBhdGgyLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHBhdGhTZXQuYWRkKHBhdGgyLmRhdGEpO1xuICAgIH0gZWxzZSBpZiAocGF0aDIuaXNBcnJheSgpKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgcGF0aDIpIHtcbiAgICAgICAgaWYgKGVsZW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHBhdGhTZXQuYWRkKGVsZW0uZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHBhdGhTZXQuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgfVxuICBjb25zdCBzY29wZVZhbHVlID0gYXdhaXQgc2NvcGUudmFsdWUuZ2V0KCk7XG4gIHJldHVybiBoYXNSZWZlcmVuY2Uoc2NvcGVWYWx1ZSwgcGF0aFNldCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG59O1xuX2dsb2JhbC5yZWZlcmVuY2VzLmFyaXR5ID0gYyA9PiBjID49IDE7XG5fZ2xvYmFsLnJvdW5kID0gYXN5bmMgZnVuY3Rpb24gcm91bmQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBjb25zdCBudW0gPSB2YWx1ZS5kYXRhO1xuICBsZXQgcHJlYyA9IDA7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IHByZWNWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICAgIGlmIChwcmVjVmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiB8fCBwcmVjVmFsdWUuZGF0YSA8IDAgfHwgIU51bWJlci5pc0ludGVnZXIocHJlY1ZhbHVlLmRhdGEpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcHJlYyA9IHByZWNWYWx1ZS5kYXRhO1xuICB9XG4gIGlmIChwcmVjID09PSAwKSB7XG4gICAgaWYgKG51bSA8IDApIHtcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKC1NYXRoLnJvdW5kKC1udW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21OdW1iZXIoTWF0aC5yb3VuZChudW0pKTtcbiAgfVxuICByZXR1cm4gZnJvbU51bWJlcihOdW1iZXIobnVtLnRvRml4ZWQocHJlYykpKTtcbn07XG5fZ2xvYmFsLnJvdW5kLmFyaXR5ID0gY291bnQyID0+IGNvdW50MiA+PSAxICYmIGNvdW50MiA8PSAyO1xuX2dsb2JhbC5ub3cgPSBhc3luYyBmdW5jdGlvbiBub3coYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC50aW1lc3RhbXAudG9JU09TdHJpbmcoKSk7XG59O1xuX2dsb2JhbC5ub3cuYXJpdHkgPSAwO1xuX2dsb2JhbC5ib29zdCA9IGFzeW5jIGZ1bmN0aW9uIGJvb3N0KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIGJvb3N0IGNhbGxcIik7XG59O1xuX2dsb2JhbC5ib29zdC5hcml0eSA9IDI7XG5jb25zdCBzdHJpbmcyID0ge307XG5zdHJpbmcyLmxvd2VyID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWx1ZS50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUuZGF0YS50b0xvd2VyQ2FzZSgpKTtcbn07XG5zdHJpbmcyLmxvd2VyLmFyaXR5ID0gMTtcbnN0cmluZzIudXBwZXIgPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZS5kYXRhLnRvVXBwZXJDYXNlKCkpO1xufTtcbnN0cmluZzIudXBwZXIuYXJpdHkgPSAxO1xuc3RyaW5nMi5zcGxpdCA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBzdHIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHN0ci50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgY29uc3Qgc2VwID0gYXdhaXQgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSk7XG4gIGlmIChzZXAudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGlmIChzdHIuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnJvbUpTKFtdKTtcbiAgfVxuICBpZiAoc2VwLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZyb21KUyhBcnJheS5mcm9tKHN0ci5kYXRhKSk7XG4gIH1cbiAgcmV0dXJuIGZyb21KUyhzdHIuZGF0YS5zcGxpdChzZXAuZGF0YSkpO1xufTtcbnN0cmluZzIuc3BsaXQuYXJpdHkgPSAyO1xuX2dsb2JhbC5sb3dlciA9IHN0cmluZzIubG93ZXI7XG5fZ2xvYmFsLnVwcGVyID0gc3RyaW5nMi51cHBlcjtcbnN0cmluZzIuc3RhcnRzV2l0aCA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBzdHIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHN0ci50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gYXdhaXQgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSk7XG4gIGlmIChwcmVmaXgudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBzdHIuZGF0YS5zdGFydHNXaXRoKHByZWZpeC5kYXRhKSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbn07XG5zdHJpbmcyLnN0YXJ0c1dpdGguYXJpdHkgPSAyO1xuY29uc3QgYXJyYXkgPSB7fTtcbmFycmF5LmpvaW4gPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGNvbnN0IHNlcCA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICBpZiAoc2VwLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgYnVmID0gXCJcIjtcbiAgbGV0IG5lZWRTZXAgPSBmYWxzZTtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgIGlmIChuZWVkU2VwKSB7XG4gICAgICBidWYgKz0gc2VwLmRhdGE7XG4gICAgfVxuICAgIHN3aXRjaCAoZWxlbS50eXBlKSB7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICAgIGJ1ZiArPSBcIlwiLmNvbmNhdChlbGVtLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBuZWVkU2VwID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZnJvbUpTKGJ1Zik7XG59O1xuYXJyYXkuam9pbi5hcml0eSA9IDI7XG5hcnJheS5jb21wYWN0ID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgICAgeWllbGQgZWxlbTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcbmFycmF5LmNvbXBhY3QuYXJpdHkgPSAxO1xuYXJyYXkudW5pcXVlID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGFkZGVkID0gLyogQF9fUFVSRV9fICovbmV3IFNldCgpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlciBvZiB2YWx1ZSkge1xuICAgICAgc3dpdGNoIChpdGVyLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgICAgIGlmICghYWRkZWQuaGFzKGl0ZXIuZGF0YSkpIHtcbiAgICAgICAgICAgIGFkZGVkLmFkZChpdGVyLmRhdGEpO1xuICAgICAgICAgICAgeWllbGQgaXRlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgeWllbGQgaXRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcbmFycmF5LnVuaXF1ZS5hcml0eSA9IDE7XG5jb25zdCBwdCA9IHt9O1xucHQudGV4dCA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBjb25zdCB0ZXh0ID0gYXdhaXQgcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSk7XG4gIGlmICh0ZXh0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIGZyb21TdHJpbmcodGV4dCk7XG59O1xucHQudGV4dC5hcml0eSA9IDE7XG5jb25zdCBzYW5pdHkgPSB7fTtcbnNhbml0eS5wcm9qZWN0SWQgPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUpIHtcbiAgaWYgKHNjb3BlLmNvbnRleHQuc2FuaXR5KSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5zYW5pdHkucHJvamVjdElkKTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5zYW5pdHkuZGF0YXNldCA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzLCBzY29wZSkge1xuICBpZiAoc2NvcGUuY29udGV4dC5zYW5pdHkpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnNhbml0eS5kYXRhc2V0KTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5jb25zdCBwaXBlRnVuY3Rpb25zID0ge307XG5waXBlRnVuY3Rpb25zLm9yZGVyID0gYXN5bmMgZnVuY3Rpb24gb3JkZXIoYmFzZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgYXdhaXQgdHJ1ZTtcbiAgaWYgKCFiYXNlLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGNvbnN0IG1hcHBlcnMgPSBbXTtcbiAgY29uc3QgZGlyZWN0aW9ucyA9IFtdO1xuICBsZXQgbiA9IDA7XG4gIGZvciAobGV0IG1hcHBlciBvZiBhcmdzKSB7XG4gICAgbGV0IGRpcmVjdGlvbiA9IFwiYXNjXCI7XG4gICAgaWYgKG1hcHBlci50eXBlID09PSBcIkRlc2NcIikge1xuICAgICAgZGlyZWN0aW9uID0gXCJkZXNjXCI7XG4gICAgICBtYXBwZXIgPSBtYXBwZXIuYmFzZTtcbiAgICB9IGVsc2UgaWYgKG1hcHBlci50eXBlID09PSBcIkFzY1wiKSB7XG4gICAgICBtYXBwZXIgPSBtYXBwZXIuYmFzZTtcbiAgICB9XG4gICAgbWFwcGVycy5wdXNoKG1hcHBlcik7XG4gICAgZGlyZWN0aW9ucy5wdXNoKGRpcmVjdGlvbik7XG4gICAgbisrO1xuICB9XG4gIGNvbnN0IGF1eCA9IFtdO1xuICBsZXQgaWR4ID0gMDtcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBiYXNlKSB7XG4gICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgIGNvbnN0IHR1cGxlID0gW2F3YWl0IHZhbHVlLmdldCgpLCBpZHhdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlKG1hcHBlcnNbaV0sIG5ld1Njb3BlKTtcbiAgICAgIHR1cGxlLnB1c2goYXdhaXQgcmVzdWx0LmdldCgpKTtcbiAgICB9XG4gICAgYXV4LnB1c2godHVwbGUpO1xuICAgIGlkeCsrO1xuICB9XG4gIGF1eC5zb3J0KChhVHVwbGUsIGJUdXBsZSkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsZXQgYyA9IHRvdGFsQ29tcGFyZShhVHVwbGVbaSArIDJdLCBiVHVwbGVbaSArIDJdKTtcbiAgICAgIGlmIChkaXJlY3Rpb25zW2ldID09PSBcImRlc2NcIikge1xuICAgICAgICBjID0gLWM7XG4gICAgICB9XG4gICAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFUdXBsZVsxXSAtIGJUdXBsZVsxXTtcbiAgfSk7XG4gIHJldHVybiBmcm9tSlMoYXV4Lm1hcCh2ID0+IHZbMF0pKTtcbn07XG5waXBlRnVuY3Rpb25zLm9yZGVyLmFyaXR5ID0gY291bnQyID0+IGNvdW50MiA+PSAxO1xucGlwZUZ1bmN0aW9ucy5zY29yZSA9IGFzeW5jIGZ1bmN0aW9uIHNjb3JlKGJhc2UsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGlmICghYmFzZS5pc0FycmF5KCkpIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCB1bmtub3duID0gW107XG4gIGNvbnN0IHNjb3JlZCA9IFtdO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGJhc2UpIHtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdW5rbm93bi5wdXNoKGF3YWl0IHZhbHVlLmdldCgpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgbGV0IHZhbHVlU2NvcmUgPSB0eXBlb2YgdmFsdWUuZGF0YS5fc2NvcmUgPT09IFwibnVtYmVyXCIgPyB2YWx1ZS5kYXRhLl9zY29yZSA6IDA7XG4gICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgdmFsdWVTY29yZSArPSBhd2FpdCBldmFsdWF0ZVNjb3JlKGFyZywgbmV3U2NvcGUsIGV4ZWN1dGUpO1xuICAgIH1cbiAgICBjb25zdCBuZXdPYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZS5kYXRhLCB7XG4gICAgICBfc2NvcmU6IHZhbHVlU2NvcmVcbiAgICB9KTtcbiAgICBzY29yZWQucHVzaChuZXdPYmplY3QpO1xuICB9XG4gIHNjb3JlZC5zb3J0KChhLCBiKSA9PiBiLl9zY29yZSAtIGEuX3Njb3JlKTtcbiAgcmV0dXJuIGZyb21KUyhzY29yZWQpO1xufTtcbnBpcGVGdW5jdGlvbnMuc2NvcmUuYXJpdHkgPSBjb3VudDIgPT4gY291bnQyID49IDE7XG5jb25zdCBkZWx0YSA9IHt9O1xuZGVsdGEub3BlcmF0aW9uID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlKSB7XG4gIGNvbnN0IGhhc0JlZm9yZSA9IHNjb3BlLmNvbnRleHQuYmVmb3JlICE9PSBudWxsO1xuICBjb25zdCBoYXNBZnRlciA9IHNjb3BlLmNvbnRleHQuYWZ0ZXIgIT09IG51bGw7XG4gIGlmIChoYXNCZWZvcmUgJiYgaGFzQWZ0ZXIpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhcInVwZGF0ZVwiKTtcbiAgfVxuICBpZiAoaGFzQWZ0ZXIpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhcImNyZWF0ZVwiKTtcbiAgfVxuICBpZiAoaGFzQmVmb3JlKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoXCJkZWxldGVcIik7XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuZGVsdGEuY2hhbmdlZEFueSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbmRlbHRhLmNoYW5nZWRBbnkuYXJpdHkgPSAxO1xuZGVsdGEuY2hhbmdlZEFueS5tb2RlID0gXCJkZWx0YVwiO1xuZGVsdGEuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kZWx0YS5jaGFuZ2VkT25seS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkT25seS5tb2RlID0gXCJkZWx0YVwiO1xuY29uc3QgZGlmZiA9IHt9O1xuZGlmZi5jaGFuZ2VkQW55ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZGlmZi5jaGFuZ2VkQW55LmFyaXR5ID0gMztcbmRpZmYuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kaWZmLmNoYW5nZWRPbmx5LmFyaXR5ID0gMztcbmNvbnN0IG1hdGggPSB7fTtcbm1hdGgubWluID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgbjtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgIGlmIChlbGVtLnR5cGUgPT09IFwibnVsbFwiKSBjb250aW51ZTtcbiAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKG4gPT09IHZvaWQgMCB8fCBlbGVtLmRhdGEgPCBuKSB7XG4gICAgICBuID0gZWxlbS5kYXRhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJvbUpTKG4pO1xufTtcbm1hdGgubWluLmFyaXR5ID0gMTtcbm1hdGgubWF4ID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgbjtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgIGlmIChlbGVtLnR5cGUgPT09IFwibnVsbFwiKSBjb250aW51ZTtcbiAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKG4gPT09IHZvaWQgMCB8fCBlbGVtLmRhdGEgPiBuKSB7XG4gICAgICBuID0gZWxlbS5kYXRhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJvbUpTKG4pO1xufTtcbm1hdGgubWF4LmFyaXR5ID0gMTtcbm1hdGguc3VtID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgbiA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpIHtcbiAgICBpZiAoZWxlbS50eXBlID09PSBcIm51bGxcIikgY29udGludWU7XG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIG4gKz0gZWxlbS5kYXRhO1xuICB9XG4gIHJldHVybiBmcm9tSlMobik7XG59O1xubWF0aC5zdW0uYXJpdHkgPSAxO1xubWF0aC5hdmcgPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGxldCBuID0gMDtcbiAgbGV0IGMgPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYXJyKSB7XG4gICAgaWYgKGVsZW0udHlwZSA9PT0gXCJudWxsXCIpIGNvbnRpbnVlO1xuICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBuICs9IGVsZW0uZGF0YTtcbiAgICBjKys7XG4gIH1cbiAgaWYgKGMgPT09IDApIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gZnJvbUpTKG4gLyBjKTtcbn07XG5tYXRoLmF2Zy5hcml0eSA9IDE7XG5jb25zdCBkYXRlVGltZTIgPSB7fTtcbmRhdGVUaW1lMi5ub3cgPSBhc3luYyBmdW5jdGlvbiBub3cyKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIHJldHVybiBmcm9tRGF0ZVRpbWUobmV3IERhdGVUaW1lKHNjb3BlLmNvbnRleHQudGltZXN0YW1wKSk7XG59O1xuZGF0ZVRpbWUyLm5vdy5hcml0eSA9IDA7XG5jb25zdCBuYW1lc3BhY2VzID0ge1xuICBnbG9iYWw6IF9nbG9iYWwsXG4gIHN0cmluZzogc3RyaW5nMixcbiAgYXJyYXksXG4gIHB0LFxuICBkZWx0YSxcbiAgZGlmZixcbiAgc2FuaXR5LFxuICBtYXRoLFxuICBkYXRlVGltZTogZGF0ZVRpbWUyXG59O1xudmFyIF9fZGVmUHJvcCQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQxKG9iaiwga2V5LCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlXG59KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkMShvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBNYXJrUHJvY2Vzc29yIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5nLCBtYXJrcywgcGFyc2VPcHRpb25zKSB7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwic3RyaW5nXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm1hcmtzXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImluZGV4XCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInBhcnNlT3B0aW9uc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJhbGxvd0Jvb3N0XCIsIGZhbHNlKTtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5wYXJzZU9wdGlvbnMgPSBwYXJzZU9wdGlvbnM7XG4gIH1cbiAgaGFzTWFyaygpIHtcbiAgICBsZXQgcG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHJldHVybiB0aGlzLmluZGV4ICsgcG9zIDwgdGhpcy5tYXJrcy5sZW5ndGg7XG4gIH1cbiAgZ2V0TWFyaygpIHtcbiAgICBsZXQgcG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHJldHVybiB0aGlzLm1hcmtzW3RoaXMuaW5kZXggKyBwb3NdO1xuICB9XG4gIHNoaWZ0KCkge1xuICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgfVxuICBwcm9jZXNzKHZpc2l0b3IpIHtcbiAgICBjb25zdCBtYXJrID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICB0aGlzLnNoaWZ0KCk7XG4gICAgY29uc3QgZnVuYyA9IHZpc2l0b3JbbWFyay5uYW1lXTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gaGFuZGxlcjogXCIuY29uY2F0KG1hcmsubmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5jYWxsKHZpc2l0b3IsIHRoaXMsIG1hcmspO1xuICB9XG4gIHByb2Nlc3NTdHJpbmcoKSB7XG4gICAgdGhpcy5zaGlmdCgpO1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgfVxuICBwcm9jZXNzU3RyaW5nRW5kKCkge1xuICAgIGNvbnN0IHByZXYgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXggLSAxXTtcbiAgICBjb25zdCBjdXJyID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICB0aGlzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHByZXYucG9zaXRpb24sIGN1cnIucG9zaXRpb24pO1xuICB9XG4gIHNsaWNlKGxlbikge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMubWFya3NbdGhpcy5pbmRleF0ucG9zaXRpb247XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHBvcywgcG9zICsgbGVuKTtcbiAgfVxufVxuY29uc3QgV1MgPSAvXihbXFx0XFxuXFx2XFxmXFxyIFxcdTAwODVcXHUwMEEwXXwoXFwvXFwvW15cXG5dKlxcbikpKy87XG5jb25zdCBOVU0gPSAvXlxcZCsvO1xuY29uc3QgSURFTlQgPSAvXlthLXpBLVpfXVthLXpBLVpfMC05XSovO1xuY29uc3QgUFJFQ19QQUlSID0gMTtcbmNvbnN0IFBSRUNfT1IgPSAyO1xuY29uc3QgUFJFQ19BTkQgPSAzO1xuY29uc3QgUFJFQ19DT01QID0gNDtcbmNvbnN0IFBSRUNfT1JERVIgPSA0O1xuY29uc3QgUFJFQ19BREQgPSA2O1xuY29uc3QgUFJFQ19TVUIgPSA2O1xuY29uc3QgUFJFQ19NVUwgPSA3O1xuY29uc3QgUFJFQ19ESVYgPSA3O1xuY29uc3QgUFJFQ19NT0QgPSA3O1xuY29uc3QgUFJFQ19QT1cgPSA4O1xuY29uc3QgUFJFQ19QT1MgPSAxMDtcbmNvbnN0IFBSRUNfTk9UID0gMTA7XG5jb25zdCBQUkVDX05FRyA9IDg7XG5mdW5jdGlvbiBwYXJzZSQxKHN0cikge1xuICBsZXQgcG9zID0gMDtcbiAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICBpZiAocG9zICE9PSBzdHIubGVuZ3RoKSB7XG4gICAgaWYgKHJlc3VsdC5mYWlsUG9zaXRpb24pIHtcbiAgICAgIHBvcyA9IHJlc3VsdC5mYWlsUG9zaXRpb24gLSAxO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgcG9zaXRpb246IHBvc1xuICAgIH07XG4gIH1cbiAgZGVsZXRlIHJlc3VsdC5wb3NpdGlvbjtcbiAgZGVsZXRlIHJlc3VsdC5mYWlsUG9zaXRpb247XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHIoc3RyLCBwb3MsIGxldmVsKSB7XG4gIGxldCBzdGFydFBvcyA9IHBvcztcbiAgbGV0IHRva2VuID0gc3RyW3Bvc107XG4gIGxldCBtYXJrcztcbiAgc3dpdGNoICh0b2tlbikge1xuICAgIGNhc2UgXCIrXCI6XG4gICAgICB7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19QT1MpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBbe1xuICAgICAgICAgIG5hbWU6IFwicG9zXCIsXG4gICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgIH1dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCItXCI6XG4gICAgICB7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19ORUcpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBbe1xuICAgICAgICAgIG5hbWU6IFwibmVnXCIsXG4gICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgIH1dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCIoXCI6XG4gICAgICB7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgMCk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pO1xuICAgICAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICAgICAgY2FzZSBcIixcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWFya3MgPSBbe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidHVwbGVcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICAgICAgfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKSBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInR1cGxlX2VuZFwiLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCIpXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICBtYXJrcyA9IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJncm91cFwiLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgICB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwiIVwiOlxuICAgICAge1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIFBSRUNfTk9UKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzID0gW3tcbiAgICAgICAgICBuYW1lOiBcIm5vdFwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwie1wiOlxuICAgICAge1xuICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBcIltcIjpcbiAgICAgIG1hcmtzID0gW3tcbiAgICAgICAgbmFtZTogXCJhcnJheVwiLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9XTtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgaWYgKHN0cltwb3NdICE9PSBcIl1cIikge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmIChzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gXCIuLi5cIikge1xuICAgICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICAgIG5hbWU6IFwiYXJyYXlfc3BsYXRcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHJlcyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgICAgaWYgKHJlcy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzLm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSByZXMucG9zaXRpb247XG4gICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKSBicmVhaztcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiXVwiKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0cltwb3NdID09PSBcIl1cIikge1xuICAgICAgICBwb3MrKztcbiAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgbmFtZTogXCJhcnJheV9lbmRcIixcbiAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIidcIjpcbiAgICBjYXNlICdcIic6XG4gICAgICB7XG4gICAgICAgIGxldCByZXN1bHQgPSBwYXJzZVN0cmluZyhzdHIsIHBvcyk7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwiXlwiOlxuICAgICAge1xuICAgICAgICBwb3MrKztcbiAgICAgICAgbWFya3MgPSBbXTtcbiAgICAgICAgd2hpbGUgKHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiXlwiKSB7XG4gICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImRibHBhcmVudFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgbmFtZTogXCJwYXJlbnRcIixcbiAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJAXCI6XG4gICAgICBtYXJrcyA9IFt7XG4gICAgICAgIG5hbWU6IFwidGhpc1wiLFxuICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgIH1dO1xuICAgICAgcG9zKys7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiKlwiOlxuICAgICAgbWFya3MgPSBbe1xuICAgICAgICBuYW1lOiBcImV2ZXJ5dGhpbmdcIixcbiAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICB9XTtcbiAgICAgIHBvcysrO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIiRcIjpcbiAgICAgIHtcbiAgICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIHBvcyArIDEsIElERU5UKTtcbiAgICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgICAgcG9zICs9IDEgKyBpZGVudExlbjtcbiAgICAgICAgICBtYXJrcyA9IFt7XG4gICAgICAgICAgICBuYW1lOiBcInBhcmFtXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImlkZW50XCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3MgKyAxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJpZGVudF9lbmRcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBsZXQgbnVtTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgICAgaWYgKG51bUxlbikge1xuICAgICAgICAgIHBvcyArPSBudW1MZW47XG4gICAgICAgICAgbGV0IG5hbWUgPSBcImludGVnZXJcIjtcbiAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiLlwiKSB7XG4gICAgICAgICAgICBsZXQgZnJhY0xlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBOVU0pO1xuICAgICAgICAgICAgaWYgKGZyYWNMZW4pIHtcbiAgICAgICAgICAgICAgbmFtZSA9IFwiZmxvYXRcIjtcbiAgICAgICAgICAgICAgcG9zICs9IDEgKyBmcmFjTGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiZVwiIHx8IHN0cltwb3NdID09PSBcIkVcIikge1xuICAgICAgICAgICAgbmFtZSA9IFwic2NpXCI7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIrXCIgfHwgc3RyW3Bvc10gPT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV4cExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIE5VTSk7XG4gICAgICAgICAgICBpZiAoIWV4cExlbikgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zICs9IGV4cExlbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFya3MgPSBbe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUgKyBcIl9lbmRcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICB9XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgICAgIGlmIChpZGVudExlbikge1xuICAgICAgICAgIHBvcyArPSBpZGVudExlbjtcbiAgICAgICAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICAgICAgICBjYXNlIFwiOlwiOlxuICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgc3RhcnRQb3MsIHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICAgICAgICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWFya3MgPSBbe1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJ0aGlzX2F0dHJcIixcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaWRlbnRcIixcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaWRlbnRfZW5kXCIsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuICBpZiAoIW1hcmtzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICB9O1xuICB9XG4gIGxldCBsaHNMZXZlbCA9IDEyO1xuICBsZXQgdHJhdjtcbiAgbG9vcDogd2hpbGUgKHRydWUpIHtcbiAgICBsZXQgaW5uZXJQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgIGlmIChpbm5lclBvcyA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgcG9zID0gaW5uZXJQb3M7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdHJhdiA9IHBhcnNlVHJhdmVyc2FsKHN0ciwgaW5uZXJQb3MpO1xuICAgIGlmICh0cmF2LnR5cGUgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgbmFtZTogXCJ0cmF2ZXJzZVwiLFxuICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgIH0pO1xuICAgICAgd2hpbGUgKHRyYXYudHlwZSA9PT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQodHJhdi5tYXJrcyk7XG4gICAgICAgIHBvcyA9IHRyYXYucG9zaXRpb247XG4gICAgICAgIHRyYXYgPSBwYXJzZVRyYXZlcnNhbChzdHIsIHNraXBXUyhzdHIsIHBvcykpO1xuICAgICAgfVxuICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgIG5hbWU6IFwidHJhdmVyc2FsX2VuZFwiLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgdG9rZW4yID0gc3RyW2lubmVyUG9zXTtcbiAgICBzd2l0Y2ggKHRva2VuMikge1xuICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAge1xuICAgICAgICAgIGxldCBuZXh0VG9rZW4gPSBzdHJbaW5uZXJQb3MgKyAxXTtcbiAgICAgICAgICBzd2l0Y2ggKG5leHRUb2tlbikge1xuICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfUEFJUiB8fCBsaHNMZXZlbCA8PSBQUkVDX1BBSVIpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfUEFJUik7XG4gICAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwicGFpclwiLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19QQUlSO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcImNvbXBcIixcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJvcFwiLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGlubmVyUG9zXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJvcF9lbmRcIixcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpbm5lclBvcyArIDJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0FERCB8fCBsaHNMZXZlbCA8IFBSRUNfQUREKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX0FERCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcImFkZFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19BREQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1NVQiB8fCBsaHNMZXZlbCA8IFBSRUNfU1VCKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX1NVQiArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcInN1YlwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19TVUI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09IFwiKlwiKSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1BPVyB8fCBsaHNMZXZlbCA8PSBQUkVDX1BPVykgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCByaHMyID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19QT1cpO1xuICAgICAgICAgICAgaWYgKHJoczIudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzMjtcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJoczIubWFya3MpO1xuICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICAgIG5hbWU6IFwicG93XCIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwb3MgPSByaHMyLnBvc2l0aW9uO1xuICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX1BPVztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX01VTCB8fCBsaHNMZXZlbCA8IFBSRUNfTVVMKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX01VTCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcIm11bFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19NVUw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0RJViB8fCBsaHNMZXZlbCA8IFBSRUNfRElWKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX0RJViArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcImRpdlwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19ESVY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX01PRCB8fCBsaHNMZXZlbCA8IFBSRUNfTU9EKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX01PRCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcIm1vZFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19NT0Q7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCI8XCI6XG4gICAgICBjYXNlIFwiPlwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgbmV4dFBvcyA9IGlubmVyUG9zICsgMTtcbiAgICAgICAgICBpZiAoc3RyW25leHRQb3NdID09PSBcIj1cIikge1xuICAgICAgICAgICAgbmV4dFBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgbmV4dFBvcyksIFBSRUNfQ09NUCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgbmFtZTogXCJjb21wXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwib3BcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBpbm5lclBvc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwib3BfZW5kXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogbmV4dFBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwifFwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdID09PSBcInxcIikge1xuICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19PUiB8fCBsaHNMZXZlbCA8IFBSRUNfT1IpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19PUiArIDEpO1xuICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICAgIG5hbWU6IFwib3JcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19PUjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxldmVsID4gMTEgfHwgbGhzTGV2ZWwgPCAxMSkgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCBpZGVudFBvcyA9IHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSk7XG4gICAgICAgICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgICAgICAgIGlmICghaWRlbnRMZW4pIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IGlkZW50UG9zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zID0gaWRlbnRQb3MgKyBpZGVudExlbjtcbiAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIoXCIgfHwgc3RyW3Bvc10gPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgaWRlbnRQb3MsIHBvcyk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpO1xuICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInBpcGVjYWxsXCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICAgICAgICAgIGxoc0xldmVsID0gMTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiJlwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdICE9IFwiJlwiKSBicmVhayBsb29wO1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQU5EIHx8IGxoc0xldmVsIDwgUFJFQ19BTkQpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfQU5EICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgIG5hbWU6IFwiYW5kXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0FORDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIiFcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSAhPT0gXCI9XCIpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcImNvbXBcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJvcFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IGlubmVyUG9zXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJvcF9lbmRcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBpbm5lclBvcyArIDJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChzdHIuc2xpY2UoaW5uZXJQb3MsIGlubmVyUG9zICsgNCkgIT09IFwiZGVzY1wiKSBicmVhayBsb29wO1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfT1JERVIgfHwgbGhzTGV2ZWwgPCBQUkVDX09SREVSKSBicmVhayBsb29wO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgbmFtZTogXCJkZXNjXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MgPSBpbm5lclBvcyArIDQ7XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX09SREVSO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiYVwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHN0ci5zbGljZShpbm5lclBvcywgaW5uZXJQb3MgKyAzKSAhPT0gXCJhc2NcIikgYnJlYWsgbG9vcDtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX09SREVSIHx8IGxoc0xldmVsIDwgUFJFQ19PUkRFUikgYnJlYWsgbG9vcDtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgIG5hbWU6IFwiYXNjXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MgPSBpbm5lclBvcyArIDM7XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX09SREVSO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgbGV0IGlkZW50ID0gcGFyc2VSZWdleFN0cihzdHIsIGlubmVyUG9zLCBJREVOVCk7XG4gICAgICAgICAgc3dpdGNoIChpZGVudCkge1xuICAgICAgICAgICAgY2FzZSBcImluXCI6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKSBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIGlubmVyUG9zICsgMik7XG4gICAgICAgICAgICAgICAgbGV0IGlzR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgICBpc0dyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2VQb3MgPSBwb3M7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gXCJpbmNfcmFuZ2VcIjtcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJbcG9zICsgMl0gPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImV4Y19yYW5nZVwiO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImluX3JhbmdlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByYW5nZVBvc1xuICAgICAgICAgICAgICAgICAgfSwgcmVzdWx0Lm1hcmtzLCByaHMubWFya3MpO1xuICAgICAgICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJjb21wXCIsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJvcFwiLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogaW5uZXJQb3NcbiAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJvcF9lbmRcIixcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGlubmVyUG9zICsgMlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNHcm91cCkge1xuICAgICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm1hdGNoXCI6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKSBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDUpLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiY29tcFwiLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIm9wXCIsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogaW5uZXJQb3NcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIm9wX2VuZFwiLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGlubmVyUG9zICsgNVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGxoc0xldmVsID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGZhaWxQb3NpdGlvbiA9ICh0cmF2ID09IG51bGwgPyB2b2lkIDAgOiB0cmF2LnR5cGUpID09PSBcImVycm9yXCIgJiYgdHJhdi5wb3NpdGlvbjtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICBtYXJrcyxcbiAgICBwb3NpdGlvbjogcG9zLFxuICAgIGZhaWxQb3NpdGlvblxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VUcmF2ZXJzYWwoc3RyLCBwb3MpIHtcbiAgbGV0IHN0YXJ0UG9zID0gcG9zO1xuICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgY2FzZSBcIi5cIjpcbiAgICAgIHtcbiAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgIGxldCBpZGVudFN0YXJ0ID0gcG9zO1xuICAgICAgICBsZXQgaWRlbnRMZW4yID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgICAgICBpZiAoIWlkZW50TGVuMikgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICB9O1xuICAgICAgICBwb3MgKz0gaWRlbnRMZW4yO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgIG1hcmtzOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJhdHRyX2FjY2Vzc1wiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJpZGVudFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IGlkZW50U3RhcnRcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImlkZW50X2VuZFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgIH1dLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlIFwiLVwiOlxuICAgICAgaWYgKHN0cltwb3MgKyAxXSAhPT0gXCI+XCIpIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgfTtcbiAgICAgIGxldCBtYXJrcyA9IFt7XG4gICAgICAgIG5hbWU6IFwiZGVyZWZcIixcbiAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICB9XTtcbiAgICAgIHBvcyArPSAyO1xuICAgICAgbGV0IGlkZW50UG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBpZGVudFBvcywgSURFTlQpO1xuICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgIHBvcyA9IGlkZW50UG9zICsgaWRlbnRMZW47XG4gICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IFwiZGVyZWZfYXR0clwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBpZGVudFBvc1xuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJpZGVudFwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBpZGVudFBvc1xuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJpZGVudF9lbmRcIixcbiAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1hcmtzLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9O1xuICAgIGNhc2UgXCJbXCI6XG4gICAgICB7XG4gICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiXVwiKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgbWFya3M6IFt7XG4gICAgICAgICAgICAgIG5hbWU6IFwiYXJyYXlfcG9zdGZpeFwiLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByYW5nZVBvcyA9IHBvcztcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICBsZXQgdHlwZSA9IFwiaW5jX3JhbmdlXCI7XG4gICAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcImV4Y19yYW5nZVwiO1xuICAgICAgICAgICAgcG9zICs9IDM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbik7XG4gICAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIl1cIikgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgIG1hcmtzOiBbe1xuICAgICAgICAgICAgICBuYW1lOiBcInNsaWNlXCIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBuYW1lOiB0eXBlLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogcmFuZ2VQb3NcbiAgICAgICAgICAgIH1dLmNvbmNhdChyZXN1bHQubWFya3MsIHJocy5tYXJrcyksXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIl1cIikgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgIG1hcmtzOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJzcXVhcmVfYnJhY2tldFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfV0uY29uY2F0KHJlc3VsdC5tYXJrcyksXG4gICAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlIFwifFwiOlxuICAgICAge1xuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIntcIikge1xuICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgcmVzdWx0Lm1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgbmFtZTogXCJwcm9qZWN0aW9uXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJ7XCI6XG4gICAgICB7XG4gICAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICByZXN1bHQubWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgbmFtZTogXCJwcm9qZWN0aW9uXCIsXG4gICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJlcnJvclwiLFxuICAgIHBvc2l0aW9uOiBwb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFtdO1xuICBtYXJrcy5wdXNoKHtcbiAgICBuYW1lOiBcImZ1bmNfY2FsbFwiLFxuICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICB9KTtcbiAgaWYgKHN0cltwb3NdID09PSBcIjpcIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiOlwiKSB7XG4gICAgbWFya3MucHVzaCh7XG4gICAgICBuYW1lOiBcIm5hbWVzcGFjZVwiLFxuICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgfSk7XG4gICAgbWFya3MucHVzaCh7XG4gICAgICBuYW1lOiBcImlkZW50XCIsXG4gICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImlkZW50X2VuZFwiLFxuICAgICAgcG9zaXRpb246IHBvc1xuICAgIH0pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xuICAgIGxldCBuYW1lTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgIGlmICghbmFtZUxlbikgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICB9O1xuICAgIG1hcmtzLnB1c2goe1xuICAgICAgbmFtZTogXCJpZGVudFwiLFxuICAgICAgcG9zaXRpb246IHBvc1xuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiaWRlbnRfZW5kXCIsXG4gICAgICBwb3NpdGlvbjogcG9zICsgbmFtZUxlblxuICAgIH0pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIG5hbWVMZW4pO1xuICAgIGlmIChzdHJbcG9zXSAhPT0gXCIoXCIpIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICBwb3NpdGlvbjogcG9zXG4gICAgfTtcbiAgICBwb3MrKztcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICB9IGVsc2Uge1xuICAgIG1hcmtzLnB1c2goe1xuICAgICAgbmFtZTogXCJpZGVudFwiLFxuICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgfSwge1xuICAgICAgbmFtZTogXCJpZGVudF9lbmRcIixcbiAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICB9KTtcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgfVxuICBsZXQgbGFzdFBvcyA9IHBvcztcbiAgaWYgKHN0cltwb3NdICE9PSBcIilcIikge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcbiAgICAgIGxhc3RQb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICAgICAgaWYgKHN0cltwb3NdICE9PSBcIixcIikgYnJlYWs7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIpXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICB9O1xuICB9XG4gIG1hcmtzLnB1c2goe1xuICAgIG5hbWU6IFwiZnVuY19hcmdzX2VuZFwiLFxuICAgIHBvc2l0aW9uOiBsYXN0UG9zXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgIG1hcmtzLFxuICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZU9iamVjdChzdHIsIHBvcykge1xuICBsZXQgbWFya3MgPSBbe1xuICAgIG5hbWU6IFwib2JqZWN0XCIsXG4gICAgcG9zaXRpb246IHBvc1xuICB9XTtcbiAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gIHdoaWxlIChzdHJbcG9zXSAhPT0gXCJ9XCIpIHtcbiAgICBsZXQgcGFpclBvcyA9IHBvcztcbiAgICBpZiAoc3RyLnNsaWNlKHBvcywgcG9zICsgMykgPT09IFwiLi4uXCIpIHtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpO1xuICAgICAgaWYgKHN0cltwb3NdICE9PSBcIn1cIiAmJiBzdHJbcG9zXSAhPT0gXCIsXCIpIHtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICBpZiAoZXhwci50eXBlID09PSBcImVycm9yXCIpIHJldHVybiBleHByO1xuICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBcIm9iamVjdF9zcGxhdFwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBwYWlyUG9zXG4gICAgICAgIH0pO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChleHByLm1hcmtzKTtcbiAgICAgICAgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IFwib2JqZWN0X3NwbGF0X3RoaXNcIixcbiAgICAgICAgICBwb3NpdGlvbjogcGFpclBvc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKGV4cHIudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gZXhwcjtcbiAgICAgIGxldCBuZXh0UG9zID0gc2tpcFdTKHN0ciwgZXhwci5wb3NpdGlvbik7XG4gICAgICBpZiAoZXhwci5tYXJrc1swXS5uYW1lID09PSBcInN0clwiICYmIHN0cltuZXh0UG9zXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgbmV4dFBvcyArIDEpLCAwKTtcbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHZhbHVlO1xuICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBcIm9iamVjdF9wYWlyXCIsXG4gICAgICAgICAgcG9zaXRpb246IHBhaXJQb3NcbiAgICAgICAgfSk7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MsIHZhbHVlLm1hcmtzKTtcbiAgICAgICAgcG9zID0gdmFsdWUucG9zaXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7XG4gICAgICAgICAgbmFtZTogXCJvYmplY3RfZXhwclwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgfSwgZXhwci5tYXJrcyk7XG4gICAgICAgIHBvcyA9IGV4cHIucG9zaXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgaWYgKHN0cltwb3NdICE9PSBcIixcIikgYnJlYWs7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gIH1cbiAgaWYgKHN0cltwb3NdICE9PSBcIn1cIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICBwb3NpdGlvbjogcG9zXG4gICAgfTtcbiAgfVxuICBwb3MrKztcbiAgbWFya3MucHVzaCh7XG4gICAgbmFtZTogXCJvYmplY3RfZW5kXCIsXG4gICAgcG9zaXRpb246IHBvc1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICBtYXJrcyxcbiAgICBwb3NpdGlvbjogcG9zXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIsIHBvcykge1xuICBsZXQgdG9rZW4gPSBzdHJbcG9zXTtcbiAgcG9zID0gcG9zICsgMTtcbiAgY29uc3QgbWFya3MgPSBbe1xuICAgIG5hbWU6IFwic3RyXCIsXG4gICAgcG9zaXRpb246IHBvc1xuICB9XTtcbiAgc3RyOiBmb3IgKDs7IHBvcysrKSB7XG4gICAgaWYgKHBvcyA+IHN0ci5sZW5ndGgpIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICBwb3NpdGlvbjogcG9zXG4gICAgfTtcbiAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICBjYXNlIHRva2VuOlxuICAgICAgICB7XG4gICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcInN0cl9lbmRcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBicmVhayBzdHI7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwic3RyX3BhdXNlXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHN0cltwb3MgKyAxXSA9PT0gXCJ1XCIpIHtcbiAgICAgICAgICAgIGlmIChzdHJbcG9zICsgMl0gPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidW5pY29kZV9oZXhcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zICsgM1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcG9zID0gc3RyLmluZGV4T2YoXCJ9XCIsIHBvcyArIDMpO1xuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInVuaWNvZGVfaGV4X2VuZFwiLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInVuaWNvZGVfaGV4XCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvcyArIDJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidW5pY29kZV9oZXhfZW5kXCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvcyArIDZcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHBvcyArPSA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgbmFtZTogXCJzaW5nbGVfZXNjYXBlXCIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwic3RyX3N0YXJ0XCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgbWFya3MsXG4gICAgcG9zaXRpb246IHBvc1xuICB9O1xufVxuZnVuY3Rpb24gc2tpcFdTKHN0ciwgcG9zKSB7XG4gIHJldHVybiBwb3MgKyBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBXUyk7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ2V4KHN0ciwgcG9zLCByZSkge1xuICBsZXQgbSA9IHJlLmV4ZWMoc3RyLnNsaWNlKHBvcykpO1xuICByZXR1cm4gbSA/IG1bMF0ubGVuZ3RoIDogMDtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVnZXhTdHIoc3RyLCBwb3MsIHJlKSB7XG4gIGxldCBtID0gcmUuZXhlYyhzdHIuc2xpY2UocG9zKSk7XG4gIHJldHVybiBtID8gbVswXSA6IG51bGw7XG59XG5mdW5jdGlvbiBqb2luKGEsIGIpIHtcbiAgcmV0dXJuIGJhc2UgPT4gYihhKGJhc2UpKTtcbn1cbmZ1bmN0aW9uIG1hcChpbm5lcikge1xuICByZXR1cm4gYmFzZSA9PiAoe1xuICAgIHR5cGU6IFwiTWFwXCIsXG4gICAgYmFzZSxcbiAgICBleHByOiBpbm5lcih7XG4gICAgICB0eXBlOiBcIlRoaXNcIlxuICAgIH0pXG4gIH0pO1xufVxuZnVuY3Rpb24gZmxhdE1hcChpbm5lcikge1xuICByZXR1cm4gYmFzZSA9PiAoe1xuICAgIHR5cGU6IFwiRmxhdE1hcFwiLFxuICAgIGJhc2UsXG4gICAgZXhwcjogaW5uZXIoe1xuICAgICAgdHlwZTogXCJUaGlzXCJcbiAgICB9KVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlQXJyYXkoYnVpbGQsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgIGJ1aWxkXG4gICAgfTtcbiAgfVxuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIG1hcChyaWdodC5idWlsZCkpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCBmbGF0TWFwKHJpZ2h0LmJ1aWxkKSlcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIuY29uY2F0KHJpZ2h0LnR5cGUpKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VQbGFpbihtYXBwZXIsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICB9O1xuICB9XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIuY29uY2F0KHJpZ2h0LnR5cGUpKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VFbGVtZW50KG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIH1cbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVByb2plY3Rpb24obWFwcGVyLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYi1iXCIsXG4gICAgICBidWlsZDogbWFwcGVyXG4gICAgfTtcbiAgfVxuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXAobWFwcGVyKSwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIuY29uY2F0KHJpZ2h0LnR5cGUpKTtcbiAgfVxufVxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlXG59KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IEVTQ0FQRV9TRVFVRU5DRSA9IHtcbiAgXCInXCI6IFwiJ1wiLFxuICAnXCInOiAnXCInLFxuICBcIlxcXFxcIjogXCJcXFxcXCIsXG4gIFwiL1wiOiBcIi9cIixcbiAgYjogXCJcXGJcIixcbiAgZjogXCJcXGZcIixcbiAgbjogXCJcXG5cIixcbiAgcjogXCJcXHJcIixcbiAgdDogXCJcdFwiXG59O1xuZnVuY3Rpb24gZXhwYW5kSGV4KHN0cikge1xuICBjb25zdCBjaGFyQ29kZSA9IHBhcnNlSW50KHN0ciwgMTYpO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG59XG5jbGFzcyBHcm9xUXVlcnlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibmFtZVwiLCBcIkdyb3FRdWVyeUVycm9yXCIpO1xuICB9XG59XG5jb25zdCBFWFBSX0JVSUxERVIgPSB7XG4gIGdyb3VwKHApIHtcbiAgICBjb25zdCBpbm5lciA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkdyb3VwXCIsXG4gICAgICBiYXNlOiBpbm5lclxuICAgIH07XG4gIH0sXG4gIGV2ZXJ5dGhpbmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiRXZlcnl0aGluZ1wiXG4gICAgfTtcbiAgfSxcbiAgdGhpcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJUaGlzXCJcbiAgICB9O1xuICB9LFxuICBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGFyZW50XCIsXG4gICAgICBuOiAxXG4gICAgfTtcbiAgfSxcbiAgZGJscGFyZW50KHApIHtcbiAgICBjb25zdCBuZXh0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGFyZW50XCIsXG4gICAgICBuOiBuZXh0Lm4gKyAxXG4gICAgfTtcbiAgfSxcbiAgdHJhdmVyc2UocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCB0cmF2ZXJzYWxMaXN0ID0gW107XG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHJhdmVyc2FsX2VuZFwiKSB7XG4gICAgICB0cmF2ZXJzYWxMaXN0LnB1c2gocC5wcm9jZXNzKFRSQVZFUlNFX0JVSUxERVIpKTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIGxldCB0cmF2ZXJzYWwgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSB0cmF2ZXJzYWxMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0cmF2ZXJzYWwgPSB0cmF2ZXJzYWxMaXN0W2ldKHRyYXZlcnNhbCk7XG4gICAgfVxuICAgIGlmIChiYXNlLnR5cGUgPT09IFwiRXZlcnl0aGluZ1wiIHx8IGJhc2UudHlwZSA9PT0gXCJBcnJheVwiIHx8IGJhc2UudHlwZSA9PT0gXCJQaXBlRnVuY0NhbGxcIikge1xuICAgICAgdHJhdmVyc2FsID0gdHJhdmVyc2VBcnJheSh2YWwgPT4gdmFsLCB0cmF2ZXJzYWwpO1xuICAgIH1cbiAgICBpZiAodHJhdmVyc2FsID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJCVUc6IHVuZXhwZWN0ZWQgZW1wdHkgdHJhdmVyc2FsXCIpO1xuICAgIHJldHVybiB0cmF2ZXJzYWwuYnVpbGQoYmFzZSk7XG4gIH0sXG4gIHRoaXNfYXR0cihwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIGlmIChuYW1lID09PSBcIm51bGxcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFwidHJ1ZVwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgfSxcbiAgbmVnKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTmVnXCIsXG4gICAgICBiYXNlXG4gICAgfTtcbiAgfSxcbiAgcG9zKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUG9zXCIsXG4gICAgICBiYXNlXG4gICAgfTtcbiAgfSxcbiAgYWRkKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIitcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIHN1YihwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCItXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBtdWwocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiKlwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgZGl2KHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIi9cIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG1vZChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIlXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBwb3cocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiKipcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIGNvbXAocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCBvcCA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcCxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIGluX3JhbmdlKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSBcImluY19yYW5nZVwiO1xuICAgIHAuc2hpZnQoKTtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJJblJhbmdlXCIsXG4gICAgICBiYXNlLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgaXNJbmNsdXNpdmVcbiAgICB9O1xuICB9LFxuICBzdHIocCkge1xuICAgIGxldCB2YWx1ZSA9IFwiXCI7XG4gICAgbG9vcDogd2hpbGUgKHAuaGFzTWFyaygpKSB7XG4gICAgICBjb25zdCBtYXJrID0gcC5nZXRNYXJrKCk7XG4gICAgICBzd2l0Y2ggKG1hcmsubmFtZSkge1xuICAgICAgICBjYXNlIFwic3RyX2VuZFwiOlxuICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgIGNhc2UgXCJzdHJfcGF1c2VcIjpcbiAgICAgICAgICB2YWx1ZSArPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0cl9zdGFydFwiOlxuICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNpbmdsZV9lc2NhcGVcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gcC5zbGljZSgxKTtcbiAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhbHVlICs9IEVTQ0FQRV9TRVFVRU5DRVtjaGFyXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcInVuaWNvZGVfaGV4XCI6XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIHZhbHVlICs9IGV4cGFuZEhleChwLnByb2Nlc3NTdHJpbmdFbmQoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCBtYXJrOiBcIi5jb25jYXQobWFyay5uYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0sXG4gIGludGVnZXIocCkge1xuICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgfTtcbiAgfSxcbiAgZmxvYXQocCkge1xuICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgfTtcbiAgfSxcbiAgc2NpKHApIHtcbiAgICBjb25zdCBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgIH07XG4gIH0sXG4gIG9iamVjdChwKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IFtdO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcIm9iamVjdF9lbmRcIikge1xuICAgICAgYXR0cmlidXRlcy5wdXNoKHAucHJvY2VzcyhPQkpFQ1RfQlVJTERFUikpO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0XCIsXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfTtcbiAgfSxcbiAgYXJyYXkocCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwiYXJyYXlfZW5kXCIpIHtcbiAgICAgIGxldCBpc1NwbGF0ID0gZmFsc2U7XG4gICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJhcnJheV9zcGxhdFwiKSB7XG4gICAgICAgIGlzU3BsYXQgPSB0cnVlO1xuICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgZWxlbWVudHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiQXJyYXlFbGVtZW50XCIsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpc1NwbGF0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkFycmF5XCIsXG4gICAgICBlbGVtZW50c1xuICAgIH07XG4gIH0sXG4gIHR1cGxlKHApIHtcbiAgICBjb25zdCBtZW1iZXJzID0gW107XG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHVwbGVfZW5kXCIpIHtcbiAgICAgIG1lbWJlcnMucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJUdXBsZVwiLFxuICAgICAgbWVtYmVyc1xuICAgIH07XG4gIH0sXG4gIGZ1bmNfY2FsbChwKSB7XG4gICAgbGV0IG5hbWVzcGFjZSA9IFwiZ2xvYmFsXCI7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwibmFtZXNwYWNlXCIpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICAgIG5hbWVzcGFjZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJnbG9iYWxcIiAmJiBuYW1lID09PSBcInNlbGVjdFwiKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFwiU2VsZWN0XCIsXG4gICAgICAgIGFsdGVybmF0aXZlczogW11cbiAgICAgIH07XG4gICAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJmdW5jX2FyZ3NfZW5kXCIpIHtcbiAgICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwicGFpclwiKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5mYWxsYmFjaykgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBhcmd1bWVudCB0byBzZWxlY3QoKVwiKTtcbiAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgY29uc3QgY29uZGl0aW9uID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICByZXN1bHQuYWx0ZXJuYXRpdmVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJTZWxlY3RBbHRlcm5hdGl2ZVwiLFxuICAgICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKSB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFyZ3VtZW50IHRvIHNlbGVjdCgpXCIpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgICAgcmVzdWx0LmZhbGxiYWNrID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHAuc2hpZnQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJmdW5jX2FyZ3NfZW5kXCIpIHtcbiAgICAgIGlmIChhcmd1bWVudFNob3VsZEJlU2VsZWN0b3IobmFtZXNwYWNlLCBuYW1lLCBhcmdzLmxlbmd0aCkpIHtcbiAgICAgICAgcC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpO1xuICAgICAgICBhcmdzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwiU2VsZWN0b3JcIlxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3MucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIChuYW1lID09PSBcImJlZm9yZVwiIHx8IG5hbWUgPT09IFwiYWZ0ZXJcIikpIHtcbiAgICAgIGlmIChwLnBhcnNlT3B0aW9ucy5tb2RlID09PSBcImRlbHRhXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcIkNvbnRleHRcIixcbiAgICAgICAgICBrZXk6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJnbG9iYWxcIiAmJiBuYW1lID09PSBcImJvb3N0XCIgJiYgIXAuYWxsb3dCb29zdCkgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBib29zdFwiKTtcbiAgICBjb25zdCBmdW5jcyA9IG5hbWVzcGFjZXNbbmFtZXNwYWNlXTtcbiAgICBpZiAoIWZ1bmNzKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJVbmRlZmluZWQgbmFtZXNwYWNlOiBcIi5jb25jYXQobmFtZXNwYWNlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZ1bmMgPSBmdW5jc1tuYW1lXTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBmdW5jdGlvbjogXCIuY29uY2F0KG5hbWUpKTtcbiAgICB9XG4gICAgaWYgKGZ1bmMuYXJpdHkgIT09IHZvaWQgMCkge1xuICAgICAgdmFsaWRhdGVBcml0eShuYW1lLCBmdW5jLmFyaXR5LCBhcmdzLmxlbmd0aCk7XG4gICAgfVxuICAgIGlmIChmdW5jLm1vZGUgIT09IHZvaWQgMCAmJiBmdW5jLm1vZGUgIT09IHAucGFyc2VPcHRpb25zLm1vZGUpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBmdW5jdGlvbjogXCIuY29uY2F0KG5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiRnVuY0NhbGxcIixcbiAgICAgIGZ1bmMsXG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBuYW1lLFxuICAgICAgYXJnc1xuICAgIH07XG4gIH0sXG4gIHBpcGVjYWxsKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcC5zaGlmdCgpO1xuICAgIGxldCBuYW1lc3BhY2UgPSBcImdsb2JhbFwiO1xuICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcIm5hbWVzcGFjZVwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZSAhPT0gXCJnbG9iYWxcIikge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiVW5kZWZpbmVkIG5hbWVzcGFjZTogXCIuY29uY2F0KG5hbWVzcGFjZSkpO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIGNvbnN0IG9sZEFsbG93Qm9vc3QgPSBwLmFsbG93Qm9vc3Q7XG4gICAgaWYgKG5hbWUgPT09IFwic2NvcmVcIikge1xuICAgICAgcC5hbGxvd0Jvb3N0ID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3QgbWFya05hbWUgPSBwLmdldE1hcmsoKS5uYW1lO1xuICAgICAgaWYgKG1hcmtOYW1lID09PSBcImZ1bmNfYXJnc19lbmRcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSBcIm9yZGVyXCIpIHtcbiAgICAgICAgaWYgKG1hcmtOYW1lID09PSBcImFzY1wiKSB7XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGFyZ3MucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcIkFzY1wiLFxuICAgICAgICAgICAgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXJrTmFtZSA9PT0gXCJkZXNjXCIpIHtcbiAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgYXJncy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiRGVzY1wiLFxuICAgICAgICAgICAgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXJncy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIHAuYWxsb3dCb29zdCA9IG9sZEFsbG93Qm9vc3Q7XG4gICAgY29uc3QgZnVuYyA9IHBpcGVGdW5jdGlvbnNbbmFtZV07XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJVbmRlZmluZWQgcGlwZSBmdW5jdGlvbjogXCIuY29uY2F0KG5hbWUpKTtcbiAgICB9XG4gICAgaWYgKGZ1bmMuYXJpdHkpIHtcbiAgICAgIHZhbGlkYXRlQXJpdHkobmFtZSwgZnVuYy5hcml0eSwgYXJncy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQaXBlRnVuY0NhbGxcIixcbiAgICAgIGZ1bmMsXG4gICAgICBiYXNlLFxuICAgICAgbmFtZSxcbiAgICAgIGFyZ3NcbiAgICB9O1xuICB9LFxuICBwYWlyKHApIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkID0+XCIpO1xuICB9LFxuICBhbmQocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkFuZFwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgb3IocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9yXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBub3QocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJOb3RcIixcbiAgICAgIGJhc2VcbiAgICB9O1xuICB9LFxuICBhc2MocCkge1xuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXNjXCIpO1xuICB9LFxuICBkZXNjKHApIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGRlc2NcIik7XG4gIH0sXG4gIHBhcmFtKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgaWYgKHAucGFyc2VPcHRpb25zLnBhcmFtcyAmJiBwLnBhcnNlT3B0aW9ucy5wYXJhbXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgICAgdmFsdWU6IHAucGFyc2VPcHRpb25zLnBhcmFtc1tuYW1lXVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGFyYW1ldGVyXCIsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IE9CSkVDVF9CVUlMREVSID0ge1xuICBvYmplY3RfZXhwcihwKSB7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwicGFpclwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBjb25zdCBjb25kaXRpb24gPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgIGNvbnN0IHZhbHVlMiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCIsXG4gICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiLFxuICAgICAgbmFtZTogZXh0cmFjdFByb3BlcnR5S2V5KHZhbHVlKSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0X3BhaXIocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBpZiAobmFtZS50eXBlICE9PSBcIlZhbHVlXCIpIHRocm93IG5ldyBFcnJvcihcIm5hbWUgbXVzdCBiZSBzdHJpbmdcIik7XG4gICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiLFxuICAgICAgbmFtZTogbmFtZS52YWx1ZSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0X3NwbGF0KHApIHtcbiAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdFNwbGF0XCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0sXG4gIG9iamVjdF9zcGxhdF90aGlzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdFNwbGF0XCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0eXBlOiBcIlRoaXNcIlxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5jb25zdCBUUkFWRVJTRV9CVUlMREVSID0ge1xuICBzcXVhcmVfYnJhY2tldChwKSB7XG4gICAgY29uc3QgZXhwciA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShleHByKTtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHJpZ2h0ID0+IHRyYXZlcnNlRWxlbWVudChiYXNlID0+ICh7XG4gICAgICAgIHR5cGU6IFwiQWNjZXNzRWxlbWVudFwiLFxuICAgICAgICBiYXNlLFxuICAgICAgICBpbmRleDogdmFsdWUuZGF0YVxuICAgICAgfSksIHJpZ2h0KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiByaWdodCA9PiB0cmF2ZXJzZVBsYWluKGJhc2UgPT4gKHtcbiAgICAgICAgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIixcbiAgICAgICAgYmFzZSxcbiAgICAgICAgbmFtZTogdmFsdWUuZGF0YVxuICAgICAgfSksIHJpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJpZ2h0ID0+IHRyYXZlcnNlQXJyYXkoYmFzZSA9PiAoe1xuICAgICAgdHlwZTogXCJGaWx0ZXJcIixcbiAgICAgIGJhc2UsXG4gICAgICBleHByXG4gICAgfSksIHJpZ2h0KTtcbiAgfSxcbiAgc2xpY2UocCkge1xuICAgIGNvbnN0IGlzSW5jbHVzaXZlID0gcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJpbmNfcmFuZ2VcIjtcbiAgICBwLnNoaWZ0KCk7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShsZWZ0KTtcbiAgICBjb25zdCByaWdodFZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShyaWdodCk7XG4gICAgaWYgKCFsZWZ0VmFsdWUgfHwgIXJpZ2h0VmFsdWUgfHwgbGVmdFZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJzbGljaW5nIG11c3QgdXNlIGNvbnN0YW50IG51bWJlcnNcIik7XG4gICAgfVxuICAgIHJldHVybiByaHMgPT4gdHJhdmVyc2VBcnJheShiYXNlID0+ICh7XG4gICAgICB0eXBlOiBcIlNsaWNlXCIsXG4gICAgICBiYXNlLFxuICAgICAgbGVmdDogbGVmdFZhbHVlLmRhdGEsXG4gICAgICByaWdodDogcmlnaHRWYWx1ZS5kYXRhLFxuICAgICAgaXNJbmNsdXNpdmVcbiAgICB9KSwgcmhzKTtcbiAgfSxcbiAgcHJvamVjdGlvbihwKSB7XG4gICAgY29uc3Qgb2JqID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHJpZ2h0ID0+IHRyYXZlcnNlUHJvamVjdGlvbihiYXNlID0+ICh7XG4gICAgICB0eXBlOiBcIlByb2plY3Rpb25cIixcbiAgICAgIGJhc2UsXG4gICAgICBleHByOiBvYmpcbiAgICB9KSwgcmlnaHQpO1xuICB9LFxuICBhdHRyX2FjY2VzcyhwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIHJldHVybiByaWdodCA9PiB0cmF2ZXJzZVBsYWluKGJhc2UgPT4gKHtcbiAgICAgIHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsXG4gICAgICBiYXNlLFxuICAgICAgbmFtZVxuICAgIH0pLCByaWdodCk7XG4gIH0sXG4gIGRlcmVmKHApIHtcbiAgICBsZXQgYXR0ciA9IG51bGw7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiZGVyZWZfYXR0clwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBhdHRyID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IHdyYXAgPSBiYXNlID0+IGF0dHIgPyB7XG4gICAgICB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLFxuICAgICAgYmFzZSxcbiAgICAgIG5hbWU6IGF0dHJcbiAgICB9IDogYmFzZTtcbiAgICByZXR1cm4gcmlnaHQgPT4gdHJhdmVyc2VQbGFpbihiYXNlID0+IHdyYXAoe1xuICAgICAgdHlwZTogXCJEZXJlZlwiLFxuICAgICAgYmFzZVxuICAgIH0pLCByaWdodCk7XG4gIH0sXG4gIGFycmF5X3Bvc3RmaXgocCkge1xuICAgIHJldHVybiByaWdodCA9PiB0cmF2ZXJzZUFycmF5KGJhc2UgPT4gKHtcbiAgICAgIHR5cGU6IFwiQXJyYXlDb2VyY2VcIixcbiAgICAgIGJhc2VcbiAgICB9KSwgcmlnaHQpO1xuICB9XG59O1xuY29uc3QgU0VMRUNUT1JfQlVJTERFUiA9IHtcbiAgZ3JvdXAocCkge1xuICAgIHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgZXZlcnl0aGluZygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgdGhpcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGFyZW50KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBkYmxwYXJlbnQocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICB0cmF2ZXJzZShwKSB7XG4gICAgcC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcInRyYXZlcnNhbF9lbmRcIikge1xuICAgICAgcC5wcm9jZXNzKFRSQVZFUlNFX0JVSUxERVIpO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHRoaXNfYXR0cihwKSB7XG4gICAgcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIG5lZyhwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBvcyhwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGFkZChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHN1YihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG11bChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGRpdihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG1vZChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBvdyhwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGNvbXAocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBpbl9yYW5nZShwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHN0cihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGludGVnZXIocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBmbG9hdChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHNjaShwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG9iamVjdChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGFycmF5KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgdHVwbGUocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBmdW5jX2NhbGwocCwgbWFyaykge1xuICAgIGNvbnN0IGZ1bmMgPSBFWFBSX0JVSUxERVIuZnVuY19jYWxsKHAsIG1hcmspO1xuICAgIGlmIChmdW5jLm5hbWUgPT09IFwiYW55d2hlcmVcIiAmJiBmdW5jLmFyZ3MubGVuZ3RoID09PSAxKSByZXR1cm4gbnVsbDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGlwZWNhbGwocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwYWlyKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYW5kKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgb3IocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBub3QocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBhc2MocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBkZXNjKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGFyYW0ocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9XG59O1xuZnVuY3Rpb24gZXh0cmFjdFByb3BlcnR5S2V5KG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJBY2Nlc3NBdHRyaWJ1dGVcIiAmJiAhbm9kZS5iYXNlKSB7XG4gICAgcmV0dXJuIG5vZGUubmFtZTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSBcIkRlcmVmXCIgfHwgbm9kZS50eXBlID09PSBcIk1hcFwiIHx8IG5vZGUudHlwZSA9PT0gXCJQcm9qZWN0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlNsaWNlXCIgfHwgbm9kZS50eXBlID09PSBcIkZpbHRlclwiIHx8IG5vZGUudHlwZSA9PT0gXCJBY2Nlc3NFbGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIkFycmF5Q29lcmNlXCIpIHtcbiAgICByZXR1cm4gZXh0cmFjdFByb3BlcnR5S2V5KG5vZGUuYmFzZSk7XG4gIH1cbiAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiQ2Fubm90IGRldGVybWluZSBwcm9wZXJ0eSBrZXkgZm9yIHR5cGU6IFwiLmNvbmNhdChub2RlLnR5cGUpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQXJpdHkobmFtZSwgYXJpdHksIGNvdW50KSB7XG4gIGlmICh0eXBlb2YgYXJpdHkgPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoY291bnQgIT09IGFyaXR5KSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiBcIi5jb25jYXQobmFtZSwgXCIoKS4gRXhwZWN0ZWQgXCIpLmNvbmNhdChhcml0eSwgXCIsIGdvdCBcIikuY29uY2F0KGNvdW50LCBcIi5cIikpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcml0eSkge1xuICAgIGlmICghYXJpdHkoY291bnQpKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiBcIi5jb25jYXQobmFtZSwgXCIoKS5cIikpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXJndW1lbnRTaG91bGRCZVNlbGVjdG9yKG5hbWVzcGFjZSwgZnVuY3Rpb25OYW1lLCBhcmdDb3VudCkge1xuICBjb25zdCBmdW5jdGlvbnNSZXF1aXJpbmdTZWxlY3RvcnMgPSBbXCJjaGFuZ2VkQW55XCIsIFwiY2hhbmdlZE9ubHlcIl07XG4gIHJldHVybiBuYW1lc3BhY2UgPT0gXCJkaWZmXCIgJiYgYXJnQ291bnQgPT0gMiAmJiBmdW5jdGlvbnNSZXF1aXJpbmdTZWxlY3RvcnMuaW5jbHVkZXMoZnVuY3Rpb25OYW1lKTtcbn1cbmNsYXNzIEdyb3FTeW50YXhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocG9zaXRpb24pIHtcbiAgICBzdXBlcihcIlN5bnRheCBlcnJvciBpbiBHUk9RIHF1ZXJ5IGF0IHBvc2l0aW9uIFwiLmNvbmNhdChwb3NpdGlvbikpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwb3NpdGlvblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibmFtZVwiLCBcIkdyb3FTeW50YXhFcnJvclwiKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgY29uc3QgcmVzdWx0ID0gcGFyc2UkMShpbnB1dCk7XG4gIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgdGhyb3cgbmV3IEdyb3FTeW50YXhFcnJvcihyZXN1bHQucG9zaXRpb24pO1xuICB9XG4gIGNvbnN0IHByb2Nlc3NvciA9IG5ldyBNYXJrUHJvY2Vzc29yKGlucHV0LCByZXN1bHQubWFya3MsIG9wdGlvbnMpO1xuICByZXR1cm4gcHJvY2Vzc29yLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbn1cbmV4cG9ydHMuRGF0ZVRpbWUgPSBEYXRlVGltZTtcbmV4cG9ydHMuZXZhbHVhdGUgPSBldmFsdWF0ZVF1ZXJ5O1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9MS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl9fZGVmUHJvcCQ1IiwiX19kZWZOb3JtYWxQcm9wJDUiLCJvYmoiLCJrZXkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX3B1YmxpY0ZpZWxkJDUiLCJlc2NhcGVSZWdFeHAiLCJzdHJpbmciLCJyZXBsYWNlIiwicGF0aFJlZ0V4cCIsInBhdHRlcm4iLCJyZSIsInBhcnQiLCJzcGxpdCIsInB1c2giLCJSZWdFeHAiLCJjb25jYXQiLCJqb2luIiwiUGF0aCIsImNvbnN0cnVjdG9yIiwicGF0dGVyblJlIiwibWF0Y2hlcyIsInN0ciIsInRlc3QiLCJ0b0pTT04iLCJfX2RlZlByb3AkNCIsIl9fZGVmTm9ybWFsUHJvcCQ0IiwiX19wdWJsaWNGaWVsZCQ0IiwiU3RyZWFtVmFsdWUiLCJnZW5lcmF0b3IiLCJ0aWNrZXIiLCJpc0RvbmUiLCJkYXRhIiwiaXNBcnJheSIsImdldCIsInJlc3VsdCIsIlN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJpIiwibGVuZ3RoIiwiX25leHRUaWNrIiwiY3VycmVudFJlc29sdmVyIiwic2V0dXBUaWNrZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRpY2siLCJmZXRjaCIsIlJGQzMzMzlfUkVHRVgiLCJwYXJzZVJGQzMzMzkiLCJEYXRlIiwiZm9ybWF0UkZDMzMzOSIsImQiLCJ5ZWFyIiwiYWRkTGVhZGluZ1plcm8iLCJnZXRVVENGdWxsWWVhciIsIm1vbnRoIiwiZ2V0VVRDTW9udGgiLCJkYXkiLCJnZXRVVENEYXRlIiwiaG91ciIsImdldFVUQ0hvdXJzIiwibWludXRlIiwiZ2V0VVRDTWludXRlcyIsInNlY29uZCIsImdldFVUQ1NlY29uZHMiLCJmcmFjdGlvbmFsU2Vjb25kIiwibWlsbGlzIiwiZ2V0TWlsbGlzZWNvbmRzIiwibnVtIiwidGFyZ2V0TGVuZ3RoIiwidG9TdHJpbmciLCJfX2RlZlByb3AkMyIsIl9fZGVmTm9ybWFsUHJvcCQzIiwiX19wdWJsaWNGaWVsZCQzIiwiU3RhdGljVmFsdWUiLCJ0eXBlIiwiQXJyYXkiLCJlbGVtZW50IiwiZnJvbUpTIiwiRXJyb3IiLCJOVUxMX1ZBTFVFIiwiVFJVRV9WQUxVRSIsIkZBTFNFX1ZBTFVFIiwiRGF0ZVRpbWUiLCJkYXRlIiwicGFyc2VUb1ZhbHVlIiwiZXF1YWxzIiwib3RoZXIiLCJnZXRUaW1lIiwiYWRkIiwic2VjcyIsImNvcHkiLCJzZXRUaW1lIiwiZGlmZmVyZW5jZSIsImNvbXBhcmVUbyIsImZyb21OdW1iZXIiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImZyb21TdHJpbmciLCJmcm9tRGF0ZVRpbWUiLCJkdCIsImZyb21QYXRoIiwicGF0aCIsImlzSXRlcmF0b3IiLCJuZXh0IiwidmFsIiwiZ2V0VHlwZSIsImlzRXF1YWwiLCJhIiwiYiIsIkNIQVJTIiwiQ0hBUlNfV0lUSF9XSUxEQ0FSRCIsIkVER0VfQ0hBUlMiLCJNQVhfVEVSTV9MRU5HVEgiLCJtYXRjaFRleHQiLCJ0b2tlbnMiLCJwYXR0ZXJucyIsImV2ZXJ5IiwibWF0Y2hUb2tlbml6ZSIsInRleHQiLCJtYXRjaCIsIm1hdGNoQW5hbHl6ZVBhdHRlcm4iLCJ0ZXJtc1JlIiwibWF0Y2hQYXR0ZXJuUmVnZXgiLCJtYXAiLCJzb21lIiwidG9rZW4iLCJ0ZXJtcyIsInRlcm0iLCJzbGljZSIsImdhdGhlclRleHQiLCJjYiIsInN1Y2Nlc3MiLCJUWVBFX09SREVSIiwiZGF0ZXRpbWUiLCJudW1iZXIiLCJib29sZWFuIiwicGFydGlhbENvbXBhcmUiLCJhVHlwZSIsImJUeXBlIiwidG90YWxDb21wYXJlIiwiYVR5cGVPcmRlciIsImJUeXBlT3JkZXIiLCJvcGVyYXRvcnMiLCJlcSIsImxlZnQiLCJyaWdodCIsIm5lcSIsImd0IiwiZ3RlIiwibHQiLCJsdGUiLCJpbiIsImlub3AiLCJkaWRTdWNjZWVkIiwibWF0Y2hlZCIsInBsdXMiLCJtaW51cyIsIm51bWVyaWNPcGVyYXRvciIsIk1hdGgiLCJwb3ciLCJpbXBsIiwiX19kZWZQcm9wJDIiLCJfX2RlZk5vcm1hbFByb3AkMiIsIl9fcHVibGljRmllbGQkMiIsIlNjb3BlIiwicGFyYW1zIiwic291cmNlIiwiY29udGV4dCIsInBhcmVudCIsImNyZWF0ZU5lc3RlZCIsImlzSGlkZGVuIiwiY3JlYXRlSGlkZGVuIiwiZXZhbHVhdGUiLCJub2RlIiwic2NvcGUiLCJleGVjdXRlIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwiZnVuYyIsIkVYRUNVVE9SUyIsInByb21pc2VsZXNzQXBwbHkiLCJ0aGVuIiwiVGhpcyIsIl8iLCJTZWxlY3RvciIsIkV2ZXJ5dGhpbmciLCJQYXJhbWV0ZXIiLCJfcmVmIiwibmFtZSIsIkNvbnRleHQiLCJfcmVmMiIsIlBhcmVudCIsIl9yZWYzIiwibiIsImN1cnJlbnQiLCJPcENhbGwiLCJfcmVmNCIsIm9wIiwibGVmdFZhbHVlIiwicmlnaHRWYWx1ZSIsIlNlbGVjdCIsIl9yZWY1IiwiYWx0ZXJuYXRpdmVzIiwiZmFsbGJhY2siLCJhbHQiLCJhbHRDb25kIiwiY29uZGl0aW9uIiwiSW5SYW5nZSIsIl9yZWY2IiwiYmFzZSIsImlzSW5jbHVzaXZlIiwibGVmdENtcCIsInJpZ2h0Q21wIiwiRmlsdGVyIiwiX3JlZjciLCJleHByIiwiYmFzZVZhbHVlIiwiZWxlbSIsIm5ld1Njb3BlIiwiZXhwclZhbHVlIiwiUHJvamVjdGlvbiIsIl9yZWY4IiwiRnVuY0NhbGwiLCJfcmVmOSIsImFyZ3MiLCJQaXBlRnVuY0NhbGwiLCJfcmVmMTAiLCJBY2Nlc3NBdHRyaWJ1dGUiLCJfcmVmMTEiLCJoYXNPd25Qcm9wZXJ0eSIsIkFjY2Vzc0VsZW1lbnQiLCJfcmVmMTIiLCJpbmRleCIsImZpbmFsSW5kZXgiLCJTbGljZSIsIl9yZWYxMyIsImFycmF5IiwibGVmdElkeCIsInJpZ2h0SWR4IiwiRGVyZWYiLCJfcmVmMTQiLCJpZCIsImRlcmVmZXJlbmNlIiwiZG9jIiwiX2lkIiwiVmFsdWUiLCJfcmVmMTUiLCJHcm91cCIsIl9yZWYxNiIsIl9yZWYxNyIsImF0dHJpYnV0ZXMiLCJhdHRyIiwiYXR0clR5cGUiLCJjb25kIiwiYXNzaWduIiwiX3JlZjE4IiwiZWxlbWVudHMiLCJpc1NwbGF0IiwidiIsIlR1cGxlIiwiT3IiLCJfcmVmMTkiLCJBbmQiLCJfcmVmMjAiLCJOb3QiLCJfcmVmMjEiLCJOZWciLCJfcmVmMjIiLCJQb3MiLCJfcmVmMjMiLCJBc2MiLCJEZXNjIiwiQXJyYXlDb2VyY2UiLCJfcmVmMjQiLCJNYXAiLCJfcmVmMjUiLCJGbGF0TWFwIiwiX3JlZjI2IiwiaW5uZXJWYWx1ZSIsImlubmVyIiwiZXZhbHVhdGVRdWVyeSIsInRyZWUiLCJvcHRpb25zIiwicm9vdCIsImRhdGFzZXQiLCJ0aW1lc3RhbXAiLCJpZGVudGl0eSIsInNhbml0eSIsImFmdGVyIiwiYmVmb3JlIiwiY2FuQ29uc3RhbnRFdmFsdWF0ZSIsIkRVTU1ZX1NDT1BFIiwidHJ5Q29uc3RhbnRFdmFsdWF0ZSIsImNvbnN0YW50RXZhbHVhdGUiLCJwb3J0YWJsZVRleHRDb250ZW50IiwiYmxvY2tUZXh0IiwidGV4dHMiLCJhcnJheVRleHQiLCJibG9jayIsIl90eXBlIiwiY2hpbGRyZW4iLCJjaGlsZCIsIkJNMjVrIiwiZXZhbHVhdGVTY29yZSIsImV2YWx1YXRlTWF0Y2hTY29yZSIsImlubmVyU2NvcmUiLCJib29zdCIsImxlZnRTY29yZSIsInJpZ2h0U2NvcmUiLCJyZXMiLCJzY29yZSIsImZyZXEiLCJyZWR1Y2UiLCJjIiwiaGFzUmVmZXJlbmNlIiwicGF0aFNldCIsImhhcyIsInZhbHVlcyIsImNvdW50VVRGOCIsImNvdW50MiIsImNvZGUiLCJjaGFyQ29kZUF0IiwiX2dsb2JhbCIsImFueXdoZXJlIiwiYXJpdHkiLCJjb2FsZXNjZSIsImFyZyIsImNvdW50IiwiZGF0ZVRpbWUiLCJkZWZpbmVkIiwicmVmZXJlbmNlcyIsIlNldCIsInBhdGgyIiwic2l6ZSIsInNjb3BlVmFsdWUiLCJyb3VuZCIsInByZWMiLCJwcmVjVmFsdWUiLCJpc0ludGVnZXIiLCJ0b0ZpeGVkIiwibm93IiwidG9JU09TdHJpbmciLCJzdHJpbmcyIiwibG93ZXIiLCJ0b0xvd2VyQ2FzZSIsInVwcGVyIiwidG9VcHBlckNhc2UiLCJzZXAiLCJmcm9tIiwic3RhcnRzV2l0aCIsInByZWZpeCIsImFyciIsImJ1ZiIsIm5lZWRTZXAiLCJjb21wYWN0IiwidW5pcXVlIiwiYWRkZWQiLCJpdGVyIiwicHQiLCJwcm9qZWN0SWQiLCJwaXBlRnVuY3Rpb25zIiwib3JkZXIiLCJtYXBwZXJzIiwiZGlyZWN0aW9ucyIsIm1hcHBlciIsImRpcmVjdGlvbiIsImF1eCIsImlkeCIsInR1cGxlIiwic29ydCIsImFUdXBsZSIsImJUdXBsZSIsInVua25vd24iLCJzY29yZWQiLCJ2YWx1ZVNjb3JlIiwiX3Njb3JlIiwibmV3T2JqZWN0IiwiZGVsdGEiLCJvcGVyYXRpb24iLCJoYXNCZWZvcmUiLCJoYXNBZnRlciIsImNoYW5nZWRBbnkiLCJtb2RlIiwiY2hhbmdlZE9ubHkiLCJkaWZmIiwibWF0aCIsIm1pbiIsIm1heCIsInN1bSIsImF2ZyIsImRhdGVUaW1lMiIsIm5vdzIiLCJuYW1lc3BhY2VzIiwiZ2xvYmFsIiwiX19kZWZQcm9wJDEiLCJfX2RlZk5vcm1hbFByb3AkMSIsIl9fcHVibGljRmllbGQkMSIsIk1hcmtQcm9jZXNzb3IiLCJtYXJrcyIsInBhcnNlT3B0aW9ucyIsImhhc01hcmsiLCJwb3MiLCJnZXRNYXJrIiwic2hpZnQiLCJwcm9jZXNzIiwidmlzaXRvciIsIm1hcmsiLCJjYWxsIiwicHJvY2Vzc1N0cmluZyIsInByb2Nlc3NTdHJpbmdFbmQiLCJwcmV2IiwiY3VyciIsInBvc2l0aW9uIiwibGVuIiwiV1MiLCJOVU0iLCJJREVOVCIsIlBSRUNfUEFJUiIsIlBSRUNfT1IiLCJQUkVDX0FORCIsIlBSRUNfQ09NUCIsIlBSRUNfT1JERVIiLCJQUkVDX0FERCIsIlBSRUNfU1VCIiwiUFJFQ19NVUwiLCJQUkVDX0RJViIsIlBSRUNfTU9EIiwiUFJFQ19QT1ciLCJQUkVDX1BPUyIsIlBSRUNfTk9UIiwiUFJFQ19ORUciLCJwYXJzZSQxIiwic2tpcFdTIiwicGFyc2VFeHByIiwiZmFpbFBvc2l0aW9uIiwibGV2ZWwiLCJzdGFydFBvcyIsInJocyIsInBhcnNlT2JqZWN0IiwicGFyc2VTdHJpbmciLCJpZGVudExlbiIsInBhcnNlUmVnZXgiLCJudW1MZW4iLCJmcmFjTGVuIiwiZXhwTGVuIiwicGFyc2VGdW5jQ2FsbCIsImxoc0xldmVsIiwidHJhdiIsImxvb3AiLCJpbm5lclBvcyIsInBhcnNlVHJhdmVyc2FsIiwidW5zaGlmdCIsInRva2VuMiIsIm5leHRUb2tlbiIsInJoczIiLCJuZXh0UG9zIiwiaWRlbnRQb3MiLCJpZGVudCIsInBhcnNlUmVnZXhTdHIiLCJpc0dyb3VwIiwicmFuZ2VQb3MiLCJpZGVudFN0YXJ0IiwiaWRlbnRMZW4yIiwibmFtZUxlbiIsImxhc3RQb3MiLCJwYWlyUG9zIiwiaW5kZXhPZiIsIm0iLCJleGVjIiwiZmxhdE1hcCIsInRyYXZlcnNlQXJyYXkiLCJidWlsZCIsInRyYXZlcnNlUGxhaW4iLCJ0cmF2ZXJzZUVsZW1lbnQiLCJ0cmF2ZXJzZVByb2plY3Rpb24iLCJfX2RlZlByb3AiLCJfX2RlZk5vcm1hbFByb3AiLCJfX3B1YmxpY0ZpZWxkIiwiRVNDQVBFX1NFUVVFTkNFIiwiZiIsInIiLCJ0IiwiZXhwYW5kSGV4IiwiY2hhckNvZGUiLCJwYXJzZUludCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIkdyb3FRdWVyeUVycm9yIiwiRVhQUl9CVUlMREVSIiwiZ3JvdXAiLCJwIiwiZXZlcnl0aGluZyIsInRoaXMiLCJkYmxwYXJlbnQiLCJ0cmF2ZXJzZSIsInRyYXZlcnNhbExpc3QiLCJUUkFWRVJTRV9CVUlMREVSIiwidHJhdmVyc2FsIiwidGhpc19hdHRyIiwibmVnIiwic3ViIiwibXVsIiwiZGl2IiwibW9kIiwiY29tcCIsImluX3JhbmdlIiwiY2hhciIsImludGVnZXIiLCJzdHJWYWx1ZSIsImZsb2F0Iiwic2NpIiwib2JqZWN0IiwiT0JKRUNUX0JVSUxERVIiLCJtZW1iZXJzIiwiZnVuY19jYWxsIiwibmFtZXNwYWNlIiwiYXJndW1lbnRTaG91bGRCZVNlbGVjdG9yIiwiU0VMRUNUT1JfQlVJTERFUiIsImFsbG93Qm9vc3QiLCJmdW5jcyIsInZhbGlkYXRlQXJpdHkiLCJwaXBlY2FsbCIsIm9sZEFsbG93Qm9vc3QiLCJtYXJrTmFtZSIsInBhaXIiLCJhbmQiLCJvciIsIm5vdCIsImFzYyIsImRlc2MiLCJwYXJhbSIsIm9iamVjdF9leHByIiwidmFsdWUyIiwiZXh0cmFjdFByb3BlcnR5S2V5Iiwib2JqZWN0X3BhaXIiLCJvYmplY3Rfc3BsYXQiLCJvYmplY3Rfc3BsYXRfdGhpcyIsInNxdWFyZV9icmFja2V0IiwicHJvamVjdGlvbiIsImF0dHJfYWNjZXNzIiwiZGVyZWYiLCJ3cmFwIiwiYXJyYXlfcG9zdGZpeCIsImZ1bmN0aW9uTmFtZSIsImFyZ0NvdW50IiwiZnVuY3Rpb25zUmVxdWlyaW5nU2VsZWN0b3JzIiwiaW5jbHVkZXMiLCJHcm9xU3ludGF4RXJyb3IiLCJwYXJzZSIsImlucHV0IiwicHJvY2Vzc29yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/groq-js/dist/1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/groq-js/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/groq-js/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _1 = __webpack_require__(/*! ./1.js */ \"(ssr)/./node_modules/groq-js/dist/1.js\");\nexports.DateTime = _1.DateTime;\nexports.evaluate = _1.evaluate;\nexports.parse = _1.parse; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGLElBQUlDLEtBQUtDLG1CQUFPQSxDQUFDO0FBQ2pCSCxnQkFBZ0IsR0FBR0UsR0FBR0UsUUFBUTtBQUM5QkosZ0JBQWdCLEdBQUdFLEdBQUdHLFFBQVE7QUFDOUJMLGFBQWEsR0FBR0UsR0FBR0ksS0FBSyxFQUN4QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJ5LmluZm8vLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0L2luZGV4LmpzPzIzN2EiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBfMSA9IHJlcXVpcmUoJy4vMS5qcycpO1xuZXhwb3J0cy5EYXRlVGltZSA9IF8xLkRhdGVUaW1lO1xuZXhwb3J0cy5ldmFsdWF0ZSA9IF8xLmV2YWx1YXRlO1xuZXhwb3J0cy5wYXJzZSA9IF8xLnBhcnNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJfMSIsInJlcXVpcmUiLCJEYXRlVGltZSIsImV2YWx1YXRlIiwicGFyc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/groq-js/dist/index.js\n");

/***/ })

};
;