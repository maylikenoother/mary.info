"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/history";
exports.ids = ["vendor-chunks/history"];
exports.modules = {

/***/ "(ssr)/./node_modules/history/index.js":
/*!***************************************!*\
  !*** ./node_modules/history/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Action: () => (/* binding */ Action),\n/* harmony export */   createBrowserHistory: () => (/* binding */ createBrowserHistory),\n/* harmony export */   createHashHistory: () => (/* binding */ createHashHistory),\n/* harmony export */   createMemoryHistory: () => (/* binding */ createMemoryHistory),\n/* harmony export */   createPath: () => (/* binding */ createPath),\n/* harmony export */   parsePath: () => (/* binding */ parsePath)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n\n/**\r\n * Actions represent the type of change to a location value.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action\r\n */ var Action;\n(function(Action) {\n    /**\r\n   * A POP indicates a change to an arbitrary index in the history stack, such\r\n   * as a back or forward navigation. It does not describe the direction of the\r\n   * navigation, only that the current index changed.\r\n   *\r\n   * Note: This is the default action for newly created history objects.\r\n   */ Action[\"Pop\"] = \"POP\";\n    /**\r\n   * A PUSH indicates a new entry being added to the history stack, such as when\r\n   * a link is clicked and a new page loads. When this happens, all subsequent\r\n   * entries in the stack are lost.\r\n   */ Action[\"Push\"] = \"PUSH\";\n    /**\r\n   * A REPLACE indicates the entry at the current index in the history stack\r\n   * being replaced by a new one.\r\n   */ Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nvar readOnly =  true ? function(obj) {\n    return Object.freeze(obj);\n} : 0;\nfunction warning(cond, message) {\n    if (!cond) {\n        // eslint-disable-next-line no-console\n        if (typeof console !== \"undefined\") console.warn(message);\n        try {\n            // Welcome to debugging history!\n            //\n            // This error is thrown as a convenience so you can more easily\n            // find the source for a warning that appears in the console by\n            // enabling \"pause on exceptions\" in your JavaScript debugger.\n            throw new Error(message); // eslint-disable-next-line no-empty\n        } catch (e) {}\n    }\n}\nvar BeforeUnloadEventType = \"beforeunload\";\nvar HashChangeEventType = \"hashchange\";\nvar PopStateEventType = \"popstate\";\n/**\r\n * Browser history stores the location in regular URLs. This is the standard for\r\n * most web apps, but it requires some configuration on the server to ensure you\r\n * serve the same app at multiple URLs.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n */ function createBrowserHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options = options, _options$window = _options.window, window = _options$window === void 0 ? document.defaultView : _options$window;\n    var globalHistory = window.history;\n    function getIndexAndLocation() {\n        var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;\n        var state = globalHistory.state || {};\n        return [\n            state.idx,\n            readOnly({\n                pathname: pathname,\n                search: search,\n                hash: hash,\n                state: state.usr || null,\n                key: state.key || \"default\"\n            })\n        ];\n    }\n    var blockedPopTx = null;\n    function handlePop() {\n        if (blockedPopTx) {\n            blockers.call(blockedPopTx);\n            blockedPopTx = null;\n        } else {\n            var nextAction = Action.Pop;\n            var _getIndexAndLocation = getIndexAndLocation(), nextIndex = _getIndexAndLocation[0], nextLocation = _getIndexAndLocation[1];\n            if (blockers.length) {\n                if (nextIndex != null) {\n                    var delta = index - nextIndex;\n                    if (delta) {\n                        // Revert the POP\n                        blockedPopTx = {\n                            action: nextAction,\n                            location: nextLocation,\n                            retry: function retry() {\n                                go(delta * -1);\n                            }\n                        };\n                        go(delta);\n                    }\n                } else {\n                    // Trying to POP to a location with no index. We did not create\n                    // this location, so we can't effectively block the navigation.\n                     true ? warning(false, // detail and link to it here so people can understand better what\n                    // is going on and how to avoid it.\n                    \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : 0;\n                }\n            } else {\n                applyTx(nextAction);\n            }\n        }\n    }\n    window.addEventListener(PopStateEventType, handlePop);\n    var action = Action.Pop;\n    var _getIndexAndLocation2 = getIndexAndLocation(), index = _getIndexAndLocation2[0], location = _getIndexAndLocation2[1];\n    var listeners = createEvents();\n    var blockers = createEvents();\n    if (index == null) {\n        index = 0;\n        globalHistory.replaceState((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, globalHistory.state, {\n            idx: index\n        }), \"\");\n    }\n    function createHref(to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    } // state defaults to `null` because `window.history.state` does\n    function getNextLocation(to, state) {\n        if (state === void 0) {\n            state = null;\n        }\n        return readOnly((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            pathname: location.pathname,\n            hash: \"\",\n            search: \"\"\n        }, typeof to === \"string\" ? parsePath(to) : to, {\n            state: state,\n            key: createKey()\n        }));\n    }\n    function getHistoryStateAndUrl(nextLocation, index) {\n        return [\n            {\n                usr: nextLocation.state,\n                key: nextLocation.key,\n                idx: index\n            },\n            createHref(nextLocation)\n        ];\n    }\n    function allowTx(action, location, retry) {\n        return !blockers.length || (blockers.call({\n            action: action,\n            location: location,\n            retry: retry\n        }), false);\n    }\n    function applyTx(nextAction) {\n        action = nextAction;\n        var _getIndexAndLocation3 = getIndexAndLocation();\n        index = _getIndexAndLocation3[0];\n        location = _getIndexAndLocation3[1];\n        listeners.call({\n            action: action,\n            location: location\n        });\n    }\n    function push(to, state) {\n        var nextAction = Action.Push;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            push(to, state);\n        }\n        if (allowTx(nextAction, nextLocation, retry)) {\n            var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1), historyState = _getHistoryStateAndUr[0], url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading\n            // try...catch because iOS limits us to 100 pushState calls :/\n            try {\n                globalHistory.pushState(historyState, \"\", url);\n            } catch (error) {\n                // They are going to lose state here, but there is no real\n                // way to warn them about it since the page will refresh...\n                window.location.assign(url);\n            }\n            applyTx(nextAction);\n        }\n    }\n    function replace(to, state) {\n        var nextAction = Action.Replace;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            replace(to, state);\n        }\n        if (allowTx(nextAction, nextLocation, retry)) {\n            var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index), historyState = _getHistoryStateAndUr2[0], url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading\n            globalHistory.replaceState(historyState, \"\", url);\n            applyTx(nextAction);\n        }\n    }\n    function go(delta) {\n        globalHistory.go(delta);\n    }\n    var history = {\n        get action () {\n            return action;\n        },\n        get location () {\n            return location;\n        },\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        back: function back() {\n            go(-1);\n        },\n        forward: function forward() {\n            go(1);\n        },\n        listen: function listen(listener) {\n            return listeners.push(listener);\n        },\n        block: function block(blocker) {\n            var unblock = blockers.push(blocker);\n            if (blockers.length === 1) {\n                window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n            }\n            return function() {\n                unblock(); // Remove the beforeunload listener so the document may\n                // still be salvageable in the pagehide event.\n                // See https://html.spec.whatwg.org/#unloading-documents\n                if (!blockers.length) {\n                    window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n                }\n            };\n        }\n    };\n    return history;\n}\n/**\r\n * Hash history stores the location in window.location.hash. This makes it ideal\r\n * for situations where you don't want to send the location to the server for\r\n * some reason, either because you do cannot configure it or the URL space is\r\n * reserved for something else.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n */ function createHashHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options2 = options, _options2$window = _options2.window, window = _options2$window === void 0 ? document.defaultView : _options2$window;\n    var globalHistory = window.history;\n    function getIndexAndLocation() {\n        var _parsePath = parsePath(window.location.hash.substr(1)), _parsePath$pathname = _parsePath.pathname, pathname = _parsePath$pathname === void 0 ? \"/\" : _parsePath$pathname, _parsePath$search = _parsePath.search, search = _parsePath$search === void 0 ? \"\" : _parsePath$search, _parsePath$hash = _parsePath.hash, hash = _parsePath$hash === void 0 ? \"\" : _parsePath$hash;\n        var state = globalHistory.state || {};\n        return [\n            state.idx,\n            readOnly({\n                pathname: pathname,\n                search: search,\n                hash: hash,\n                state: state.usr || null,\n                key: state.key || \"default\"\n            })\n        ];\n    }\n    var blockedPopTx = null;\n    function handlePop() {\n        if (blockedPopTx) {\n            blockers.call(blockedPopTx);\n            blockedPopTx = null;\n        } else {\n            var nextAction = Action.Pop;\n            var _getIndexAndLocation4 = getIndexAndLocation(), nextIndex = _getIndexAndLocation4[0], nextLocation = _getIndexAndLocation4[1];\n            if (blockers.length) {\n                if (nextIndex != null) {\n                    var delta = index - nextIndex;\n                    if (delta) {\n                        // Revert the POP\n                        blockedPopTx = {\n                            action: nextAction,\n                            location: nextLocation,\n                            retry: function retry() {\n                                go(delta * -1);\n                            }\n                        };\n                        go(delta);\n                    }\n                } else {\n                    // Trying to POP to a location with no index. We did not create\n                    // this location, so we can't effectively block the navigation.\n                     true ? warning(false, // detail and link to it here so people can understand better\n                    // what is going on and how to avoid it.\n                    \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : 0;\n                }\n            } else {\n                applyTx(nextAction);\n            }\n        }\n    }\n    window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge\n    // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event\n    window.addEventListener(HashChangeEventType, function() {\n        var _getIndexAndLocation5 = getIndexAndLocation(), nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.\n        if (createPath(nextLocation) !== createPath(location)) {\n            handlePop();\n        }\n    });\n    var action = Action.Pop;\n    var _getIndexAndLocation6 = getIndexAndLocation(), index = _getIndexAndLocation6[0], location = _getIndexAndLocation6[1];\n    var listeners = createEvents();\n    var blockers = createEvents();\n    if (index == null) {\n        index = 0;\n        globalHistory.replaceState((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, globalHistory.state, {\n            idx: index\n        }), \"\");\n    }\n    function getBaseHref() {\n        var base = document.querySelector(\"base\");\n        var href = \"\";\n        if (base && base.getAttribute(\"href\")) {\n            var url = window.location.href;\n            var hashIndex = url.indexOf(\"#\");\n            href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n        }\n        return href;\n    }\n    function createHref(to) {\n        return getBaseHref() + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n    }\n    function getNextLocation(to, state) {\n        if (state === void 0) {\n            state = null;\n        }\n        return readOnly((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            pathname: location.pathname,\n            hash: \"\",\n            search: \"\"\n        }, typeof to === \"string\" ? parsePath(to) : to, {\n            state: state,\n            key: createKey()\n        }));\n    }\n    function getHistoryStateAndUrl(nextLocation, index) {\n        return [\n            {\n                usr: nextLocation.state,\n                key: nextLocation.key,\n                idx: index\n            },\n            createHref(nextLocation)\n        ];\n    }\n    function allowTx(action, location, retry) {\n        return !blockers.length || (blockers.call({\n            action: action,\n            location: location,\n            retry: retry\n        }), false);\n    }\n    function applyTx(nextAction) {\n        action = nextAction;\n        var _getIndexAndLocation7 = getIndexAndLocation();\n        index = _getIndexAndLocation7[0];\n        location = _getIndexAndLocation7[1];\n        listeners.call({\n            action: action,\n            location: location\n        });\n    }\n    function push(to, state) {\n        var nextAction = Action.Push;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            push(to, state);\n        }\n         true ? warning(nextLocation.pathname.charAt(0) === \"/\", \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\") : 0;\n        if (allowTx(nextAction, nextLocation, retry)) {\n            var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1), historyState = _getHistoryStateAndUr3[0], url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading\n            // try...catch because iOS limits us to 100 pushState calls :/\n            try {\n                globalHistory.pushState(historyState, \"\", url);\n            } catch (error) {\n                // They are going to lose state here, but there is no real\n                // way to warn them about it since the page will refresh...\n                window.location.assign(url);\n            }\n            applyTx(nextAction);\n        }\n    }\n    function replace(to, state) {\n        var nextAction = Action.Replace;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            replace(to, state);\n        }\n         true ? warning(nextLocation.pathname.charAt(0) === \"/\", \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(to) + \")\") : 0;\n        if (allowTx(nextAction, nextLocation, retry)) {\n            var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index), historyState = _getHistoryStateAndUr4[0], url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading\n            globalHistory.replaceState(historyState, \"\", url);\n            applyTx(nextAction);\n        }\n    }\n    function go(delta) {\n        globalHistory.go(delta);\n    }\n    var history = {\n        get action () {\n            return action;\n        },\n        get location () {\n            return location;\n        },\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        back: function back() {\n            go(-1);\n        },\n        forward: function forward() {\n            go(1);\n        },\n        listen: function listen(listener) {\n            return listeners.push(listener);\n        },\n        block: function block(blocker) {\n            var unblock = blockers.push(blocker);\n            if (blockers.length === 1) {\n                window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n            }\n            return function() {\n                unblock(); // Remove the beforeunload listener so the document may\n                // still be salvageable in the pagehide event.\n                // See https://html.spec.whatwg.org/#unloading-documents\n                if (!blockers.length) {\n                    window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n                }\n            };\n        }\n    };\n    return history;\n}\n/**\r\n * Memory history stores the current location in memory. It is designed for use\r\n * in stateful non-browser environments like tests and React Native.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory\r\n */ function createMemoryHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options3 = options, _options3$initialEntr = _options3.initialEntries, initialEntries = _options3$initialEntr === void 0 ? [\n        \"/\"\n    ] : _options3$initialEntr, initialIndex = _options3.initialIndex;\n    var entries = initialEntries.map(function(entry) {\n        var location = readOnly((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            pathname: \"/\",\n            search: \"\",\n            hash: \"\",\n            state: null,\n            key: createKey()\n        }, typeof entry === \"string\" ? parsePath(entry) : entry));\n         true ? warning(location.pathname.charAt(0) === \"/\", \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(entry) + \")\") : 0;\n        return location;\n    });\n    var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);\n    var action = Action.Pop;\n    var location = entries[index];\n    var listeners = createEvents();\n    var blockers = createEvents();\n    function createHref(to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    function getNextLocation(to, state) {\n        if (state === void 0) {\n            state = null;\n        }\n        return readOnly((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n            pathname: location.pathname,\n            search: \"\",\n            hash: \"\"\n        }, typeof to === \"string\" ? parsePath(to) : to, {\n            state: state,\n            key: createKey()\n        }));\n    }\n    function allowTx(action, location, retry) {\n        return !blockers.length || (blockers.call({\n            action: action,\n            location: location,\n            retry: retry\n        }), false);\n    }\n    function applyTx(nextAction, nextLocation) {\n        action = nextAction;\n        location = nextLocation;\n        listeners.call({\n            action: action,\n            location: location\n        });\n    }\n    function push(to, state) {\n        var nextAction = Action.Push;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            push(to, state);\n        }\n         true ? warning(location.pathname.charAt(0) === \"/\", \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(to) + \")\") : 0;\n        if (allowTx(nextAction, nextLocation, retry)) {\n            index += 1;\n            entries.splice(index, entries.length, nextLocation);\n            applyTx(nextAction, nextLocation);\n        }\n    }\n    function replace(to, state) {\n        var nextAction = Action.Replace;\n        var nextLocation = getNextLocation(to, state);\n        function retry() {\n            replace(to, state);\n        }\n         true ? warning(location.pathname.charAt(0) === \"/\", \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(to) + \")\") : 0;\n        if (allowTx(nextAction, nextLocation, retry)) {\n            entries[index] = nextLocation;\n            applyTx(nextAction, nextLocation);\n        }\n    }\n    function go(delta) {\n        var nextIndex = clamp(index + delta, 0, entries.length - 1);\n        var nextAction = Action.Pop;\n        var nextLocation = entries[nextIndex];\n        function retry() {\n            go(delta);\n        }\n        if (allowTx(nextAction, nextLocation, retry)) {\n            index = nextIndex;\n            applyTx(nextAction, nextLocation);\n        }\n    }\n    var history = {\n        get index () {\n            return index;\n        },\n        get action () {\n            return action;\n        },\n        get location () {\n            return location;\n        },\n        createHref: createHref,\n        push: push,\n        replace: replace,\n        go: go,\n        back: function back() {\n            go(-1);\n        },\n        forward: function forward() {\n            go(1);\n        },\n        listen: function listen(listener) {\n            return listeners.push(listener);\n        },\n        block: function block(blocker) {\n            return blockers.push(blocker);\n        }\n    };\n    return history;\n} ////////////////////////////////////////////////////////////////////////////////\n// UTILS\n////////////////////////////////////////////////////////////////////////////////\nfunction clamp(n, lowerBound, upperBound) {\n    return Math.min(Math.max(n, lowerBound), upperBound);\n}\nfunction promptBeforeUnload(event) {\n    // Cancel the event.\n    event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.\n    event.returnValue = \"\";\n}\nfunction createEvents() {\n    var handlers = [];\n    return {\n        get length () {\n            return handlers.length;\n        },\n        push: function push(fn) {\n            handlers.push(fn);\n            return function() {\n                handlers = handlers.filter(function(handler) {\n                    return handler !== fn;\n                });\n            };\n        },\n        call: function call(arg) {\n            handlers.forEach(function(fn) {\n                return fn && fn(arg);\n            });\n        }\n    };\n}\nfunction createKey() {\n    return Math.random().toString(36).substr(2, 8);\n}\n/**\r\n * Creates a string URL path from the given pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath\r\n */ function createPath(_ref) {\n    var _ref$pathname = _ref.pathname, pathname = _ref$pathname === void 0 ? \"/\" : _ref$pathname, _ref$search = _ref.search, search = _ref$search === void 0 ? \"\" : _ref$search, _ref$hash = _ref.hash, hash = _ref$hash === void 0 ? \"\" : _ref$hash;\n    if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n    if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n    return pathname;\n}\n/**\r\n * Parses a string URL path into its separate pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath\r\n */ function parsePath(path) {\n    var parsedPath = {};\n    if (path) {\n        var hashIndex = path.indexOf(\"#\");\n        if (hashIndex >= 0) {\n            parsedPath.hash = path.substr(hashIndex);\n            path = path.substr(0, hashIndex);\n        }\n        var searchIndex = path.indexOf(\"?\");\n        if (searchIndex >= 0) {\n            parsedPath.search = path.substr(searchIndex);\n            path = path.substr(0, searchIndex);\n        }\n        if (path) {\n            parsedPath.pathname = path;\n        }\n    }\n    return parsedPath;\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFNBQVMsS0FBS0YsWUFBWUUsS0FBSzJFLE1BQU0sQ0FBQyxPQUFPLE1BQU0zRSxPQUFPLE1BQU1BO0lBQzVFLE9BQU9GO0FBQ1Q7QUFDQTs7OztDQUlDLEdBRUQsU0FBU2dDLFVBQVVpRixJQUFJO0lBQ3JCLElBQUlDLGFBQWEsQ0FBQztJQUVsQixJQUFJRCxNQUFNO1FBQ1IsSUFBSXhDLFlBQVl3QyxLQUFLdkMsT0FBTyxDQUFDO1FBRTdCLElBQUlELGFBQWEsR0FBRztZQUNsQnlDLFdBQVdoSCxJQUFJLEdBQUcrRyxLQUFLcEQsTUFBTSxDQUFDWTtZQUM5QndDLE9BQU9BLEtBQUtwRCxNQUFNLENBQUMsR0FBR1k7UUFDeEI7UUFFQSxJQUFJMEMsY0FBY0YsS0FBS3ZDLE9BQU8sQ0FBQztRQUUvQixJQUFJeUMsZUFBZSxHQUFHO1lBQ3BCRCxXQUFXakgsTUFBTSxHQUFHZ0gsS0FBS3BELE1BQU0sQ0FBQ3NEO1lBQ2hDRixPQUFPQSxLQUFLcEQsTUFBTSxDQUFDLEdBQUdzRDtRQUN4QjtRQUVBLElBQUlGLE1BQU07WUFDUkMsV0FBV2xILFFBQVEsR0FBR2lIO1FBQ3hCO0lBQ0Y7SUFFQSxPQUFPQztBQUNUO0FBRXVHLENBQ3ZHLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcnkuaW5mby8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2luZGV4LmpzP2UxZmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuXG4vKipcclxuICogQWN0aW9ucyByZXByZXNlbnQgdGhlIHR5cGUgb2YgY2hhbmdlIHRvIGEgbG9jYXRpb24gdmFsdWUuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjYWN0aW9uXHJcbiAqL1xudmFyIEFjdGlvbjtcblxuKGZ1bmN0aW9uIChBY3Rpb24pIHtcbiAgLyoqXHJcbiAgICogQSBQT1AgaW5kaWNhdGVzIGEgY2hhbmdlIHRvIGFuIGFyYml0cmFyeSBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFjaywgc3VjaFxyXG4gICAqIGFzIGEgYmFjayBvciBmb3J3YXJkIG5hdmlnYXRpb24uIEl0IGRvZXMgbm90IGRlc2NyaWJlIHRoZSBkaXJlY3Rpb24gb2YgdGhlXHJcbiAgICogbmF2aWdhdGlvbiwgb25seSB0aGF0IHRoZSBjdXJyZW50IGluZGV4IGNoYW5nZWQuXHJcbiAgICpcclxuICAgKiBOb3RlOiBUaGlzIGlzIHRoZSBkZWZhdWx0IGFjdGlvbiBmb3IgbmV3bHkgY3JlYXRlZCBoaXN0b3J5IG9iamVjdHMuXHJcbiAgICovXG4gIEFjdGlvbltcIlBvcFwiXSA9IFwiUE9QXCI7XG4gIC8qKlxyXG4gICAqIEEgUFVTSCBpbmRpY2F0ZXMgYSBuZXcgZW50cnkgYmVpbmcgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2ssIHN1Y2ggYXMgd2hlblxyXG4gICAqIGEgbGluayBpcyBjbGlja2VkIGFuZCBhIG5ldyBwYWdlIGxvYWRzLiBXaGVuIHRoaXMgaGFwcGVucywgYWxsIHN1YnNlcXVlbnRcclxuICAgKiBlbnRyaWVzIGluIHRoZSBzdGFjayBhcmUgbG9zdC5cclxuICAgKi9cblxuICBBY3Rpb25bXCJQdXNoXCJdID0gXCJQVVNIXCI7XG4gIC8qKlxyXG4gICAqIEEgUkVQTEFDRSBpbmRpY2F0ZXMgdGhlIGVudHJ5IGF0IHRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrXHJcbiAgICogYmVpbmcgcmVwbGFjZWQgYnkgYSBuZXcgb25lLlxyXG4gICAqL1xuXG4gIEFjdGlvbltcIlJlcGxhY2VcIl0gPSBcIlJFUExBQ0VcIjtcbn0pKEFjdGlvbiB8fCAoQWN0aW9uID0ge30pKTtcblxudmFyIHJlYWRPbmx5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShvYmopO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iajtcbn07XG5cbmZ1bmN0aW9uIHdhcm5pbmcoY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIGNvbnNvbGUud2FybihtZXNzYWdlKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBXZWxjb21lIHRvIGRlYnVnZ2luZyBoaXN0b3J5IVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28geW91IGNhbiBtb3JlIGVhc2lseVxuICAgICAgLy8gZmluZCB0aGUgc291cmNlIGZvciBhIHdhcm5pbmcgdGhhdCBhcHBlYXJzIGluIHRoZSBjb25zb2xlIGJ5XG4gICAgICAvLyBlbmFibGluZyBcInBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIEphdmFTY3JpcHQgZGVidWdnZXIuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbn1cblxudmFyIEJlZm9yZVVubG9hZEV2ZW50VHlwZSA9ICdiZWZvcmV1bmxvYWQnO1xudmFyIEhhc2hDaGFuZ2VFdmVudFR5cGUgPSAnaGFzaGNoYW5nZSc7XG52YXIgUG9wU3RhdGVFdmVudFR5cGUgPSAncG9wc3RhdGUnO1xuLyoqXHJcbiAqIEJyb3dzZXIgaGlzdG9yeSBzdG9yZXMgdGhlIGxvY2F0aW9uIGluIHJlZ3VsYXIgVVJMcy4gVGhpcyBpcyB0aGUgc3RhbmRhcmQgZm9yXHJcbiAqIG1vc3Qgd2ViIGFwcHMsIGJ1dCBpdCByZXF1aXJlcyBzb21lIGNvbmZpZ3VyYXRpb24gb24gdGhlIHNlcnZlciB0byBlbnN1cmUgeW91XHJcbiAqIHNlcnZlIHRoZSBzYW1lIGFwcCBhdCBtdWx0aXBsZSBVUkxzLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZWJyb3dzZXJoaXN0b3J5XHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkd2luZG93ID0gX29wdGlvbnMud2luZG93LFxuICAgICAgd2luZG93ID0gX29wdGlvbnMkd2luZG93ID09PSB2b2lkIDAgPyBkb2N1bWVudC5kZWZhdWx0VmlldyA6IF9vcHRpb25zJHdpbmRvdztcbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcblxuICBmdW5jdGlvbiBnZXRJbmRleEFuZExvY2F0aW9uKCkge1xuICAgIHZhciBfd2luZG93JGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLFxuICAgICAgICBwYXRobmFtZSA9IF93aW5kb3ckbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCA9IF93aW5kb3ckbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNoID0gX3dpbmRvdyRsb2NhdGlvbi5oYXNoO1xuICAgIHZhciBzdGF0ZSA9IGdsb2JhbEhpc3Rvcnkuc3RhdGUgfHwge307XG4gICAgcmV0dXJuIFtzdGF0ZS5pZHgsIHJlYWRPbmx5KHtcbiAgICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICAgIHNlYXJjaDogc2VhcmNoLFxuICAgICAgaGFzaDogaGFzaCxcbiAgICAgIHN0YXRlOiBzdGF0ZS51c3IgfHwgbnVsbCxcbiAgICAgIGtleTogc3RhdGUua2V5IHx8ICdkZWZhdWx0J1xuICAgIH0pXTtcbiAgfVxuXG4gIHZhciBibG9ja2VkUG9wVHggPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZVBvcCgpIHtcbiAgICBpZiAoYmxvY2tlZFBvcFR4KSB7XG4gICAgICBibG9ja2Vycy5jYWxsKGJsb2NrZWRQb3BUeCk7XG4gICAgICBibG9ja2VkUG9wVHggPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV4dEFjdGlvbiA9IEFjdGlvbi5Qb3A7XG5cbiAgICAgIHZhciBfZ2V0SW5kZXhBbmRMb2NhdGlvbiA9IGdldEluZGV4QW5kTG9jYXRpb24oKSxcbiAgICAgICAgICBuZXh0SW5kZXggPSBfZ2V0SW5kZXhBbmRMb2NhdGlvblswXSxcbiAgICAgICAgICBuZXh0TG9jYXRpb24gPSBfZ2V0SW5kZXhBbmRMb2NhdGlvblsxXTtcblxuICAgICAgaWYgKGJsb2NrZXJzLmxlbmd0aCkge1xuICAgICAgICBpZiAobmV4dEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgZGVsdGEgPSBpbmRleCAtIG5leHRJbmRleDtcblxuICAgICAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBQT1BcbiAgICAgICAgICAgIGJsb2NrZWRQb3BUeCA9IHtcbiAgICAgICAgICAgICAgYWN0aW9uOiBuZXh0QWN0aW9uLFxuICAgICAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICAgICAgICByZXRyeTogZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICAgICAgICAgICAgZ28oZGVsdGEgKiAtMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbyhkZWx0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRyeWluZyB0byBQT1AgdG8gYSBsb2NhdGlvbiB3aXRoIG5vIGluZGV4LiBXZSBkaWQgbm90IGNyZWF0ZVxuICAgICAgICAgIC8vIHRoaXMgbG9jYXRpb24sIHNvIHdlIGNhbid0IGVmZmVjdGl2ZWx5IGJsb2NrIHRoZSBuYXZpZ2F0aW9uLlxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIC8vIFRPRE86IFdyaXRlIHVwIGEgZG9jIHRoYXQgZXhwbGFpbnMgb3VyIGJsb2NraW5nIHN0cmF0ZWd5IGluXG4gICAgICAgICAgLy8gZGV0YWlsIGFuZCBsaW5rIHRvIGl0IGhlcmUgc28gcGVvcGxlIGNhbiB1bmRlcnN0YW5kIGJldHRlciB3aGF0XG4gICAgICAgICAgLy8gaXMgZ29pbmcgb24gYW5kIGhvdyB0byBhdm9pZCBpdC5cbiAgICAgICAgICBcIllvdSBhcmUgdHJ5aW5nIHRvIGJsb2NrIGEgUE9QIG5hdmlnYXRpb24gdG8gYSBsb2NhdGlvbiB0aGF0IHdhcyBub3QgXCIgKyBcImNyZWF0ZWQgYnkgdGhlIGhpc3RvcnkgbGlicmFyeS4gVGhlIGJsb2NrIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBcIiArIFwicHJvZHVjdGlvbiwgYnV0IGluIGdlbmVyYWwgeW91IHNob3VsZCBkbyBhbGwgbmF2aWdhdGlvbiB3aXRoIHRoZSBcIiArIFwiaGlzdG9yeSBsaWJyYXJ5IChpbnN0ZWFkIG9mIHVzaW5nIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSBkaXJlY3RseSkgXCIgKyBcInRvIGF2b2lkIHRoaXMgc2l0dWF0aW9uLlwiKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwbHlUeChuZXh0QWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTtcbiAgdmFyIGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG5cbiAgdmFyIF9nZXRJbmRleEFuZExvY2F0aW9uMiA9IGdldEluZGV4QW5kTG9jYXRpb24oKSxcbiAgICAgIGluZGV4ID0gX2dldEluZGV4QW5kTG9jYXRpb24yWzBdLFxuICAgICAgbG9jYXRpb24gPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjJbMV07XG5cbiAgdmFyIGxpc3RlbmVycyA9IGNyZWF0ZUV2ZW50cygpO1xuICB2YXIgYmxvY2tlcnMgPSBjcmVhdGVFdmVudHMoKTtcblxuICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgIGluZGV4ID0gMDtcbiAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShfZXh0ZW5kcyh7fSwgZ2xvYmFsSGlzdG9yeS5zdGF0ZSwge1xuICAgICAgaWR4OiBpbmRleFxuICAgIH0pLCAnJyk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKHRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICB9IC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuXG5cbiAgZnVuY3Rpb24gZ2V0TmV4dExvY2F0aW9uKHRvLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlYWRPbmx5KF9leHRlbmRzKHtcbiAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIGhhc2g6ICcnLFxuICAgICAgc2VhcmNoOiAnJ1xuICAgIH0sIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyBwYXJzZVBhdGgodG8pIDogdG8sIHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIGtleTogY3JlYXRlS2V5KClcbiAgICB9KSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGVBbmRVcmwobmV4dExvY2F0aW9uLCBpbmRleCkge1xuICAgIHJldHVybiBbe1xuICAgICAgdXNyOiBuZXh0TG9jYXRpb24uc3RhdGUsXG4gICAgICBrZXk6IG5leHRMb2NhdGlvbi5rZXksXG4gICAgICBpZHg6IGluZGV4XG4gICAgfSwgY3JlYXRlSHJlZihuZXh0TG9jYXRpb24pXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbG93VHgoYWN0aW9uLCBsb2NhdGlvbiwgcmV0cnkpIHtcbiAgICByZXR1cm4gIWJsb2NrZXJzLmxlbmd0aCB8fCAoYmxvY2tlcnMuY2FsbCh7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgIHJldHJ5OiByZXRyeVxuICAgIH0pLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVR4KG5leHRBY3Rpb24pIHtcbiAgICBhY3Rpb24gPSBuZXh0QWN0aW9uO1xuXG4gICAgdmFyIF9nZXRJbmRleEFuZExvY2F0aW9uMyA9IGdldEluZGV4QW5kTG9jYXRpb24oKTtcblxuICAgIGluZGV4ID0gX2dldEluZGV4QW5kTG9jYXRpb24zWzBdO1xuICAgIGxvY2F0aW9uID0gX2dldEluZGV4QW5kTG9jYXRpb24zWzFdO1xuICAgIGxpc3RlbmVycy5jYWxsKHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKHRvLCBzdGF0ZSkge1xuICAgIHZhciBuZXh0QWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgdmFyIG5leHRMb2NhdGlvbiA9IGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpO1xuXG4gICAgZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICBwdXNoKHRvLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uLCByZXRyeSkpIHtcbiAgICAgIHZhciBfZ2V0SGlzdG9yeVN0YXRlQW5kVXIgPSBnZXRIaXN0b3J5U3RhdGVBbmRVcmwobmV4dExvY2F0aW9uLCBpbmRleCArIDEpLFxuICAgICAgICAgIGhpc3RvcnlTdGF0ZSA9IF9nZXRIaXN0b3J5U3RhdGVBbmRVclswXSxcbiAgICAgICAgICB1cmwgPSBfZ2V0SGlzdG9yeVN0YXRlQW5kVXJbMV07IC8vIFRPRE86IFN1cHBvcnQgZm9yY2VkIHJlbG9hZGluZ1xuICAgICAgLy8gdHJ5Li4uY2F0Y2ggYmVjYXVzZSBpT1MgbGltaXRzIHVzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHMgOi9cblxuXG4gICAgICB0cnkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCB1cmwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gVGhleSBhcmUgZ29pbmcgdG8gbG9zZSBzdGF0ZSBoZXJlLCBidXQgdGhlcmUgaXMgbm8gcmVhbFxuICAgICAgICAvLyB3YXkgdG8gd2FybiB0aGVtIGFib3V0IGl0IHNpbmNlIHRoZSBwYWdlIHdpbGwgcmVmcmVzaC4uLlxuICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgICB9XG5cbiAgICAgIGFwcGx5VHgobmV4dEFjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICB2YXIgbmV4dEFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgIHZhciBuZXh0TG9jYXRpb24gPSBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKTtcblxuICAgIGZ1bmN0aW9uIHJldHJ5KCkge1xuICAgICAgcmVwbGFjZSh0bywgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhbGxvd1R4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbiwgcmV0cnkpKSB7XG4gICAgICB2YXIgX2dldEhpc3RvcnlTdGF0ZUFuZFVyMiA9IGdldEhpc3RvcnlTdGF0ZUFuZFVybChuZXh0TG9jYXRpb24sIGluZGV4KSxcbiAgICAgICAgICBoaXN0b3J5U3RhdGUgPSBfZ2V0SGlzdG9yeVN0YXRlQW5kVXIyWzBdLFxuICAgICAgICAgIHVybCA9IF9nZXRIaXN0b3J5U3RhdGVBbmRVcjJbMV07IC8vIFRPRE86IFN1cHBvcnQgZm9yY2VkIHJlbG9hZGluZ1xuXG5cbiAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgJycsIHVybCk7XG4gICAgICBhcHBseVR4KG5leHRBY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdvKGRlbHRhKSB7XG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhkZWx0YSk7XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH0sXG5cbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgYmFjazogZnVuY3Rpb24gYmFjaygpIHtcbiAgICAgIGdvKC0xKTtcbiAgICB9LFxuICAgIGZvcndhcmQ6IGZ1bmN0aW9uIGZvcndhcmQoKSB7XG4gICAgICBnbygxKTtcbiAgICB9LFxuICAgIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH0sXG4gICAgYmxvY2s6IGZ1bmN0aW9uIGJsb2NrKGJsb2NrZXIpIHtcbiAgICAgIHZhciB1bmJsb2NrID0gYmxvY2tlcnMucHVzaChibG9ja2VyKTtcblxuICAgICAgaWYgKGJsb2NrZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihCZWZvcmVVbmxvYWRFdmVudFR5cGUsIHByb21wdEJlZm9yZVVubG9hZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHVuYmxvY2soKTsgLy8gUmVtb3ZlIHRoZSBiZWZvcmV1bmxvYWQgbGlzdGVuZXIgc28gdGhlIGRvY3VtZW50IG1heVxuICAgICAgICAvLyBzdGlsbCBiZSBzYWx2YWdlYWJsZSBpbiB0aGUgcGFnZWhpZGUgZXZlbnQuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyN1bmxvYWRpbmctZG9jdW1lbnRzXG5cbiAgICAgICAgaWYgKCFibG9ja2Vycy5sZW5ndGgpIHtcbiAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihCZWZvcmVVbmxvYWRFdmVudFR5cGUsIHByb21wdEJlZm9yZVVubG9hZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cbi8qKlxyXG4gKiBIYXNoIGhpc3Rvcnkgc3RvcmVzIHRoZSBsb2NhdGlvbiBpbiB3aW5kb3cubG9jYXRpb24uaGFzaC4gVGhpcyBtYWtlcyBpdCBpZGVhbFxyXG4gKiBmb3Igc2l0dWF0aW9ucyB3aGVyZSB5b3UgZG9uJ3Qgd2FudCB0byBzZW5kIHRoZSBsb2NhdGlvbiB0byB0aGUgc2VydmVyIGZvclxyXG4gKiBzb21lIHJlYXNvbiwgZWl0aGVyIGJlY2F1c2UgeW91IGRvIGNhbm5vdCBjb25maWd1cmUgaXQgb3IgdGhlIFVSTCBzcGFjZSBpc1xyXG4gKiByZXNlcnZlZCBmb3Igc29tZXRoaW5nIGVsc2UuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjY3JlYXRlaGFzaGhpc3RvcnlcclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9uczIgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMyJHdpbmRvdyA9IF9vcHRpb25zMi53aW5kb3csXG4gICAgICB3aW5kb3cgPSBfb3B0aW9uczIkd2luZG93ID09PSB2b2lkIDAgPyBkb2N1bWVudC5kZWZhdWx0VmlldyA6IF9vcHRpb25zMiR3aW5kb3c7XG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG5cbiAgZnVuY3Rpb24gZ2V0SW5kZXhBbmRMb2NhdGlvbigpIHtcbiAgICB2YXIgX3BhcnNlUGF0aCA9IHBhcnNlUGF0aCh3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHIoMSkpLFxuICAgICAgICBfcGFyc2VQYXRoJHBhdGhuYW1lID0gX3BhcnNlUGF0aC5wYXRobmFtZSxcbiAgICAgICAgcGF0aG5hbWUgPSBfcGFyc2VQYXRoJHBhdGhuYW1lID09PSB2b2lkIDAgPyAnLycgOiBfcGFyc2VQYXRoJHBhdGhuYW1lLFxuICAgICAgICBfcGFyc2VQYXRoJHNlYXJjaCA9IF9wYXJzZVBhdGguc2VhcmNoLFxuICAgICAgICBzZWFyY2ggPSBfcGFyc2VQYXRoJHNlYXJjaCA9PT0gdm9pZCAwID8gJycgOiBfcGFyc2VQYXRoJHNlYXJjaCxcbiAgICAgICAgX3BhcnNlUGF0aCRoYXNoID0gX3BhcnNlUGF0aC5oYXNoLFxuICAgICAgICBoYXNoID0gX3BhcnNlUGF0aCRoYXNoID09PSB2b2lkIDAgPyAnJyA6IF9wYXJzZVBhdGgkaGFzaDtcblxuICAgIHZhciBzdGF0ZSA9IGdsb2JhbEhpc3Rvcnkuc3RhdGUgfHwge307XG4gICAgcmV0dXJuIFtzdGF0ZS5pZHgsIHJlYWRPbmx5KHtcbiAgICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICAgIHNlYXJjaDogc2VhcmNoLFxuICAgICAgaGFzaDogaGFzaCxcbiAgICAgIHN0YXRlOiBzdGF0ZS51c3IgfHwgbnVsbCxcbiAgICAgIGtleTogc3RhdGUua2V5IHx8ICdkZWZhdWx0J1xuICAgIH0pXTtcbiAgfVxuXG4gIHZhciBibG9ja2VkUG9wVHggPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZVBvcCgpIHtcbiAgICBpZiAoYmxvY2tlZFBvcFR4KSB7XG4gICAgICBibG9ja2Vycy5jYWxsKGJsb2NrZWRQb3BUeCk7XG4gICAgICBibG9ja2VkUG9wVHggPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV4dEFjdGlvbiA9IEFjdGlvbi5Qb3A7XG5cbiAgICAgIHZhciBfZ2V0SW5kZXhBbmRMb2NhdGlvbjQgPSBnZXRJbmRleEFuZExvY2F0aW9uKCksXG4gICAgICAgICAgbmV4dEluZGV4ID0gX2dldEluZGV4QW5kTG9jYXRpb240WzBdLFxuICAgICAgICAgIG5leHRMb2NhdGlvbiA9IF9nZXRJbmRleEFuZExvY2F0aW9uNFsxXTtcblxuICAgICAgaWYgKGJsb2NrZXJzLmxlbmd0aCkge1xuICAgICAgICBpZiAobmV4dEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgZGVsdGEgPSBpbmRleCAtIG5leHRJbmRleDtcblxuICAgICAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICAgICAgLy8gUmV2ZXJ0IHRoZSBQT1BcbiAgICAgICAgICAgIGJsb2NrZWRQb3BUeCA9IHtcbiAgICAgICAgICAgICAgYWN0aW9uOiBuZXh0QWN0aW9uLFxuICAgICAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICAgICAgICByZXRyeTogZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICAgICAgICAgICAgZ28oZGVsdGEgKiAtMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbyhkZWx0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRyeWluZyB0byBQT1AgdG8gYSBsb2NhdGlvbiB3aXRoIG5vIGluZGV4LiBXZSBkaWQgbm90IGNyZWF0ZVxuICAgICAgICAgIC8vIHRoaXMgbG9jYXRpb24sIHNvIHdlIGNhbid0IGVmZmVjdGl2ZWx5IGJsb2NrIHRoZSBuYXZpZ2F0aW9uLlxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIC8vIFRPRE86IFdyaXRlIHVwIGEgZG9jIHRoYXQgZXhwbGFpbnMgb3VyIGJsb2NraW5nIHN0cmF0ZWd5IGluXG4gICAgICAgICAgLy8gZGV0YWlsIGFuZCBsaW5rIHRvIGl0IGhlcmUgc28gcGVvcGxlIGNhbiB1bmRlcnN0YW5kIGJldHRlclxuICAgICAgICAgIC8vIHdoYXQgaXMgZ29pbmcgb24gYW5kIGhvdyB0byBhdm9pZCBpdC5cbiAgICAgICAgICBcIllvdSBhcmUgdHJ5aW5nIHRvIGJsb2NrIGEgUE9QIG5hdmlnYXRpb24gdG8gYSBsb2NhdGlvbiB0aGF0IHdhcyBub3QgXCIgKyBcImNyZWF0ZWQgYnkgdGhlIGhpc3RvcnkgbGlicmFyeS4gVGhlIGJsb2NrIHdpbGwgZmFpbCBzaWxlbnRseSBpbiBcIiArIFwicHJvZHVjdGlvbiwgYnV0IGluIGdlbmVyYWwgeW91IHNob3VsZCBkbyBhbGwgbmF2aWdhdGlvbiB3aXRoIHRoZSBcIiArIFwiaGlzdG9yeSBsaWJyYXJ5IChpbnN0ZWFkIG9mIHVzaW5nIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSBkaXJlY3RseSkgXCIgKyBcInRvIGF2b2lkIHRoaXMgc2l0dWF0aW9uLlwiKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwbHlUeChuZXh0QWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50VHlwZSwgaGFuZGxlUG9wKTsgLy8gcG9wc3RhdGUgZG9lcyBub3QgZmlyZSBvbiBoYXNoY2hhbmdlIGluIElFIDExIGFuZCBvbGQgKHRyaWRlbnQpIEVkZ2VcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZGUvZG9jcy9XZWIvQVBJL1dpbmRvdy9wb3BzdGF0ZV9ldmVudFxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKEhhc2hDaGFuZ2VFdmVudFR5cGUsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2dldEluZGV4QW5kTG9jYXRpb241ID0gZ2V0SW5kZXhBbmRMb2NhdGlvbigpLFxuICAgICAgICBuZXh0TG9jYXRpb24gPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjVbMV07IC8vIElnbm9yZSBleHRyYW5lb3VzIGhhc2hjaGFuZ2UgZXZlbnRzLlxuXG5cbiAgICBpZiAoY3JlYXRlUGF0aChuZXh0TG9jYXRpb24pICE9PSBjcmVhdGVQYXRoKGxvY2F0aW9uKSkge1xuICAgICAgaGFuZGxlUG9wKCk7XG4gICAgfVxuICB9KTtcbiAgdmFyIGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG5cbiAgdmFyIF9nZXRJbmRleEFuZExvY2F0aW9uNiA9IGdldEluZGV4QW5kTG9jYXRpb24oKSxcbiAgICAgIGluZGV4ID0gX2dldEluZGV4QW5kTG9jYXRpb242WzBdLFxuICAgICAgbG9jYXRpb24gPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjZbMV07XG5cbiAgdmFyIGxpc3RlbmVycyA9IGNyZWF0ZUV2ZW50cygpO1xuICB2YXIgYmxvY2tlcnMgPSBjcmVhdGVFdmVudHMoKTtcblxuICBpZiAoaW5kZXggPT0gbnVsbCkge1xuICAgIGluZGV4ID0gMDtcbiAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShfZXh0ZW5kcyh7fSwgZ2xvYmFsSGlzdG9yeS5zdGF0ZSwge1xuICAgICAgaWR4OiBpbmRleFxuICAgIH0pLCAnJyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCYXNlSHJlZigpIHtcbiAgICB2YXIgYmFzZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcbiAgICB2YXIgaHJlZiA9ICcnO1xuXG4gICAgaWYgKGJhc2UgJiYgYmFzZS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkge1xuICAgICAgdmFyIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgdmFyIGhhc2hJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgICBocmVmID0gaGFzaEluZGV4ID09PSAtMSA/IHVybCA6IHVybC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBocmVmO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZih0bykge1xuICAgIHJldHVybiBnZXRCYXNlSHJlZigpICsgJyMnICsgKHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyB0byA6IGNyZWF0ZVBhdGgodG8pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgc3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZWFkT25seShfZXh0ZW5kcyh7XG4gICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBoYXNoOiAnJyxcbiAgICAgIHNlYXJjaDogJydcbiAgICB9LCB0eXBlb2YgdG8gPT09ICdzdHJpbmcnID8gcGFyc2VQYXRoKHRvKSA6IHRvLCB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBrZXk6IGNyZWF0ZUtleSgpXG4gICAgfSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlQW5kVXJsKG5leHRMb2NhdGlvbiwgaW5kZXgpIHtcbiAgICByZXR1cm4gW3tcbiAgICAgIHVzcjogbmV4dExvY2F0aW9uLnN0YXRlLFxuICAgICAga2V5OiBuZXh0TG9jYXRpb24ua2V5LFxuICAgICAgaWR4OiBpbmRleFxuICAgIH0sIGNyZWF0ZUhyZWYobmV4dExvY2F0aW9uKV07XG4gIH1cblxuICBmdW5jdGlvbiBhbGxvd1R4KGFjdGlvbiwgbG9jYXRpb24sIHJldHJ5KSB7XG4gICAgcmV0dXJuICFibG9ja2Vycy5sZW5ndGggfHwgKGJsb2NrZXJzLmNhbGwoe1xuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICByZXRyeTogcmV0cnlcbiAgICB9KSwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlUeChuZXh0QWN0aW9uKSB7XG4gICAgYWN0aW9uID0gbmV4dEFjdGlvbjtcblxuICAgIHZhciBfZ2V0SW5kZXhBbmRMb2NhdGlvbjcgPSBnZXRJbmRleEFuZExvY2F0aW9uKCk7XG5cbiAgICBpbmRleCA9IF9nZXRJbmRleEFuZExvY2F0aW9uN1swXTtcbiAgICBsb2NhdGlvbiA9IF9nZXRJbmRleEFuZExvY2F0aW9uN1sxXTtcbiAgICBsaXN0ZW5lcnMuY2FsbCh7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaCh0bywgc3RhdGUpIHtcbiAgICB2YXIgbmV4dEFjdGlvbiA9IEFjdGlvbi5QdXNoO1xuICAgIHZhciBuZXh0TG9jYXRpb24gPSBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKTtcblxuICAgIGZ1bmN0aW9uIHJldHJ5KCkge1xuICAgICAgcHVzaCh0bywgc3RhdGUpO1xuICAgIH1cblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcobmV4dExvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nLCBcIlJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBoYXNoIGhpc3RvcnkucHVzaChcIiArIEpTT04uc3RyaW5naWZ5KHRvKSArIFwiKVwiKSA6IHZvaWQgMDtcblxuICAgIGlmIChhbGxvd1R4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbiwgcmV0cnkpKSB7XG4gICAgICB2YXIgX2dldEhpc3RvcnlTdGF0ZUFuZFVyMyA9IGdldEhpc3RvcnlTdGF0ZUFuZFVybChuZXh0TG9jYXRpb24sIGluZGV4ICsgMSksXG4gICAgICAgICAgaGlzdG9yeVN0YXRlID0gX2dldEhpc3RvcnlTdGF0ZUFuZFVyM1swXSxcbiAgICAgICAgICB1cmwgPSBfZ2V0SGlzdG9yeVN0YXRlQW5kVXIzWzFdOyAvLyBUT0RPOiBTdXBwb3J0IGZvcmNlZCByZWxvYWRpbmdcbiAgICAgIC8vIHRyeS4uLmNhdGNoIGJlY2F1c2UgaU9TIGxpbWl0cyB1cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzIDovXG5cblxuICAgICAgdHJ5IHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgdXJsKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFRoZXkgYXJlIGdvaW5nIHRvIGxvc2Ugc3RhdGUgaGVyZSwgYnV0IHRoZXJlIGlzIG5vIHJlYWxcbiAgICAgICAgLy8gd2F5IHRvIHdhcm4gdGhlbSBhYm91dCBpdCBzaW5jZSB0aGUgcGFnZSB3aWxsIHJlZnJlc2guLi5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgICAgfVxuXG4gICAgICBhcHBseVR4KG5leHRBY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UodG8sIHN0YXRlKSB7XG4gICAgdmFyIG5leHRBY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICB2YXIgbmV4dExvY2F0aW9uID0gZ2V0TmV4dExvY2F0aW9uKHRvLCBzdGF0ZSk7XG5cbiAgICBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgIHJlcGxhY2UodG8sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKG5leHRMb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJywgXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnJlcGxhY2UoXCIgKyBKU09OLnN0cmluZ2lmeSh0bykgKyBcIilcIikgOiB2b2lkIDA7XG5cbiAgICBpZiAoYWxsb3dUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24sIHJldHJ5KSkge1xuICAgICAgdmFyIF9nZXRIaXN0b3J5U3RhdGVBbmRVcjQgPSBnZXRIaXN0b3J5U3RhdGVBbmRVcmwobmV4dExvY2F0aW9uLCBpbmRleCksXG4gICAgICAgICAgaGlzdG9yeVN0YXRlID0gX2dldEhpc3RvcnlTdGF0ZUFuZFVyNFswXSxcbiAgICAgICAgICB1cmwgPSBfZ2V0SGlzdG9yeVN0YXRlQW5kVXI0WzFdOyAvLyBUT0RPOiBTdXBwb3J0IGZvcmNlZCByZWxvYWRpbmdcblxuXG4gICAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCB1cmwpO1xuICAgICAgYXBwbHlUeChuZXh0QWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnbyhkZWx0YSkge1xuICAgIGdsb2JhbEhpc3RvcnkuZ28oZGVsdGEpO1xuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcblxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9LFxuXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGJhY2s6IGZ1bmN0aW9uIGJhY2soKSB7XG4gICAgICBnbygtMSk7XG4gICAgfSxcbiAgICBmb3J3YXJkOiBmdW5jdGlvbiBmb3J3YXJkKCkge1xuICAgICAgZ28oMSk7XG4gICAgfSxcbiAgICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIGJsb2NrOiBmdW5jdGlvbiBibG9jayhibG9ja2VyKSB7XG4gICAgICB2YXIgdW5ibG9jayA9IGJsb2NrZXJzLnB1c2goYmxvY2tlcik7XG5cbiAgICAgIGlmIChibG9ja2Vycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoQmVmb3JlVW5sb2FkRXZlbnRUeXBlLCBwcm9tcHRCZWZvcmVVbmxvYWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB1bmJsb2NrKCk7IC8vIFJlbW92ZSB0aGUgYmVmb3JldW5sb2FkIGxpc3RlbmVyIHNvIHRoZSBkb2N1bWVudCBtYXlcbiAgICAgICAgLy8gc3RpbGwgYmUgc2FsdmFnZWFibGUgaW4gdGhlIHBhZ2VoaWRlIGV2ZW50LlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jdW5sb2FkaW5nLWRvY3VtZW50c1xuXG4gICAgICAgIGlmICghYmxvY2tlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoQmVmb3JlVW5sb2FkRXZlbnRUeXBlLCBwcm9tcHRCZWZvcmVVbmxvYWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG4vKipcclxuICogTWVtb3J5IGhpc3Rvcnkgc3RvcmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIG1lbW9yeS4gSXQgaXMgZGVzaWduZWQgZm9yIHVzZVxyXG4gKiBpbiBzdGF0ZWZ1bCBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgbGlrZSB0ZXN0cyBhbmQgUmVhY3QgTmF0aXZlLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZW1lbW9yeWhpc3RvcnlcclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3Rvcnkob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zMyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9uczMkaW5pdGlhbEVudHIgPSBfb3B0aW9uczMuaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsRW50cmllcyA9IF9vcHRpb25zMyRpbml0aWFsRW50ciA9PT0gdm9pZCAwID8gWycvJ10gOiBfb3B0aW9uczMkaW5pdGlhbEVudHIsXG4gICAgICBpbml0aWFsSW5kZXggPSBfb3B0aW9uczMuaW5pdGlhbEluZGV4O1xuICB2YXIgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICB2YXIgbG9jYXRpb24gPSByZWFkT25seShfZXh0ZW5kcyh7XG4gICAgICBwYXRobmFtZTogJy8nLFxuICAgICAgc2VhcmNoOiAnJyxcbiAgICAgIGhhc2g6ICcnLFxuICAgICAgc3RhdGU6IG51bGwsXG4gICAgICBrZXk6IGNyZWF0ZUtleSgpXG4gICAgfSwgdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyA/IHBhcnNlUGF0aChlbnRyeSkgOiBlbnRyeSkpO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsIFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGNyZWF0ZU1lbW9yeUhpc3RvcnkoeyBpbml0aWFsRW50cmllcyB9KSAoaW52YWxpZCBlbnRyeTogXCIgKyBKU09OLnN0cmluZ2lmeShlbnRyeSkgKyBcIilcIikgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGxvY2F0aW9uO1xuICB9KTtcbiAgdmFyIGluZGV4ID0gY2xhbXAoaW5pdGlhbEluZGV4ID09IG51bGwgPyBlbnRyaWVzLmxlbmd0aCAtIDEgOiBpbml0aWFsSW5kZXgsIDAsIGVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIHZhciBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICB2YXIgbG9jYXRpb24gPSBlbnRyaWVzW2luZGV4XTtcbiAgdmFyIGxpc3RlbmVycyA9IGNyZWF0ZUV2ZW50cygpO1xuICB2YXIgYmxvY2tlcnMgPSBjcmVhdGVFdmVudHMoKTtcblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKHRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyB0byA6IGNyZWF0ZVBhdGgodG8pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TmV4dExvY2F0aW9uKHRvLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlYWRPbmx5KF9leHRlbmRzKHtcbiAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIHNlYXJjaDogJycsXG4gICAgICBoYXNoOiAnJ1xuICAgIH0sIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyBwYXJzZVBhdGgodG8pIDogdG8sIHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIGtleTogY3JlYXRlS2V5KClcbiAgICB9KSk7XG4gIH1cblxuICBmdW5jdGlvbiBhbGxvd1R4KGFjdGlvbiwgbG9jYXRpb24sIHJldHJ5KSB7XG4gICAgcmV0dXJuICFibG9ja2Vycy5sZW5ndGggfHwgKGJsb2NrZXJzLmNhbGwoe1xuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICByZXRyeTogcmV0cnlcbiAgICB9KSwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24pIHtcbiAgICBhY3Rpb24gPSBuZXh0QWN0aW9uO1xuICAgIGxvY2F0aW9uID0gbmV4dExvY2F0aW9uO1xuICAgIGxpc3RlbmVycy5jYWxsKHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKHRvLCBzdGF0ZSkge1xuICAgIHZhciBuZXh0QWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgdmFyIG5leHRMb2NhdGlvbiA9IGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpO1xuXG4gICAgZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICBwdXNoKHRvLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJywgXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gbWVtb3J5IGhpc3RvcnkucHVzaChcIiArIEpTT04uc3RyaW5naWZ5KHRvKSArIFwiKVwiKSA6IHZvaWQgMDtcblxuICAgIGlmIChhbGxvd1R4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbiwgcmV0cnkpKSB7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIGVudHJpZXMubGVuZ3RoLCBuZXh0TG9jYXRpb24pO1xuICAgICAgYXBwbHlUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UodG8sIHN0YXRlKSB7XG4gICAgdmFyIG5leHRBY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICB2YXIgbmV4dExvY2F0aW9uID0gZ2V0TmV4dExvY2F0aW9uKHRvLCBzdGF0ZSk7XG5cbiAgICBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgIHJlcGxhY2UodG8sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nLCBcIlJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBtZW1vcnkgaGlzdG9yeS5yZXBsYWNlKFwiICsgSlNPTi5zdHJpbmdpZnkodG8pICsgXCIpXCIpIDogdm9pZCAwO1xuXG4gICAgaWYgKGFsbG93VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uLCByZXRyeSkpIHtcbiAgICAgIGVudHJpZXNbaW5kZXhdID0gbmV4dExvY2F0aW9uO1xuICAgICAgYXBwbHlUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdvKGRlbHRhKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGNsYW1wKGluZGV4ICsgZGVsdGEsIDAsIGVudHJpZXMubGVuZ3RoIC0gMSk7XG4gICAgdmFyIG5leHRBY3Rpb24gPSBBY3Rpb24uUG9wO1xuICAgIHZhciBuZXh0TG9jYXRpb24gPSBlbnRyaWVzW25leHRJbmRleF07XG5cbiAgICBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24sIHJldHJ5KSkge1xuICAgICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICBhcHBseVR4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICBnZXQgYWN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9LFxuXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH0sXG5cbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgYmFjazogZnVuY3Rpb24gYmFjaygpIHtcbiAgICAgIGdvKC0xKTtcbiAgICB9LFxuICAgIGZvcndhcmQ6IGZ1bmN0aW9uIGZvcndhcmQoKSB7XG4gICAgICBnbygxKTtcbiAgICB9LFxuICAgIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH0sXG4gICAgYmxvY2s6IGZ1bmN0aW9uIGJsb2NrKGJsb2NrZXIpIHtcbiAgICAgIHJldHVybiBibG9ja2Vycy5wdXNoKGJsb2NrZXIpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBVVElMU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gY2xhbXAobiwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpO1xufVxuXG5mdW5jdGlvbiBwcm9tcHRCZWZvcmVVbmxvYWQoZXZlbnQpIHtcbiAgLy8gQ2FuY2VsIHRoZSBldmVudC5cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gQ2hyb21lIChhbmQgbGVnYWN5IElFKSByZXF1aXJlcyByZXR1cm5WYWx1ZSB0byBiZSBzZXQuXG5cbiAgZXZlbnQucmV0dXJuVmFsdWUgPSAnJztcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXZlbnRzKCkge1xuICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIGhhbmRsZXJzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgcHVzaDogZnVuY3Rpb24gcHVzaChmbikge1xuICAgICAgaGFuZGxlcnMucHVzaChmbik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBoYW5kbGVycyA9IGhhbmRsZXJzLmZpbHRlcihmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVyICE9PSBmbjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgY2FsbDogZnVuY3Rpb24gY2FsbChhcmcpIHtcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbiAmJiBmbihhcmcpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOCk7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIHN0cmluZyBVUkwgcGF0aCBmcm9tIHRoZSBnaXZlbiBwYXRobmFtZSwgc2VhcmNoLCBhbmQgaGFzaCBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZXBhdGhcclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlUGF0aChfcmVmKSB7XG4gIHZhciBfcmVmJHBhdGhuYW1lID0gX3JlZi5wYXRobmFtZSxcbiAgICAgIHBhdGhuYW1lID0gX3JlZiRwYXRobmFtZSA9PT0gdm9pZCAwID8gJy8nIDogX3JlZiRwYXRobmFtZSxcbiAgICAgIF9yZWYkc2VhcmNoID0gX3JlZi5zZWFyY2gsXG4gICAgICBzZWFyY2ggPSBfcmVmJHNlYXJjaCA9PT0gdm9pZCAwID8gJycgOiBfcmVmJHNlYXJjaCxcbiAgICAgIF9yZWYkaGFzaCA9IF9yZWYuaGFzaCxcbiAgICAgIGhhc2ggPSBfcmVmJGhhc2ggPT09IHZvaWQgMCA/ICcnIDogX3JlZiRoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaCAhPT0gJz8nKSBwYXRobmFtZSArPSBzZWFyY2guY2hhckF0KDApID09PSAnPycgPyBzZWFyY2ggOiAnPycgKyBzZWFyY2g7XG4gIGlmIChoYXNoICYmIGhhc2ggIT09ICcjJykgcGF0aG5hbWUgKz0gaGFzaC5jaGFyQXQoMCkgPT09ICcjJyA/IGhhc2ggOiAnIycgKyBoYXNoO1xuICByZXR1cm4gcGF0aG5hbWU7XG59XG4vKipcclxuICogUGFyc2VzIGEgc3RyaW5nIFVSTCBwYXRoIGludG8gaXRzIHNlcGFyYXRlIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjcGFyc2VwYXRoXHJcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgcGFyc2VkUGF0aCA9IHt9O1xuXG4gIGlmIChwYXRoKSB7XG4gICAgdmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZignIycpO1xuXG4gICAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLmhhc2ggPSBwYXRoLnN1YnN0cihoYXNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIGhhc2hJbmRleCk7XG4gICAgfVxuXG4gICAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aC5pbmRleE9mKCc/Jyk7XG5cbiAgICBpZiAoc2VhcmNoSW5kZXggPj0gMCkge1xuICAgICAgcGFyc2VkUGF0aC5zZWFyY2ggPSBwYXRoLnN1YnN0cihzZWFyY2hJbmRleCk7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgc2VhcmNoSW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChwYXRoKSB7XG4gICAgICBwYXJzZWRQYXRoLnBhdGhuYW1lID0gcGF0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFyc2VkUGF0aDtcbn1cblxuZXhwb3J0IHsgQWN0aW9uLCBjcmVhdGVCcm93c2VySGlzdG9yeSwgY3JlYXRlSGFzaEhpc3RvcnksIGNyZWF0ZU1lbW9yeUhpc3RvcnksIGNyZWF0ZVBhdGgsIHBhcnNlUGF0aCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJBY3Rpb24iLCJyZWFkT25seSIsInByb2Nlc3MiLCJvYmoiLCJPYmplY3QiLCJmcmVlemUiLCJ3YXJuaW5nIiwiY29uZCIsIm1lc3NhZ2UiLCJjb25zb2xlIiwid2FybiIsIkVycm9yIiwiZSIsIkJlZm9yZVVubG9hZEV2ZW50VHlwZSIsIkhhc2hDaGFuZ2VFdmVudFR5cGUiLCJQb3BTdGF0ZUV2ZW50VHlwZSIsImNyZWF0ZUJyb3dzZXJIaXN0b3J5Iiwib3B0aW9ucyIsIl9vcHRpb25zIiwiX29wdGlvbnMkd2luZG93Iiwid2luZG93IiwiZG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImdsb2JhbEhpc3RvcnkiLCJoaXN0b3J5IiwiZ2V0SW5kZXhBbmRMb2NhdGlvbiIsIl93aW5kb3ckbG9jYXRpb24iLCJsb2NhdGlvbiIsInBhdGhuYW1lIiwic2VhcmNoIiwiaGFzaCIsInN0YXRlIiwiaWR4IiwidXNyIiwia2V5IiwiYmxvY2tlZFBvcFR4IiwiaGFuZGxlUG9wIiwiYmxvY2tlcnMiLCJjYWxsIiwibmV4dEFjdGlvbiIsIlBvcCIsIl9nZXRJbmRleEFuZExvY2F0aW9uIiwibmV4dEluZGV4IiwibmV4dExvY2F0aW9uIiwibGVuZ3RoIiwiZGVsdGEiLCJpbmRleCIsImFjdGlvbiIsInJldHJ5IiwiZ28iLCJhcHBseVR4IiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9nZXRJbmRleEFuZExvY2F0aW9uMiIsImxpc3RlbmVycyIsImNyZWF0ZUV2ZW50cyIsInJlcGxhY2VTdGF0ZSIsImNyZWF0ZUhyZWYiLCJ0byIsImNyZWF0ZVBhdGgiLCJnZXROZXh0TG9jYXRpb24iLCJwYXJzZVBhdGgiLCJjcmVhdGVLZXkiLCJnZXRIaXN0b3J5U3RhdGVBbmRVcmwiLCJhbGxvd1R4IiwiX2dldEluZGV4QW5kTG9jYXRpb24zIiwicHVzaCIsIlB1c2giLCJfZ2V0SGlzdG9yeVN0YXRlQW5kVXIiLCJoaXN0b3J5U3RhdGUiLCJ1cmwiLCJwdXNoU3RhdGUiLCJlcnJvciIsImFzc2lnbiIsInJlcGxhY2UiLCJSZXBsYWNlIiwiX2dldEhpc3RvcnlTdGF0ZUFuZFVyMiIsImJhY2siLCJmb3J3YXJkIiwibGlzdGVuIiwibGlzdGVuZXIiLCJibG9jayIsImJsb2NrZXIiLCJ1bmJsb2NrIiwicHJvbXB0QmVmb3JlVW5sb2FkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNyZWF0ZUhhc2hIaXN0b3J5IiwiX29wdGlvbnMyIiwiX29wdGlvbnMyJHdpbmRvdyIsIl9wYXJzZVBhdGgiLCJzdWJzdHIiLCJfcGFyc2VQYXRoJHBhdGhuYW1lIiwiX3BhcnNlUGF0aCRzZWFyY2giLCJfcGFyc2VQYXRoJGhhc2giLCJfZ2V0SW5kZXhBbmRMb2NhdGlvbjQiLCJfZ2V0SW5kZXhBbmRMb2NhdGlvbjUiLCJfZ2V0SW5kZXhBbmRMb2NhdGlvbjYiLCJnZXRCYXNlSHJlZiIsImJhc2UiLCJxdWVyeVNlbGVjdG9yIiwiaHJlZiIsImdldEF0dHJpYnV0ZSIsImhhc2hJbmRleCIsImluZGV4T2YiLCJzbGljZSIsIl9nZXRJbmRleEFuZExvY2F0aW9uNyIsImNoYXJBdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJfZ2V0SGlzdG9yeVN0YXRlQW5kVXIzIiwiX2dldEhpc3RvcnlTdGF0ZUFuZFVyNCIsImNyZWF0ZU1lbW9yeUhpc3RvcnkiLCJfb3B0aW9uczMiLCJfb3B0aW9uczMkaW5pdGlhbEVudHIiLCJpbml0aWFsRW50cmllcyIsImluaXRpYWxJbmRleCIsImVudHJpZXMiLCJtYXAiLCJlbnRyeSIsImNsYW1wIiwic3BsaWNlIiwibiIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwiTWF0aCIsIm1pbiIsIm1heCIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJyZXR1cm5WYWx1ZSIsImhhbmRsZXJzIiwiZm4iLCJmaWx0ZXIiLCJoYW5kbGVyIiwiYXJnIiwiZm9yRWFjaCIsInJhbmRvbSIsInRvU3RyaW5nIiwiX3JlZiIsIl9yZWYkcGF0aG5hbWUiLCJfcmVmJHNlYXJjaCIsIl9yZWYkaGFzaCIsInBhdGgiLCJwYXJzZWRQYXRoIiwic2VhcmNoSW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/history/index.js\n");

/***/ })

};
;